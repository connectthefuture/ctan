% \iffalse    meta-comment
%
% 
%                   COPYRIGHT NOTICE AND LICENSE
% 
% 
% COPYRIGHT
% =========
% 
%    Copyright Gianfranco Boggio-Togna 2006
% 
% 
% DEFINITIONS
% ===========
% 
% In this document the following terms are used:
% 
%    `Work'
%     The files TEXNIKA.dtx, poetry.dtx, drama.dtx, technica.ins and
%     the derived files TEXNIKA.sty, poetry.sty, drama.sty
%     
%     'Copyright Holder'
%     Gianfranco Boggio-Togna
% 
%    `Derived Work'
%     Any work that under any applicable law is derived from the Work.
% 
%    `Modification' 
%     Any procedure that produces a Derived Work under any applicable
%     law -- for example, the production of a file containing an
%     original file associated with the Work or a significant portion of
%     such a file, either verbatim or with modifications and/or
%     translated into another language.
% 
%    `Modify'
%     To apply any procedure that produces a Derived Work under any
%     applicable law.
%     
%    `Distribution'
%     Making copies of the Work available from one person to another, in
%     whole or in part.  Distribution includes (but is not limited to)
%     making any electronic components of the Work accessible by
%     file transfer protocols such as FTP or HTTP or by shared file
%     systems such as Sun's Network File System (NFS).
% 
% 
% CONDITIONS ON DISTRIBUTION AND MODIFICATION
% ===========================================
% 
% 1.  You may distribute a complete, unmodified copy of the Work as you
% received it.  Distribution of only part of the Work is considered
% modification of the Work, and no right to distribute such a Derived
% Work may be assumed under the terms of this clause.
% 
% 2. The Copyright Holder may, without restriction, modify the Work,
% thus creating a Derived Work. The Copyright Holder may also distribute
% the Derived Work without restriction. Derived Works distributed in
% this manner by the Copyright Holder are considered to be updated
% versions of the Work.
% 
% 3.  If you are not the Copyright Holder, you are not allowed
% to modify the Work.
% 
% 4.  The conditions above are not intended to prohibit, and hence do
% not apply to, the modification, by any method, of any component so that it
% becomes identical to an  updated version of that component of the Work as
% it is distributed by the Copyright Holder under Clause 2, above.
% 
% 5. Distribution of the Work in an alternative format, where the Work
% is then produced by applying some process to that format, does not
% relax or nullify any sections of this license as they pertain to the
% results of applying that process.
% 
% 6. This license places no restrictions on works that are unrelated to
% the Work, nor does this license place any restrictions on aggregating
% such works with the Work by any means.
% 
% 7.  Nothing in this license is intended to, or may be used to, prevent
% complete compliance by all parties with all applicable laws.
% 
% 
% CONDITIONS ON USE
% =================
% 
% The Work may be used without charge for non-commercial private
% or academic purposes. Use of the Work for commercial purposes is
% prohibited. To use the Work for commercial purposes you must obtain a
% license for commercial use from the Copyright Holder.
% 
% 
% NO WARRANTY
% ===========
% 
% There is no warranty for the Work.  Except when otherwise stated in
% writing, the Copyright Holder provides the Work `as is', without
% warranty of any kind, either expressed or implied, including, but not
% limited to, the implied warranties of merchantability and fitness for
% a particular purpose.  The entire risk as to the quality and performance
% of the Work is with you.  Should the Work prove defective, you
% assume the cost of all necessary servicing, repair, or correction.
% 
% In no event unless agreed to in writing will the Copyright Holder or
% any other party who may distribute the Work as permitted above, be
% liable to you for damages, including any general, special, incidental
% or consequential damages arising out of any use of the Work or out
% of inability to use the Work (including, but not limited to, loss of
% data, data being rendered inaccurate, or losses sustained by anyone
% as a result of any failure of the Work to operate with any other
% programs), even if the Copyright Holder or said other party has been
% advised of the possibility of such damages.
% 
%<*driver>
\documentclass{ltxdoc}
\setlength{\parindent}{0pt}
\setlength{\textwidth}{5.5in}
\setlength{\textheight}{8.5in}
\setlength{\parskip}{\smallskipamount}
\usepackage[ibycus,english]{babel}
\usepackage[pagestyles]{titlesec}
\newpagestyle {POETRY@page} {

  \sethead   {}
             {\large {\itshape The} \texttt{poetry} {\itshape package}} 
             {\textup{\thepage}}
  \setfoot   {}
             {Copyright \copyright\ Gianfranco Boggio--Togna 2006}
             {}%
  \setmarks  {section}{subsection}
}
\MakeShortVerb{|}
\AlsoImplementation
\begin{document}
\DocInput{poetry.dtx}
\end{document}
%</driver>
%
% \fi
% \iftrue \CheckSum{4592} \fi
%
% \def\fileversion{0.9}
% \def\filedate{2006/11/11}
%
\def\TEXNIKA {%
  \expandafter
  \ifx \csname l@polutonikogreek\endcsname \relax
    \expandafter
    \ifx \csname l@ibycus\endcsname \relax
       $\tau\kern-.05em\epsilon\chi\nu\kern-.05em\iota
       \kappa\kern.04em\acute\alpha$%
    \else
      \foreignlanguage{ibycus}{texnika'}%
    \fi
  \else
      \foreignlanguage{polutonikogreek}{teqnik'a}%
  \fi
}
\def \TeXbook {\textit{The \TeX{}book}{}}
\def \TXN@cmd#1{\texttt{\protect\bslash #1}}%
%
%
% \thispagestyle{empty}
% \begin{centering}
% {\large \textsc{Gianfranco Boggio\,--Togna}}\par
% \vspace*{1in}
% {\Huge \TEXNIKA}\par 
% \vspace*{.15in}
% {\LARGE Typesetting for the Humanities}\par
% \vspace*{.5in}
% {\Large The \textbf{poetry} package}\par
% \vfill
% {\Large Version 0.9}\par
% \end{centering}
% \newpage
% \thispagestyle{empty}
% \vspace{6ex}
% \section*{Copyright notice}
% \noindent Copyright \copyright\ Gianfranco Boggio--Togna 2006\par
%        Author's address: C.P. 14021, I-20140 Milano\\
%                  Email: \textsl{gbt\kern .08em @\kern .1em acm.org}
% \vspace{6ex}
% \section*{License}
% \noindent This program is distributed under the terms of the license
% that appears at the start of the file \texttt{poetry.dtx} (this file)
% and in file \texttt{license.txt} 
%  
% This program consists of the files \texttt{poetry.dtx} and 
% \texttt{technica.ins} 
%  
% \newpage
% \pagenumbering{roman}
% \tableofcontents
% \newpage
% \pagenumbering{arabic}
% \pagestyle {POETRY@page} 
% 
% \StopEventually{}
%
% \newpage
% \section{External dependencies}
%    \begin{macrocode}
\def \TXN@temp {LaTeX2e}
\def \TXN@temp@bis {2003/12/01}
\@tempswafalse
\ifx \fmtname \TXN@temp
  \ifx \fmtversion \TXN@temp@bis
  \else
    \def \TXN@temp@bis {2005/12/01}
    \ifx \fmtversion \TXN@temp@bis
    \else
      \@tempswatrue
    \fi
  \fi
\else
    \@tempswatrue
\fi
\if@tempswa
   \PackageError {POETRY}
     {The Technica suite requires the LaTex\MessageBreak
      release dated `2003/12/01' or `2005/12/01'}
     {}
   \def\recurse{(\recurse)}\recurse
\fi
%    \end{macrocode}
%
%    \begin{macrocode}
\ProvidesPackage{poetry}%
  [2006/11/11 v. 0.9 A package for typesetting poetry]
\DeclareOption {repeat} {\PassOptionsToPackage{repeat}{TEXNIKA}}
\DeclareOption {lineno} {\PassOptionsToPackage{lineno}{TEXNIKA}}
\DeclareOption {nowarnings} {\PassOptionsToPackage{nowarnings}{TEXNIKA}}
\DeclareOption {inplacewarnings}
  {\PassOptionsToPackage{inplacewarnings}{TEXNIKA}}
\ProcessOptions
\RequirePackage{TEXNIKA}
%    \end{macrocode}
%
% \section{The main program} 
% \subsection{Initialize} 
%
% Create the structures for |\excessus|.
%    \begin{macrocode}
  \TXN@internaltrue
  \Novus \textus[\TXN@e] \excessus
  \TXN@internalfalse
  \TXN@def {TXN@textus[\TXN@e]text}{\unhbox \PTR@box@excessus}
%    \end{macrocode}
% Define the indentation unit.
%    \begin{macrocode}
  \gdef \PTR@stropha@unit {1em}%
%    \end{macrocode}
%
%    \begin{macrocode}
\AtBeginDocument {%
%    \end{macrocode}
% Initialize the variables required for handling multi-split lines.
%    \begin{macrocode}
  \xdef \PTR@SpatiumEscEsc@corr {\the\maxdimen}%
  \gdef \PTR@multisplit@cs {0}%
  \ifnum \TXN@pass = \tw@
    \PTR@multisplit@next
  \fi
}
%    \end{macrocode}
% \subsection{Enter \textit{versus}} 
%    \begin{macrocode}
\newif \ifPTR@first@line
\newif \ifPTR@suspend
\def \versus {\TXN@domain@enter 1}
\def \PTR@versus {%
%<debug>  \TXN@trace \PTR@versus
  \TXN@withinVersustrue
  \ifTXN@folio@set
  \else
    \xdef \TXN@theFolio {\ifodd \c@page recto\else verso\fi}%
    \global \TXN@folio@settrue
  \fi
  \ifTXN@lineating
    \TXNl@lineate \TXN@process@line
  \fi
  \let \PTR@versus@esc@esc = \\\relax
%    \end{macrocode}
% All paragraph spacing is suppressed: |\parskip| has an 
% infinitesimal amount of stretchability to compensate for
% (equally infinitesimal) rounding errors in computing the page height.
%    \begin{macrocode}
  \edef \PTR@versus@parindent {\the\parindent}%
  \edef \PTR@versus@parskip   {\the\parskip}%
  \parindent = \z@
  \parskip = \z@ plus 1sp minus 1sp\relax 
  \endgraf
  \xdef \PTR@lastskip {\maxdimen}%
%    \end{macrocode}
% If suspended, do not initialize the domain info
%    \begin{macrocode}
  \ifPTR@suspend
  \else
    \xdef \MaxLineWidth {-\maxdimen}%
    \xdef \MinLineWidth {\maxdimen}%
    \xdef \MaxLineShift {-\maxdimen}%
    \xdef \MinLineShift {\maxdimen}%
  \fi
%    \end{macrocode}
% Set up for auto |\Locus|.
%    \begin{macrocode}
  \ifPTR@auto@no
    \let \PTR@save@auto@def = \auto
    \def \auto {}%
  \else
    \ifx \empty \PTR@auto@mode 
    \else
      \ifPTR@suspend
        \PTR@suspendfalse
      \else
        \let \PTR@save@auto@def = \auto
        \PTR@auto@setup
      \fi
    \fi
  \fi
%    \end{macrocode}
% If suspended, resume
%    \begin{macrocode}
  \ifPTR@suspend
    \PTR@suspendfalse
  \fi
%    \end{macrocode}
% Start fetching lines.
%    \begin{macrocode}
  \global \PTR@first@linetrue
  \PTR@fetch@line
}
\newcommand {\NotFirstLine}{\global \PTR@first@linefalse}
\newcommand {\FirstLine}{\global \PTR@first@linetrue}
\let \Versus = \versus
%    \end{macrocode}
% \subsection{Fetch a line} 
% The mechanism for fetching a line is basically that of the dirty trick
% with tabs on page 391 of \TeXbook: |\everypar| traps the start of a line
% and opens an hbox; end-of-line, made active, closes the box.  In most cases, 
% the whole line fits in a single box, but the |\\| command and the commands
% in \textsl{drama} put parts of the line into separate boxes.
%
% The boxes come from this set. Reserving ten boxes is something of
% an overkill, as no more than three or four are usually needed; but
% pathological lines of drama may contain several embedded stage directions.
% The boxes are assumed to be in a continuous range; we do not bother
% to check this, as it is inconceivable that \LaTeX{} should start
% allocating boxes non contiguously.
%    \begin{macrocode}
\newbox  \PTR@box@line      
\newbox  \PTR@box@line@ii      
\newbox  \PTR@box@line@iii      
\newbox  \PTR@box@line@iv      
\newbox  \PTR@box@line@v      
\newbox  \PTR@box@line@vi      
\newbox  \PTR@box@line@vii      
\newbox  \PTR@box@line@viii      
\newbox  \PTR@box@line@ix      
%    \end{macrocode}
% We need an index to keep track of where we are in the set.
%    \begin{macrocode}
\newcount \PTR@box@ind
%    \end{macrocode}
% There are five types of boxes: (\textit{Caution} These values are used in an
% |\ifcase|).
%    \begin{macrocode}
\chardef \PTR@box@text               = 0 
\chardef \PTR@box@persona            = 1 
\chardef \PTR@box@bracketSD          = 2 
\chardef \PTR@box@persona@bracketSD  = 3 
\chardef \PTR@box@split              = 4 
%    \end{macrocode}
% The box flags (only used by \textsl{Drama}) are stored in:\\ 
% |\@namedef{PTR@box@flags\the\PTR@box@ind}|
%
% \halign {\quad\tt#&\kern 4em#\hfill\cr
% l&   align left (persona and bracket)     \cr
% r&   align right (bracket)                \cr
% c&   center (bracket)                     \cr
% b&   bracket at beginning of speech       \cr
% m&   bracket in the middle of a speech    \cr
% d&   detached bracket                     \cr
% a&   suppress SpatiumAnte bracket         \cr
% p&   suppress SpatiumPost bracket         \cr
% }
% The box type is stored in: |\@namedef{PTR@box@type\the\PTR@box@ind}|
%
% The box contents, (only used by \textsl{Drama} for b-SDs)
% are stored in:\\ 
% |\@namedef{PTR@box@toks\the\PTR@box@ind}|
%
% Two boxes (always use globally) for assembling and disassembling
% a set of lines
%    \begin{macrocode}
\newbox \PTR@vbox
\newbox \PTR@hbox
%    \end{macrocode}
%
% This sets the machine in motion.
%    \begin{macrocode}
\def \PTR@fetch@line {%
  \PTR@box@ind = \PTR@box@line
  \xdef \TXN@line@length {}%
  \global \PTR@explicit@indent = \z@skip
  \let \PTR@save@esc@esc = \\\relax
  \def \\{\leavevmode\PTR@esc@esc}%
  \everypar = {\PTR@start@box}%
  \PTR@obeylines
}
%    \end{macrocode}
% At the end of the line, we need to know if any text was found.
%    \begin{macrocode}
\newif \ifPTR@par@started
%    \end{macrocode}
% This macros is usually empty. It is set to |\ignorespaces| 
% before and after a b-SD.
%    \begin{macrocode}
\gdef \PTR@ignorespaces {}%
%    \end{macrocode}
% Start a box.
%    \begin{macrocode}
\def \PTR@start@box {%
%<debug>  \TXN@trace \PTR@start@box
  \global \PTR@par@startedtrue
  \TXN@edef {PTR@box@type\the\PTR@box@ind}{\PTR@box@text}%
  \TXN@def  {PTR@box@flags\the\PTR@box@ind}{}%
  \TXN@def  {PTR@box@toks\the\PTR@box@ind}{}%
  \def \\{\leavevmode\PTR@esc@esc}%
  \setbox \PTR@box@ind = \hbox \bgroup
    \csname TXN@textus[\TXN@theTextus]Facies\endcsname \relax
    \ifnum \PTR@box@ind = \PTR@box@line
      \global \PTR@em = 1em\relax
      \xdef \PTR@strut@ht {\the\ht\strutbox}%
    \fi
    \strut \PTR@ignorespaces \TXN@check@incipit 
}
%    \end{macrocode}
% The definition of end-of-line when active.
%    \begin{macrocode}
\def \PTR@atendofline {%
%<debug>  \TXN@trace \PTR@atendofline
  \ifPTR@par@started
    \egroup 
    \let \\= \PTR@save@esc@esc 
    \everypar = {}\TXN@normalCR
    \ifdim \wd\PTR@box@ind = \z@
      \advance \PTR@box@ind by \m@ne
    \fi  
%<debug>  \PTR@showboxes
    \PTR@process@line
  \else
    \dimen@ = \lastskip
    \xdef \PTR@lastskip {\the\dimen@}%
    \ifTXN@after@Spatium
    \else
      \global \TXN@blank@linetrue
    \fi
  \fi
  \global \TXN@after@Spatiumfalse
  \global \PTR@par@startedfalse
}
%    \end{macrocode}
% Make end-of-line active.
%    \begin{macrocode}
\begingroup
  \TXN@activeCR % CR is active!
  \gdef \PTR@obeylines {%
    \TXN@activeCR \let^^M=\PTR@atendofline}%
\endgroup
%    \end{macrocode}
% Close a box, setting type and flags.
%    \begin{macrocode}
\def \PTR@close@box #1#2{%
%<debug>  \TXN@trace \PTR@close@box
   \egroup
   \gdef \PTR@ignorespaces {}%
   \TXN@edef {PTR@box@type\the\PTR@box@ind}{#1}%
   \TXN@edef {PTR@box@flags\the\PTR@box@ind}{#2}%
}
%    \end{macrocode}
% Advance to next box.
%    \begin{macrocode}
\def \PTR@next@box {%
%<debug>  \TXN@trace \PTR@next@box
   \advance \PTR@box@ind by \@ne
   \PTR@start@box 
}
%    \end{macrocode}
% Outside \textsl{drama} only |\\| can cause the line to be split
% over two or three boxes. |\\| generates an empty box, whose width
% is not zero if the optional parameter is present. 
%    \begin{macrocode}
\newif \ifPTR@initial@esc@esc
\newif \ifPTR@esc@esc@star
%    \end{macrocode}
%
%    \begin{macrocode}
\def \PTR@esc@esc {%
%<debug>  \TXN@trace \PTR@esc@esc
  \ifPTR@par@started
    \unskip \egroup 
  \fi
  \PTR@initial@esc@escfalse
  \ifdim \wd\PTR@box@ind = \z@
    \ifnum \PTR@box@ind = \PTR@box@line
      \PTR@initial@esc@esctrue
    \fi
  \fi
  \@ifstar {\PTR@esc@esc@startrue\PTR@esc@esc@bis}
           {\PTR@esc@esc@starfalse\PTR@esc@esc@bis}%
}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand {\PTR@esc@esc@bis}[1][\relax]{%
%<debug>  \TXN@trace \PTR@esc@esc@bis
  \def \TXN@parameter {#1}%
  \dimen@@ = \maxdimen
  \ifPTR@initial@esc@esc
    \dimen@ = \PTR@stropha@unit \TXN@safe
  \else
    \setbox\z@ = \hbox {\TXN@SpatiumPostEscEsc}%
    \dimen@ = \wd\z@
  \fi
  \ifPTR@esc@esc@star
    \multiply \dimen@ by \ifx \TXN@parameter \TXN@safe \tw@ \else #1\fi
  \else
    \ifx \TXN@parameter \TXN@safe
    \else
      \PTR@esc@esc@width #1\TXN@nil
    \fi
  \fi
  \ifPTR@initial@esc@esc
    \ifdim \dimen@@ < \maxdimen
      \dimen@ = \dimen@@
    \fi
    \global \PTR@explicit@indent = \dimen@ \TXN@safe
    \expandafter \PTR@start@box
  \else
    \ifdim \wd\PTR@box@ind > \z@
      \advance \PTR@box@ind by \@ne
    \fi  
    \setbox \PTR@box@ind = \null
    \TXN@edef {PTR@box@type\the\PTR@box@ind}{\PTR@box@split}%
    \TXN@def {PTR@box@flags\the\PTR@box@ind}{}%
    \ifdim \dimen@@ < \maxdimen
      \advance \dimen@ by \dimen@@
      \wd\PTR@box@ind = -\dimen@
    \else
      \wd\PTR@box@ind = \dimen@
    \fi
    \expandafter \PTR@next@box
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \PTR@esc@esc@width #1#2\TXN@nil{%
%<debug>  \TXN@trace \PTR@esc@esc@width
  \ifx -#1\relax
    \setbox \z@ = \hbox {#2}%
    \wd\z@ = -\wd\z@
  \else
    \setbox \z@ = \hbox {%
      \csname TXN@textus[\TXN@theTextus]Facies\endcsname \relax
      #1#2}%
  \fi
  \dimen@@ = \wd\z@
}
%    \end{macrocode}
% \newpage
% \subsection{Process a line} 
% The line is assembled in this box:
%    \begin{macrocode}
\newbox   \PTR@box@full@line      
%    \end{macrocode}
% Two macros for adding stuff to the box:
%    \begin{macrocode}
\def \PTR@append #1{\setbox \PTR@box@full@line = 
  \hbox {\unhbox \PTR@box@full@line#1}}
\def \PTR@prepend #1{\setbox \PTR@box@full@line =  
  \hbox {#1\unhbox \PTR@box@full@line}}
%    \end{macrocode}
% A box for the part of the text being moved to another line:
%    \begin{macrocode}
\newbox   \PTR@box@excessus      
%    \end{macrocode}
% \texttt{1em} for |\textus|
%    \begin{macrocode}
\newdimen \PTR@em
%    \end{macrocode}
% Though the values are actually \meta{dimen}, we allocate \meta{skip}
% registers, as more of these are available.
%
% The indentation set by |\Forma \strophae|:
%    \begin{macrocode}
\newskip  \PTR@stropha@indent
%    \end{macrocode}
% The explicit indentation set by |\\|:
%    \begin{macrocode}
\newskip  \PTR@explicit@indent
%    \end{macrocode}
% The indentation for a speech, set by |\Forma \personae|:
%    \begin{macrocode}
\newskip  \PTR@speech@indent
%    \end{macrocode}
% The |\textus| shift:
%    \begin{macrocode}
\newskip  \PTR@textus@shift
%    \end{macrocode}
% The total indentation for text:
%    \begin{macrocode}
\newskip  \PTR@text@indent
%    \end{macrocode}
% The length of the fragment on the previous line:
%    \begin{macrocode}
\newskip  \PTR@split@skip
%    \end{macrocode}
% The length of the fragment on this line:
%    \begin{macrocode}
\newskip  \PTR@next@split@skip
\global   \PTR@next@split@skip = \z@skip
%    \end{macrocode}
% The total size of text on the line:
%    \begin{macrocode}
\newskip  \PTR@text@width
%    \end{macrocode}
% Counting the line in a strophe.
%    \begin{macrocode}
\newcount \PTR@stropha@counter
%    \end{macrocode}
% True at the end of a strophe.
%    \begin{macrocode}
\newif \ifPTR@after@stropha
%    \end{macrocode}
% True is the box cannot be typeset properly.
%    \begin{macrocode}
\newif \ifPTR@overfull@box
%    \end{macrocode}
% Process the line just fetched.
%    \begin{macrocode}
\def \PTR@process@line {%
%<debug>  \TXN@trace \PTR@process@line
%<debug>  \TXN@trace@mode [process line]%
%    \end{macrocode}
% Housekeeping.
%    \begin{macrocode}
  \setbox \PTR@box@full@line  = \copy\voidb@x
  \PTR@text@width = \z@skip
  \setbox \TXN@marginalia  = \copy\voidb@x
  \setbox \PTR@box@excessus = \null      
  \def \PTR@r@bracketSD@ind {}%
  \def \TXN@line@class {}%
%    \end{macrocode}
%
%    \begin{macrocode}
  \PTR@after@strophafalse
  \PTR@overfull@boxfalse
  \def \PTR@folded@line {}%
%    \end{macrocode}
%
%    \begin{macrocode}
  \TXN@assign \TXN@measure = {TXN@textus[\TXN@theTextus]measure}%
  \PTR@text@width = \z@skip
  \global \TXN@leading@space = \maxdimen
  \PTR@stropha@indent = \maxdimen \TXN@safe
  \PTR@speech@indent =  \z@skip
  \TXN@assign \PTR@textus@shift = {TXN@textus[\TXN@theTextus]shift}%
  \PTR@text@indent = \maxdimen \TXN@safe
  \TXN@get@Locus {textus[\TXN@e]}{t}%
  \edef \PTR@locus@excessus {\the\dimen@}%
%    \end{macrocode}
%
%    \begin{macrocode}
  \gdef \PTR@SpatiumInfra@line {}%
  \gdef \PTR@SpatiumSupra@line {}%
  \def \PTR@hfill@right {\z@}%
  \def \PTR@hfill@left {\z@}%
%    \end{macrocode}
% If the previous line ended with |\\|, this is the width of the
% text before |\\|, otherwise zero.
%    \begin{macrocode}
  \global \PTR@split@skip = \PTR@next@split@skip
%    \end{macrocode}
% Set the parameters defining the shape of a speech.
%    \begin{macrocode}
  \ifTXN@withinDrama
    \begingroup
      \DRM@FormaPersonae
      \xdef \PTR@parindent  {\the\parindent}%
      \xdef \PTR@hangindent {\the\hangindent}%
      \xdef \PTR@hangafter  {\the\hangafter}%
    \endgroup
    \PTR@get@speech@indent \@ne
    \edef \PTR@speech@indent@one {\the\PTR@speech@indent}%
    \PTR@get@speech@indent \tw@
    \edef \PTR@speech@indent@two {\the\PTR@speech@indent}%
  \fi
%    \end{macrocode}
%  Save the initial value of the stropha counter.
%    \begin{macrocode}
  \edef \PTR@save@stropha@counter {\the\PTR@stropha@counter}%
%    \end{macrocode}
% Join the pieces and typeset the complete line.
%    \begin{macrocode}
  \PTR@assemble@line 
  \ifvoid \PTR@box@full@line 
    \ifx \empty \PTR@r@bracketSD@ind 
    \else
      \PTR@typeset@line
    \fi
  \else
    \PTR@typeset@line
  \fi
%    \end{macrocode}
% Final clean up.
%    \begin{macrocode}
  \global \TXN@blank@linefalse
  \ifTXN@withinDrama
    \TXN@gincr \DRM@speech@lines
  \fi
%    \end{macrocode}
% Go fetch the next line.
%    \begin{macrocode}
  \PTR@fetch@line
}
%    \end{macrocode}
% \subsection{Leave \textit{versus}} 
%    \begin{macrocode}
\def \endversus {\TXN@domain@leave 1}
\let \endVersus = \endversus
\def \PTR@endversus {%
%<debug>  \TXN@trace \PTR@endversus 
  \ifPTR@par@started \egroup \fi
  \endgraf
  \TXN@withinVersusfalse
  \ifTXN@lineating
    \TXNl@lineate \relax
  \fi
  \parindent =  \PTR@versus@parindent \TXN@safe
  \parskip =  \PTR@versus@parskip \TXN@safe
  \let \\= \PTR@versus@esc@esc
  \ifPTR@suspend
    \PTR@suspendfalse
  \else
    \PTR@auto@record
  \fi
  \everypar = {}\TXN@normalCR
  \ifnum \TXN@numerus@pending > \z@
    \TXN@Warning* {One or more line numbers could not be printed\MessageBreak
                  (there is not enough room in the line)}%
    \def \TXN@numerus@pending {0}%
    {\parskip \z@ \par}%
  \fi
}
%    \end{macrocode}
% \newpage
% \section{The \texttt{\char`\\stropha} class} 
% \subsection{The \texttt{\char`\\stropha} command} 
%
% Initialize the attributes.
%    \begin{macrocode}
\def \PTR@FormaStrophae {}
\def \PTR@FaciesStrophae {}
\def \PTR@SpatiumSupraStropham {}
\def \PTR@SpatiumInfraStropham {}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand {\stropha} {%
  \ifx \empty \TXN@attribute@name 
    \expandafter \PTR@stropha
  \else
    \def \TXN@subclass@name {stropha}%
    \def \TXN@subclass@number {}%
    \def \TXN@temp {PTR}%
    \expandafter \TXN@attribute@set
  \fi
}
%    \end{macrocode}
% Some synonyms.
%    \begin{macrocode}
\let \strophae = \stropha
\let \stropham = \stropha
%    \end{macrocode}
%
% The variable is set to 2 by an explicit |\stropha| command. It changes to 1
% after the start of stropha has been processed (to prevent activation of
% the normal mechanism) and is cleared by |\stropha*|, or by exiting a group
% if |\stropha| appeared within a group.
%
%    \begin{macrocode}
\def \PTR@explicit@stropha {0}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \PTR@stropha {%
%<debug>  \TXN@trace \PTR@stropha
  \global \PTR@stropha@counter = \z@
  \def \PTR@explicit@stropha {0}%
  \@ifstar {}{\PTR@stropha@bis}%
}
%    \end{macrocode}
% The normal form (explicit or phantom strophe).
%    \begin{macrocode}
\newcommand {\PTR@stropha@bis}[1][\relax]{%
%<debug>  \TXN@trace \PTR@stropha@bis
  \def \TXN@parameter {#1}%
  \ifx \TXN@parameter \TXN@safe
    \def \PTR@explicit@stropha {2}%
  \else
    \toks@ = {#1}%
    \expandafter \PTR@phantom@stropha 
  \fi
}
%    \end{macrocode}
% A `phantom' stropha.
%    \begin{macrocode}
\newif \ifPTR@phantom@text
\def \PTR@phantom@stropha #1{
%<debug>  \TXN@trace \PTR@phantom@stropha
    \def \TXN@parameter {#1}%
    \PTR@phantom@texttrue
    \ifx \empty \TXN@parameter 
      \PTR@phantom@textfalse
    \fi
    \TXN@counter = \PTR@stropha@start \TXN@safe
    \TXN@counter@a = \PTR@stropha@length \TXN@safe
    \ifnum \TXN@counter < \z@
      \TXN@counter = -\TXN@counter
    \fi
    \advance \TXN@counter@a by -\TXN@counter
    \ifPTR@phantom@text
      \advance \TXN@counter by \m@ne
      \advance \TXN@counter@a by \m@ne
    \fi
    \global \PTR@stropha@counter = \TXN@counter
    \TXN@toks@a = {}%
    \TXN@toks@b = {}%
    \expandafter \PTR@phantom@stropha@bis \the\toks@\TXN@nil
    \ifPTR@phantom@text
      \TXN@spatium@vertical \PTR@SpatiumSupraStropham
    \fi
    \the\TXN@toks@b#1\the\TXN@toks@a 
}
%    \end{macrocode}
% Update the |\numerus| counters
%    \begin{macrocode}
\def \PTR@phantom@stropha@bis #1{%
  \ifx \TXN@nil #1\relax
  \else
    \edef \TXN@temp {\the\TXN@toks@a \noexpand#1{+\the\TXN@counter@a}}%
    \TXN@toks@a = \expandafter {\TXN@temp}%
    \TXN@toks@b = \expandafter {\the\TXN@toks@b #1*{}}%
    \expandafter \PTR@phantom@stropha@bis 
  \fi
}
%    \end{macrocode}
% \subsection{The \texttt{\char`\\Forma} attribute} 
%    \begin{macrocode}
\newif \ifPTR@stropha@skip@pending
\newif \ifPTR@stropha@dup@pending
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand {\PTR@setForma@stropha} [1][0] {%
%<debug>  \TXN@trace \PTR@setForma@stropha
  \let \PTR@save@stropha@esc@esc = \\\relax
  \edef \PTR@stropha@length  {#1}%
%    \end{macrocode}
% Restore normal end-of-line while the parameter is read.
%    \begin{macrocode}
  \ifTXN@withinVersus
    \TXN@normalCR
  \fi
  \PTR@setForma@stropha@bis
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \PTR@setForma@stropha@bis #1{%
  \ifTXN@withinVersus
    \TXN@activeCR
  \fi
  \TXN@SimpleList \TXN@SimpleList@work \z@
  \global \PTR@stropha@counter = \z@ 
  \def \PTR@stropha@break {\z@}%
  \def \PTR@stropha@start {\z@}%
  \PTR@stropha@skip@pendingfalse
  \PTR@stropha@dup@pendingfalse
  \PTR@setForma@stropha@ter #1\TXN@nil
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \PTR@setForma@stropha@ter #1{%
   \let \\= \relax
   \let \PTR@stropha@next = \PTR@setForma@stropha@ter
   \ifx \TXN@nil#1\relax
     \let \PTR@stropha@next = \PTR@setForma@stropha@extend
   \else \ifx /#1\relax 
     \edef \PTR@stropha@break {\the\PTR@stropha@counter}%
   \else \ifx (#1\relax 
     \edef \PTR@stropha@start {\the\PTR@stropha@counter}%
   \else \ifx )#1\relax 
     \relax
   \else \ifx *#1\relax 
     \PTR@stropha@dup@pendingtrue
   \else \ifx \\#1\relax 
     \let \PTR@stropha@next = \PTR@get@stropha@unit
   \else \ifPTR@stropha@dup@pending
     \PTR@stropha@dup@pendingfalse
     \TXN@counter = \@ne
     \loop
     \ifnum \TXN@counter < #1\relax
       \TXN@SimpleList@append \TXN@SimpleList@work {\the\TXN@toks@a}%
       \global \advance \PTR@stropha@counter by \@ne
       \advance \TXN@counter by \@ne
     \repeat
   \else
     \TXN@sw@false
     \ifx c#1\relax \else
     \ifx C#1\relax \else
     \ifx z#1\relax \else
     \ifx Z#1\relax \else
       \PTR@stropha@check@spatium {#1}%
       \ifTXN@sw 
         \TXN@build@spatium@list {#1}%
       \fi
     \fi\fi\fi\fi
     \ifTXN@sw
       \PTR@stropha@skip@pendingtrue
       \expandafter \TXN@toks@b \expandafter {\TXN@L@spatium}%
     \else
       \ifPTR@stropha@skip@pending
         \TXN@SimpleList@append \TXN@SimpleList@work {\the\TXN@toks@b}%
         \PTR@stropha@skip@pendingfalse
       \fi
       \global \advance \PTR@stropha@counter by \@ne
       \TXN@toks@a = {#1}%
       \ifx c#1\relax
         \TXN@toks@a = {-10000}%
       \fi
       \ifx C#1\relax
         \TXN@toks@a = {-10000}%
       \fi
       \ifx z#1\relax
         \TXN@toks@a = {-9999}%
       \fi
       \ifx Z#1\relax
         \TXN@toks@a = {-9999}%
       \fi
       \TXN@SimpleList@append \TXN@SimpleList@work {\the\TXN@toks@a}%
     \fi
   \fi\fi\fi\fi\fi\fi\fi
   \PTR@stropha@next
}
%    \end{macrocode}
% Check whether the value is a |\spatium| specification (i.e. contains
% at least a letter or a control sequence)
%    \begin{macrocode}
\def \PTR@stropha@check@spatium #1{%
  \PTR@stropha@check@spatium@bis #1\TXN@nil
}
\def \PTR@stropha@check@spatium@bis #1{%
  \let \next = \PTR@stropha@check@spatium@ter
  \ifx \TXN@nil #1\relax
    \let \next = \relax
  \else
    \ifcat \relax \noexpand#1\relax
      \TXN@sw@true
    \else
      \ifcat a\noexpand#1\relax
        \TXN@sw@true
      \else
        \let \next = \PTR@stropha@check@spatium@bis
      \fi
    \fi
  \fi
  \next
}
\def \PTR@stropha@check@spatium@ter #1\TXN@nil{}%
%    \end{macrocode}
% Extend the list to the length given in the optional parameter (if any)
% by replicating the last entry as necessary.\\
% |\TXN@toks@a| contains the last value\\ 
% |\TXN@toks@b| may contain the pending skip (which can be inserted
% only after the list has been extended). 
%    \begin{macrocode}
\def \PTR@setForma@stropha@extend {%
  \ifnum \PTR@stropha@counter = \z@
  \else
    \TXN@counter@a = \PTR@stropha@length \TXN@safe
    \advance \TXN@counter@a by \PTR@stropha@start \TXN@safe
    \loop
    \ifnum \PTR@stropha@counter < \TXN@counter@a 
      \TXN@SimpleList@append \TXN@SimpleList@work {\the\TXN@toks@a}%
      \global \advance \PTR@stropha@counter by \@ne  
    \repeat 
    \ifPTR@stropha@skip@pending
      \TXN@SimpleList@append \TXN@SimpleList@work {\the\TXN@toks@b}%
    \fi
    \edef \PTR@stropha@length {\the\PTR@stropha@counter}%
    \TXN@SimpleList@append \TXN@SimpleList@work {10000}%
  \fi
  \global \PTR@stropha@counter = \z@
  \edef \PTR@FormaStrophae {\TXN@SimpleList@work}%
  \let \\= \PTR@save@stropha@esc@esc
}
%    \end{macrocode}
% Set the stropha indent unit.
%    \begin{macrocode}
\def \PTR@get@stropha@unit #1\TXN@nil{%
  \TXN@check@if@glue #1\TXN@nil  
  \ifTXN@sw
    \xdef \PTR@stropha@unit  {#1}%
  \else
    \PackageError {POETRY}
      {The value you have specified for the \MessageBreak
       indentation unit is not a legal TeX dimension.}%
      {You may have forgotten the unit of measure\MessageBreak
       or mispelled its name.}%
  \fi
  \PTR@setForma@stropha@extend
}
%    \end{macrocode}
% \subsection{The other attributes} 
%    \begin{macrocode}
\def \PTR@setFacies@stropha #1{%
  \def \TXN@parameter {#1}%
  \ifx \empty \TXN@parameter
    \def \PTR@FaciesStrophae {}%
  \else
    \def \PTR@FaciesStrophae {#1\relax\vskip \z@}%
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \PTR@setSpatiumSupra@stropha #1{% 
  \def \TXN@parameter {#1}%
  \ifx \empty \TXN@parameter
    \def \PTR@SpatiumSupraStropham {}%
  \else
    \TXN@build@spatium@list {#1}%
    \edef \PTR@SpatiumSupraStropham {\TXN@L@spatium}%
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \PTR@setSpatiumInfra@stropha #1{% 
  \def \TXN@parameter {#1}%
  \ifx \empty \TXN@parameter
    \def \PTR@SpatiumInfraStropham {}%
  \else
    \TXN@build@spatium@list {#1}%
    \edef \PTR@SpatiumInfraStropham {\TXN@L@spatium}%
  \fi
}
%    \end{macrocode}
% \section{\textit{Processing the line}} 
% \subsection{Assemble the line} 
%
% This is a fragment (other than the first) of a split line.
%    \begin{macrocode}
\newif \ifPTR@is@fragment
%    \end{macrocode}
%
% The first box is \texttt{persona} or \texttt{persona} + \texttt{b-SD}.
%    \begin{macrocode}
\newif \ifPTR@speech@heading
%    \end{macrocode}
%
% The line contains a SD.
%    \begin{macrocode}
\newif \ifPTR@has@SD
%    \end{macrocode}
%
%    \begin{macrocode}
\def \PTR@cannot@typeset@properly {%
  \TXN@Warning* {The line cannot be typeset properly.\MessageBreak
                 Manual intervention is necessary}%  
}
\def \PTR@assemble@line {%
%<debug>  \TXN@trace \PTR@assemble@line
%<debug>  \TXN@trace@mode [assemble line]%
  \PTR@is@fragmentfalse
  \PTR@speech@headingfalse
  \PTR@has@SDfalse
%    \end{macrocode}
% Loop through the boxes.
%    \begin{macrocode}
  \advance \PTR@box@ind by \@ne
  \edef \PTR@box@ind@afterlast {\the\PTR@box@ind}%
  \PTR@box@ind = \PTR@box@line
  \TXN@assign \count@ = {PTR@box@type\the\PTR@box@line}%
  \ifodd \count@        % persona or persona + b-SD
    \PTR@speech@headingtrue
  \fi
  \@whilenum \PTR@box@ind < \PTR@box@ind@afterlast \do{%
    \edef \PTR@box@flags {\@nameuse {PTR@box@flags\the\PTR@box@ind}}%
    \TXN@assign \TXN@counter = {PTR@box@type\the\PTR@box@ind}%
    \ifcase \TXN@counter
%    \end{macrocode}
% Text
%    \begin{macrocode}
        \ifdim \wd\PTR@box@ind > \z@
          \let \PTR@next = \PTR@process@text@box
        \fi
%    \end{macrocode}
% Persona
%    \begin{macrocode}
    \or \let \PTR@next = \PTR@process@persona@box
%    \end{macrocode}
% b-SD
%    \begin{macrocode}
    \or \ifdim \wd\PTR@box@ind > \z@
          \let \PTR@next = \PTR@process@bracketSD@box
          \ifnum \PTR@box@ind = \PTR@box@line 
            \if \TXN@option \TXN@o@DetachedSD \PTR@box@flags
              \let \PTR@next = \PTR@process@detached@bracketSD@box
            \else
              \ifTXN@blank@line
                \PTR@count@text@boxes
                \ifnum \TXN@counter@a = \z@
                  \if \TXN@option \TXN@o@EmbeddedSD \PTR@box@flags
                  \else
                    \let \PTR@next = \PTR@process@detached@bracketSD@box
                  \fi
                \fi
              \fi
            \fi
          \fi
        \fi
%    \end{macrocode}
% Persona + b-SD
%    \begin{macrocode}
    \or \let \PTR@next = \PTR@process@persona@bracketSD@box
%    \end{macrocode}
% Split
%    \begin{macrocode}
    \or \let \PTR@next = \PTR@process@split@box
    \else
      \PackageError {POETRY} 
                    {This can't happen (3)}
                    {Please report the error to the author}%
    \fi
    \PTR@next
    \advance \PTR@box@ind by \@ne
  }%
}
%    \end{macrocode}
% \subsection{Typeset the line} 
%
%    \begin{macrocode}
%    \end{macrocode}
% Do not normalize line height
%    \begin{macrocode}
\newif \ifTXN@true@line@height
\newcommand {\TrueLineHeight}{\TXN@true@line@heighttrue}
%    \end{macrocode}
% True if the line overlaps the next line.
%    \begin{macrocode}
\newif \ifPTR@backup
%    \end{macrocode}
%
%    \begin{macrocode}
\def \PTR@typeset@line {%
%<debug>  \TXN@trace \PTR@typeset@line
%    \end{macrocode}
% Check for a multisplit line
%    \begin{macrocode}
  \ifTXN@SpatiumEscEsc@noauto
  \else
    \PTR@check@multisplit
  \fi
%    \end{macrocode}
% Process |\auto| information.
%    \begin{macrocode}
  \PTR@auto@update
%    \end{macrocode}
% Insert SpatiumSupra, if any.
%    \begin{macrocode}
  \ifx \empty \PTR@SpatiumSupra@line
  \else
    \endgraf
    \vskip -\baselineskip
    \vskip \z@ 
    \TXN@spatium@vertical  \PTR@SpatiumSupra@line
  \fi
%    \end{macrocode}
% Save the position of the text.
%    \begin{macrocode}
  \TXN@assign \dimen@ = {TXN@textus[\TXN@theTextus]shift}%
  \xdef \PTR@previous@shift {\the\dimen@}%
%    \end{macrocode}
% Check if this the start of a strophe.
%    \begin{macrocode}
  \ifdim \PTR@text@width > \z@
    \PTR@check@start@of@stropha
    \xdef \PTR@lastskip {\z@}%
  \fi
%    \end{macrocode}
%
%    \begin{macrocode}
  \ifPTR@first@line
    \global \PTR@first@linefalse
    \ifTXN@CollectingIndexesData
      \ifnum \TXN@pass = \tw@
        \TXN@sw@false
        \ifTXN@index@first@lines
          \TXN@sw@true
        \else
          \ifTXN@index@next@first@line
            \TXN@sw@true
          \fi
        \fi
        \ifTXN@sw
          \PTR@process@first@line
        \fi
      \fi
    \fi
  \fi
%    \end{macrocode}
% Update statistics
%    \begin{macrocode}
  \ifPTR@is@fragment
  \else
    \ifdim \PTR@text@width > \z@
      \TXN@gincr \TXN@stats@versus@lines
    \fi
  \fi
  \ifdim \TXN@stats@versus@longest < \wd\PTR@box@full@line
     \xdef \TXN@stats@versus@longest {\the\wd\PTR@box@full@line}%
  \fi
%    \end{macrocode}
% Check if line needs folding
%    \begin{macrocode}
  \PTR@check@folding
%    \end{macrocode}
% Check for a pending [r] b-SD
%    \begin{macrocode}
  \ifx \empty \PTR@r@bracketSD@ind 
  \else
    \TXN@counter = \PTR@r@bracketSD@ind \TXN@safe
    \dimen@ = \wd\TXN@counter
    \advance \dimen@  by \wd\PTR@box@full@line 
    \setbox \z@ = \hbox {\DRM@SpatiumAnteBracketSD}%
    \advance \dimen@  by \wd\z@ 
    \ifdim \dimen@ > \TXN@measure
    \else
%<debug>  \TXN@trace \PTR@process@R
      \advance \dimen@  by -\wd\z@ 
      \dimen@@ = \TXN@measure
      \advance \dimen@@ by -\dimen@ 
      \edef \PTR@hfill@right {\the\dimen@@}%
      \setbox \PTR@box@full@line = \hbox {%
        \hbox {\unhbox \PTR@box@full@line}%
        \kern \dimen@@
        \hbox {\unhbox \TXN@counter}}%
      \def \PTR@r@bracketSD@ind {}%
      \ifdim \PTR@text@width = \z@
        \def \TXN@line@class {[}%
      \else
        \PTR@has@SDtrue
      \fi
    \fi
  \fi
%    \end{macrocode}
% Update statistics.
%    \begin{macrocode}
  \ifdim \wd\PTR@box@excessus > \z@
    \TXN@gincr \TXN@stats@versus@excessus@count
    \ifdim \TXN@stats@versus@excessus@longest < \wd\PTR@box@excessus 
      \xdef \TXN@stats@versus@excessus@longest  
            {\the\wd\PTR@box@excessus}%
    \fi
    \ifdim \TXN@stats@versus@excessus@shortest > \wd\PTR@box@excessus 
      \xdef \TXN@stats@versus@excessus@shortest  
            {\the\wd\PTR@box@excessus}%
    \fi
    \ifdim \wd\PTR@box@excessus < .75\PTR@em %
       \TXN@Warning {The folded part of the line\MessageBreak
                     is less than .75em in width}%
    \fi
  \fi
  \dimen@ = \the\wd\PTR@box@full@line
  \advance \dimen@ by -\PTR@textus@shift
  \xdef \PreviousLineWidth {\the\dimen@}%
  \ifdim \PreviousLineWidth > \MaxLineWidth 
    \xdef \MaxLineWidth {\PreviousLineWidth}%
  \fi
  \ifdim \PreviousLineWidth < \MinLineWidth 
    \xdef \MinLineWidth {\PreviousLineWidth}%
  \fi
  \ifdim \TXN@stats@versus@longest@print < \wd\PTR@box@full@line
     \xdef \TXN@stats@versus@longest@print 
           {\the \wd\PTR@box@full@line}%
  \fi
  \xdef \PreviousLineShift {\the\PTR@textus@shift}%
  \ifdim \PreviousLineShift > \MaxLineShift \TXN@safe
    \xdef \MaxLineShift {\PreviousLineShift}%
  \fi
  \ifdim \PreviousLineShift < \MinLineShift \TXN@safe
    \xdef \MinLineShift {\PreviousLineShift}%
  \fi
%    \end{macrocode}
% Set the line margins.
%    \begin{macrocode}
  \PTR@set@line@margins \PTR@box@full@line
%    \end{macrocode}
% Generate the |\excessus|
%    \begin{macrocode}
  \ifdim \wd\PTR@box@excessus > \z@
    \TXN@attach@textus{\TXN@e}% 
    \ifTXN@leaders
      \PTR@append {\kern \TXN@excessus@leaders\relax}%
    \fi
    \def \PTR@folded@line {0}%
  \fi
%    \end{macrocode}
% This is necessary because uppercase letters carrying an accent have
% a height greater than the design height for the font: they would stretch
% the inter-line spacing, making the page \texttt{Underfull}. 
%    \begin{macrocode}
  \ifdim \PTR@text@width > \z@
    \ifTXN@true@line@height
    \else
      \ht\PTR@box@full@line = \PTR@strut@ht \TXN@safe
    \fi
  \fi
%<*debug>
  \ifPTR@showline
    \showbox \PTR@box@full@line
  \fi
%</debug>
  \ifPTR@has@SD
    \ifdim \PTR@text@width = \z@
      \def \TXN@line@class {[}%
    \fi
  \fi
%    \end{macrocode}
% Attach |\textus| and |\numerus| objects
%    \begin{macrocode}
  \TXN@attach@textus{\z@}% 
  \TXN@process@line@numbers
  \def \PTR@folded@line {}%
%    \end{macrocode}
% At last, we are ready to print the line.
%    \begin{macrocode}
   \ifvoid \PTR@box@full@line 
   \else
    \leavevmode
    \PTR@line@to@page \PTR@box@full@line 
    \par
   \fi
   \def \TXN@line@class {}%
%    \end{macrocode}
% If |\\| after |\persona| back up a line
%    \begin{macrocode}
  \ifPTR@backup
    \PTR@backupfalse
    \vskip -\baselineskip
  \fi
%    \end{macrocode}
% Add any requested space below this line.
%    \begin{macrocode}
  \TXN@spatium@vertical \PTR@SpatiumInfra@line
  \ifPTR@after@stropha
    \ifnum \TXN@active@areas > \z@
      \expandafter \global \expandafter 
      \let \csname TXN@area[\TXN@area@count]stropha\endcsname
           = \PTR@SpatiumInfraStropham
    \else
      \TXN@spatium@vertical \PTR@SpatiumInfraStropham
    \fi
  \fi
%    \end{macrocode}
% Check for a (still) pending [r] b-SD
%    \begin{macrocode}
  \ifx \empty \PTR@r@bracketSD@ind 
  \else
    \global \setbox \PTR@hbox = \hbox to \TXN@measure {%
      \hfill \unhbox \PTR@r@bracketSD@ind}%
    \def \TXN@line@class {[}%
    \PTR@line@to@page \PTR@hbox
    \def \TXN@line@class {}%
  \fi
}
%    \end{macrocode}
% Set the line margins.
%    \begin{macrocode}
\def \PTR@set@line@margins #1{%
  \TXN@SimpleList \TXN@line@fields \z@
  \TXN@assign \dimen@@ = {TXN@textus[\TXN@theTextus]offset@\TXN@theFolio}%
  \dimen@ = \TXN@leading@space \TXN@safe
  \advance \dimen@ by \dimen@@
  \setbox \z@ = \hbox {\unhcopy#1\unskip}%
  \advance \dimen@@ by \wd\z@
  \edef \TXN@temp {\the\dimen@,\the\dimen@@}%
  \TXN@SimpleList@append \TXN@line@fields \TXN@temp
}
%    \end{macrocode}
% \section{\textit{Assembling the line}} 
% \subsection{Process a text box}
%    \begin{macrocode}
\def \PTR@process@text@box {%
%<debug>  \TXN@trace \PTR@process@text@box
  \ifdim \PTR@text@indent = \maxdimen
    \PTR@set@text@indent 
%<debug>  \TXN@trace@dim \PTR@textus@shift
%<debug>  \TXN@trace@dim \PTR@text@indent
%<debug>  \TXN@trace@macro \DRM@speech@lines
    \ifPTR@speech@heading
      \ifdim \PTR@textus@shift = \z@
      \else
        \dimen@ = \PTR@text@indent \TXN@safe
        \PTR@get@speech@indent \tw@
        \advance \dimen@ by \PTR@speech@indent \TXN@safe
        \setbox \z@ = \hbox {\unhcopy \PTR@box@full@line\unskip}%
        \ifdim \dimen@ < \wd\z@
          \TXN@Warning* {The text overlaps the speech heading}%
        \fi
        \advance \dimen@ by -\wd\PTR@box@full@line
        \PTR@append {\kern \dimen@}%
      \fi
    \else
      \PTR@append {\kern \PTR@text@indent}%
    \fi
  \fi
  \ifdim \PTR@split@skip > \z@
    \PTR@process@text@box@split 
  \else
    \PTR@append {\unhbox \PTR@box@ind}%
  \fi
  \PTR@text@width = \wd\PTR@box@full@line
}
\def \PTR@process@text@box@split {%
%    \end{macrocode}
% This is a fragment (not the first) of a split line.
%    \begin{macrocode}
    \PTR@is@fragmenttrue
    \ifdim \PTR@SpatiumEscEsc@corr < \maxdimen
%    \end{macrocode}
% The correction for a multi-split line is available; apply it.
%    \begin{macrocode}
      \dimen@ = \PTR@split@skip
      \advance \dimen@ by -\wd\PTR@box@full@line 
      \advance \dimen@ by \PTR@SpatiumEscEsc@corr 
      \PTR@append {\kern \dimen@ \unhbox \PTR@box@ind}%
    \else
      \ifdim \PTR@split@skip > \wd\PTR@box@full@line
%    \end{macrocode}
% The first pass: collect information for a (possibly) multi-split line.
%    \begin{macrocode}
        \setbox\z@ = \hbox {\TXN@SpatiumPostEscEsc}%
        \dimen@ = \PTR@split@skip
        \advance \dimen@ by \wd\z@ 
        \advance \dimen@ by \wd\PTR@box@ind
        \ifdim \dimen@ > \TXN@measure
          \advance \dimen@ by -\TXN@measure
          \dimen@@ = \dimen@
          \advance \dimen@@ by -\wd\z@ 
          \dimen@ = \PTR@split@skip
          \advance \dimen@ by -\wd\PTR@box@full@line
          \advance \dimen@ by -\dimen@@
        \else
          \dimen@ = \PTR@split@skip
          \advance \dimen@ by -\wd\PTR@box@full@line
          \dimen@@ = \wd\z@ 
          \advance \dimen@ by \dimen@@
        \fi
        \PTR@append {\kern \dimen@ \unhbox \PTR@box@ind}%
        \ifnum \PTR@split@count > \z@
          \advance \dimen@@ by \PTR@multisplit@spacing 
          \xdef \PTR@multisplit@spacing {\the\dimen@@}%
        \fi
      \else
%    \end{macrocode}
% We are already beyond the point at which the fragment should start
%    \begin{macrocode}
        \PTR@append {\unhbox \PTR@box@ind}%
        \ifnum \TXN@pass = \tw@
        \else
          \ifnum \PTR@multisplit@line > \z@
%    \end{macrocode}
% This cannot be a multipslit line
%    \begin{macrocode}
            \xdef \PTR@multisplit@line {\z@}%
            \gdef \PTR@split@count {\z@}%
          \fi
        \fi
      \fi
    \fi
    \global \PTR@next@split@skip = \z@skip
}
%    \end{macrocode}
% \subsection{Process a persona box}
%    \begin{macrocode}
\def \PTR@process@persona@box {%
%<debug>  \TXN@trace \PTR@process@persona@box
  \PTR@process@persona@vertical@spacing
  \xdef \DRM@speech@lines {\@ne}%
%    \end{macrocode}
% For |\00| we use the indentation for text.
%    \begin{macrocode}
  \ifx \DRM@persona@first \DRM@persona@zero@zero
    \xdef \DRM@speech@lines {\tw@}%
    \setbox \PTR@box@ind = \null
  \fi
  \PTR@count@text@boxes 
  \ifnum \TXN@counter@a = \z@
    \def \TXN@line@class {p}%
  \fi
  \PTR@get@speech@indent \empty
  \PTR@append {\kern \PTR@speech@indent \unhbox \PTR@box@ind}%
  \ifdim \TXN@leading@space = \maxdimen
      \global \TXN@leading@space = \PTR@speech@indent \TXN@safe
  \fi
  \if \TXN@option \TXN@o@PersonaLeft \PTR@box@flags
      \expandafter \PTR@process@persona@left
  \fi
}
%    \end{macrocode}
% \subsection{Process a persona+b-SD box}
%    \begin{macrocode}
\def \PTR@process@persona@bracketSD@box {%
%<debug>  \TXN@trace \PTR@process@persona@bracketSD@box
  \PTR@process@persona@vertical@spacing
  \PTR@get@speech@indent \@ne
  \ifdim \TXN@leading@space = \maxdimen
      \global \TXN@leading@space = \PTR@speech@indent \TXN@safe
  \fi
  \dimen@ = \wd\PTR@box@full@line
  \advance \dimen@ by \wd\PTR@box@ind
  \ifdim \dimen@ > \TXN@measure 
    \PTR@process@persona@bracketSD@box@overflow
  \else
    \PTR@has@SDtrue
    \PTR@append {\kern \PTR@speech@indent\unhbox \PTR@box@ind}%
    \ifdim \wd\PTR@box@full@line > \TXN@measure 
      \PTR@reset@line
    \fi
    \if \TXN@option \TXN@o@PersonaLeft \PTR@box@flags
      \PTR@process@persona@left 
    \fi
  \fi
}
%    \end{macrocode}
% The SD does not fit in the line.
%    \begin{macrocode}
\def \PTR@process@persona@bracketSD@box@overflow {%
%<debug>  \TXN@trace \PTR@process@persona@bracketSD@box@overflow
  \setbox \PTR@vbox = \vbox {%
    \hsize = \TXN@measure
    \hbadness = \@M
    \hfuzz = \maxdimen
    \parindent = \z@
    \topskip = \z@
    \DRM@FormaPersonae
    \begingroup
      \def \\{\hskip \z@ plus 1fil\penalty -10000\relax}%
      \def \TXN@parm@ii {%
        \DRM@SpatiumAnteBracketSD
        \DRM@FaciesBracketSD {%
          \strut \@nameuse {PTR@box@toks\the\PTR@box@ind}\strut}%
        }%
      \DRM@FaciesPersonae@first {\DRM@persona@first}{\TXN@parm@ii}%
    \endgroup
    \global \TXN@baselineskip = \baselineskip
    \xdef \TXN@badness {\the\badness}%
    \endgraf
    \xdef \TXN@prevgraf {\the\prevgraf}%
    \ifnum \TXN@badness < \badness
      \xdef \TXN@badness {\the\badness}%
    \fi
  }% 
  \ifnum \TXN@badness < \@M
  \else
    \PTR@cannot@typeset@properly 
  \fi
  \def \TXN@line@class {[}%
  \TXN@counter = \@ne
  \@whilenum \TXN@counter < \TXN@prevgraf \do{%
    \setbox \tw@ = \vbox {%
      \vbadness = \@M
      \splittopskip = \z@
      \global \setbox \@ne = \vsplit \PTR@vbox to \TXN@baselineskip
      \global \setbox \PTR@vbox = \box \PTR@vbox
      \unvbox \@ne \global \setbox \PTR@hbox = \lastbox
      \global \setbox \PTR@hbox = \hbox to \TXN@measure {%
           \kern \ifnum \TXN@counter = \@ne \PTR@speech@indent@one
                 \else \PTR@speech@indent@two\fi
           \unhbox \PTR@hbox}%
       }%
       \PTR@set@line@margins \PTR@hbox
       \TXN@attach@textus {\z@}% 
       \TXN@process@line@numbers
       \leavevmode \PTR@line@to@page \PTR@hbox 
       \advance \TXN@counter by \@ne
  }%
  \unvbox \PTR@vbox \setbox \z@ = \lastbox
  \setbox \PTR@box@full@line = \hbox {%
    \kern \ifnum \TXN@counter = \@ne \PTR@speech@indent@one
          \else \PTR@speech@indent@two \fi
          \unhbox \z@}%
  \ifnum \TXN@prevgraf = \@ne
    \PTR@line@to@page \PTR@box@full@line  
    \setbox \PTR@box@full@line = \copy \voidb@x
    \PTR@text@width = \z@skip
  \else
    \PTR@setSpatiumPostBracketSD
  \fi
  \PTR@has@SDtrue
  \def \TXN@line@class {}%
}
%    \end{macrocode}
% Set the spacing around persona.
%    \begin{macrocode}
\def \PTR@process@persona@vertical@spacing {%
%<debug>  \TXN@trace \PTR@process@persona@vertical@spacing
  \TXN@spatium@vertical \DRM@SpatiumSupraPersonam
%    \end{macrocode}
% Any text on the line?
%    \begin{macrocode}
  \PTR@count@text@boxes 
%    \end{macrocode}
% No.
%    \begin{macrocode}
  \ifnum \TXN@counter@a = \z@
    \global \let \PTR@SpatiumInfra@line = \DRM@SpatiumInfraPersonam
  \fi
}
\def \PTR@process@persona@left {%
  \ifdim \PTR@split@skip > \z@
  \else
%    \end{macrocode}
% Any text on the line?
%    \begin{macrocode}
    \PTR@count@text@boxes 
%    \end{macrocode}
% Yes.
%    \begin{macrocode}
    \ifnum \TXN@counter@a > \z@
      \global \setbox \PTR@hbox = \hbox to \TXN@measure {%
        \unhbox \PTR@box@full@line \hss}% 
      \PTR@line@to@page \PTR@hbox 
      \endgraf
      \PTR@get@speech@indent \tw@
      \PTR@prepend {\kern \PTR@speech@indent}%
    \fi
    \TXN@spatium@vertical \DRM@SpatiumInfraPersonam
  \fi
}
%    \end{macrocode}
% \subsection{Process a b-SD box}
%    \begin{macrocode}
\def \PTR@process@bracketSD@box {%
%<debug>  \TXN@trace \PTR@process@bracketSD@box
%    \end{macrocode}
% For a [r] b-SD we delay processing until the whole line has
% been assembled: there may not be room for it in the line and
% it may have to be moved to a line of its own.
%    \begin{macrocode}
  \if \TXN@option \TXN@o@RightSD \PTR@box@flags 
    \edef \PTR@r@bracketSD@ind {\number \PTR@box@ind}%
  \else
    \expandafter \PTR@process@bracketSD@box@bis
  \fi
}
\def \PTR@process@bracketSD@box@bis {%
  \ifnum  \PTR@box@ind = \PTR@box@line
    \ifdim \PTR@text@indent = \maxdimen
      \PTR@set@text@indent 
    \fi
    \PTR@append {\kern \PTR@text@indent}%
  \fi
  \dimen@ = \TXN@measure
  \advance \dimen@ by -\wd\PTR@box@full@line 
  \advance \dimen@ by -\wd\PTR@box@ind 
  \ifdim \dimen@ < \z@
     \expandafter \PTR@process@bracketSD@overflow
  \else
    \expandafter \PTR@process@bracketSD@normal
  \fi
}
%    \end{macrocode}
% The normal case: a SD that fits in the line.
%    \begin{macrocode}
\def \PTR@process@bracketSD@normal {%
%<debug>  \TXN@trace \PTR@process@bracketSD@normal
  \PTR@has@SDtrue
%    \end{macrocode}
% If at the start of the line, do not generate the \textit{SpatiumAnte}. 
%    \begin{macrocode}
  \if \TXN@option \TXN@o@LeftSD \PTR@box@flags 
    \count@ = \PTR@box@ind
    \advance \count@ by \@ne
    \TXN@sw@true
    \ifnum \count@ = \PTR@box@ind@afterlast
      \TXN@sw@false
    \else
      \if \TXN@num {PTR@box@type\the\count@} = \PTR@box@text 
      \else
        \TXN@sw@false
      \fi
    \fi
    \ifTXN@sw
      \setbox \z@ = \hbox {\unhbox \PTR@box@ind\DRM@SpatiumPostBracketSD}%
      \setbox \count@ = \hbox {\kern -\wd\z@ \box \z@ \box \count@}%
    \else
      \PackageError {POETRY}
      {A b-SD with the 'l' option must be immediately followed by text} 
      {}%
    \fi
  \else
    \ifnum \PTR@box@ind = \PTR@box@line
    \else
      \if \TXN@option \TXN@o@NoSpatiumAnte \PTR@box@flags 
      \else
        \PTR@append {\unskip \DRM@SpatiumAnteBracketSD}%
      \fi
    \fi
    \PTR@append {\unhbox \PTR@box@ind}%
    \PTR@has@SDtrue
    \PTR@setSpatiumPostBracketSD
  \fi
}
%    \end{macrocode}
% A SD that does not fit in the line.
%
%    \begin{macrocode}
\def \PTR@process@bracketSD@overflow {%
%<debug>  \TXN@trace \PTR@process@bracketSD@overflow
  \global \setbox \PTR@vbox = \vbox {%
    \parindent = \z@skip
    \hsize = \TXN@measure
    \hbadness = \@M
    \hfuzz = \maxdimen
    \topskip = \z@
    \leavevmode 
    \ifPTR@speech@heading
      \DRM@FormaPersonae
      \kern -\TXN@leading@space
      \xdef \TXN@gtemp {\PTR@speech@indent@one}%
      \xdef \TXN@gtemp@bis {\PTR@speech@indent@two}%
    \else
      \hangafter \@ne
      \hangindent = \PTR@text@indent 
      \gdef \TXN@gtemp {0pt}%
      \xdef \TXN@gtemp@bis {\the\PTR@text@indent}%
    \fi
    \unhbox \PTR@box@full@line
    \ifnum  \PTR@box@ind > \PTR@box@line
      \DRM@SpatiumAnteBracketSD
    \fi
    \begingroup
      \def \\{\hskip \z@ plus 1fil\penalty -10000\relax}%
      \DRM@FaciesBracketSD {%
        \strut \@nameuse {PTR@box@toks\the\PTR@box@ind}\strut}%
    \endgroup
    \global \TXN@baselineskip = \baselineskip
    \xdef \TXN@badness {\the\badness}%
    \endgraf
    \ifnum \TXN@badness < \badness
      \xdef \TXN@badness {\the\badness}%
    \fi
    \xdef \TXN@prevgraf {\the\prevgraf}%
  }% 
  \ifnum \TXN@badness < \@M
  \else
    \PTR@cannot@typeset@properly 
  \fi
  \def \TXN@line@class {[}%
  \TXN@counter = \@ne
  \@whilenum \TXN@counter < \TXN@prevgraf \do{%
    \setbox\tw@ = \vbox{%
      \vbadness = \@M
      \splittopskip = \z@
      \global \setbox \@ne = \vsplit \PTR@vbox to \TXN@baselineskip
      \global \setbox \PTR@vbox = \box \PTR@vbox
      \unvbox \@ne \global \setbox \PTR@hbox = \lastbox
      \global \setbox \PTR@hbox = \hbox to \TXN@measure {%
           \kern \ifnum \TXN@counter = \@ne \TXN@gtemp \else \TXN@gtemp@bis\fi
           \unhbox \PTR@hbox}%
       }%
       \PTR@set@line@margins \PTR@hbox
       \TXN@attach@textus {\z@}% 
       \TXN@process@line@numbers
       \leavevmode \PTR@line@to@page \PTR@hbox 
       \advance \TXN@counter by \@ne
  }%
  \unvbox \PTR@vbox \setbox \z@ = \lastbox
  \setbox \PTR@box@full@line = \hbox {%
    \kern \ifnum \TXN@counter = \@ne \TXN@gtemp \else \TXN@gtemp@bis\fi
    \unhbox \z@
  }%
  \PTR@setSpatiumPostBracketSD
  \PTR@has@SDtrue
  \def \TXN@line@class {}%
}
%    \end{macrocode}
% \subsection{Process a detached b-SD}
%    \begin{macrocode}
\def \PTR@process@detached@bracketSD@box {%
%<debug>  \TXN@trace \PTR@process@detached@bracketSD@box
  \def \TXN@entity@code {[}%
  \def \TXN@line@class {[}%
  \edef \DRM@options@SD {\PTR@box@flags}%
  \DRM@standalone@pre
  \DRM@FaciesBracketSD {%
    \@nameuse {PTR@box@toks\the\PTR@box@ind}}%
  \DRM@standalone@post
  \def \TXN@line@class {}%
  \setbox \PTR@box@full@line = \copy \voidb@x
  \PTR@text@width = \z@skip
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \PTR@setSpatiumPostBracketSD {%
%<debug>  \TXN@trace \PTR@setSpatiumPostBracketSD
  \if \TXN@option \TXN@o@NoSpatiumPost \PTR@box@flags 
  \else
    \setbox \z@ = \hbox {\DRM@SpatiumPostBracketSD}%
    \dimen@ = \wd\PTR@box@full@line 
    \advance \dimen@ by \wd\z@
    \ifdim \dimen@ > \TXN@measure
    \else
      \PTR@append {\DRM@SpatiumPostBracketSD}%
    \fi
  \fi
}
%    \end{macrocode}
% \subsection{Process a `line split' box}
%    \begin{macrocode}
\def \PTR@process@split@box {%
%    \end{macrocode}
% Any more text on the line?
%    \begin{macrocode}
  \PTR@count@text@boxes
  \ifnum \TXN@counter@a > \z@
%    \end{macrocode}
% Yes: this is an explicit text split.
%    \begin{macrocode}
    \advance \PTR@box@ind by \@ne
    \TXN@sw@false
    \ifnum \TXN@counter@a > \@ne
      \TXN@sw@true
    \else
      \if \TXN@num {PTR@box@type\the\PTR@box@ind} = \PTR@box@text 
      \else
        \TXN@sw@true
      \fi
    \fi
    \ifTXN@sw 
      \PackageError {POETRY}
        {Extraneous material after \protect\\} 
        {Only a single \protect\textus\space object may follow \protect\\}%
    \fi
%    \end{macrocode}
%   Advancing the index terminates the main loop.
%    \begin{macrocode}
    \setbox \PTR@box@excessus = \copy \PTR@box@ind    
  \else
%    \end{macrocode}
% No: this is a verse fragment or a stand-alone |\persona|.
%    \begin{macrocode}
%    \end{macrocode}
% Any text before the split?
%
% Yes: this is a verse fragment.
%    \begin{macrocode}
    \ifnum \TXN@counter@b > \z@
      \setbox \z@ = \hbox {\unhcopy \PTR@box@full@line}%
      \global \PTR@next@split@skip = \wd\z@ 
      \global \advance \PTR@next@split@skip by \wd\PTR@box@ind 
    \else
%    \end{macrocode}
% No: this is split after a stand-alone |\persona|.
%    \begin{macrocode}
      \PTR@backuptrue
    \fi
  \fi
}
%    \end{macrocode}
% \subsection{Count the text boxes} 
% Returns: in |\TXN@counter@a| the number of text boxes in the part
% of the line starting at the current box (|\PTR@box@ind|), in
% |\TXN@counter@b| the number of text boxes in the  part of the line
% before the current box. 
%    \begin{macrocode}
\def \PTR@count@text@boxes {%
  \TXN@counter = \PTR@box@line
  \TXN@counter@a = \z@
  \TXN@counter@b = \z@
  \@whilenum \TXN@counter < \PTR@box@ind@afterlast \do{%
    \if \TXN@num {PTR@box@type\the\TXN@counter} = \PTR@box@text 
      \advance 
        \ifnum \TXN@counter > \PTR@box@ind 
          \TXN@counter@a
        \else
          \TXN@counter@b
        \fi
        by \@ne
    \fi
    \advance \TXN@counter by \@ne
  }%
}
%    \end{macrocode}
% \subsection{Get the hanging indentation}
%    \begin{macrocode}
\def \PTR@get@speech@indent #1{%
%<debug>  \TXN@trace \PTR@get@speech@indent
  \PTR@speech@indent = \z@skip
  \ifTXN@withinDrama
    \ifx \empty #1\relax
      \TXN@counter = \DRM@speech@lines \TXN@safe
    \else
      \TXN@counter = #1\relax
    \fi
    \ifdim \PTR@hangindent = \z@
      \ifdim \PTR@parindent = \z@
      \else
        \ifnum \TXN@counter = \@ne
          \PTR@speech@indent = \PTR@parindent \TXN@safe
        \fi
      \fi
    \else
      \ifdim \PTR@hangindent < \z@
        \PackageError {POETRY}
          {The package does not support\MessageBreak
           negative values for \protect\hangindent}
           {}%
      \else
        \ifnum \PTR@hangafter < \z@
          \count@ = \PTR@hangafter \TXN@safe
          \advance \count@ by \m@ne
          \count@ = -\count@
          \ifnum \TXN@counter < \count@
            \PTR@speech@indent = \PTR@hangindent \TXN@safe
          \fi
        \else
          \ifnum \TXN@counter > \PTR@hangafter \TXN@safe
            \PTR@speech@indent = \PTR@hangindent \TXN@safe
          \fi
        \fi
      \fi
    \fi
  \fi
%<debug>  \TXN@trace@dim \PTR@speech@indent
}
%    \end{macrocode}
% \subsection{Get the stropha indentation}
%    \begin{macrocode}
\def \PTR@get@stropha@indent {%
%<debug>  \TXN@trace \PTR@get@stropha@indent
  \PTR@stropha@indent = \z@skip
  \ifx \empty \PTR@FormaStrophae
  \else
    \ifnum \PTR@stropha@break > \z@
      \global \PTR@stropha@counter = \PTR@stropha@break \TXN@safe 
      \def \PTR@stropha@break {\z@}%
    \fi
    \ifdim \PTR@split@skip = \z@
      \global \advance \PTR@stropha@counter by \@ne 
    \fi
  \fi
  \ifx \empty \PTR@FormaStrophae
    \PTR@stropha@indent = \PTR@explicit@indent \TXN@safe
  \else
    \ifnum \PTR@explicit@stropha = \z@
%    \end{macrocode}
%    After |\stropha [...]| the counter may be -1 on entry and 0 now.
%    \begin{macrocode}
      \ifnum \PTR@stropha@counter > \z@
        \PTR@get@stropha@indent@bis 
      \fi
    \else
      \PTR@get@stropha@indent@bis 
%    \end{macrocode}
% Ignore the indentation except for `z'
%    \begin{macrocode}
      \ifnum -9999 = \TXN@indent \TXN@safe
      \else
        \PTR@stropha@indent = \z@
      \fi
    \fi
    \advance \PTR@stropha@indent by \PTR@explicit@indent \TXN@safe
  \fi
%    \end{macrocode}
% Account from the indentation forced by a Drop Cap.
%    \begin{macrocode}
  \ifnum \TXN@DropCap@lines = \z@
  \else
    \TXN@dim@a = \z@
    \count@ = \TXN@DropCap@lines \TXN@safe
    \ifnum \count@ < \z@
      \count@ = -\count@
      \xdef \PTR@DropCap@first@indent {\the\PTR@stropha@indent}%
    \else
      \advance \count@ by \m@ne
      \TXN@get \TXN@DropCap@indent.\count@ \TXN@temp
      \ifx \empty \PTR@FormaStrophae
        \TXN@dim@a = \TXN@temp \TXN@safe
        \advance \TXN@dim@a by \PTR@DropCap@first@indent \TXN@safe
      \else
        \ifnum -\@M = \TXN@indent \TXN@safe
        \else
          \TXN@dim@a = \TXN@temp \TXN@safe
          \advance \TXN@dim@a by \PTR@DropCap@first@indent \TXN@safe
        \fi
      \fi
    \fi
    \xdef \TXN@DropCap@lines {\the\count@}%
    \ifdim \PTR@stropha@indent < \TXN@dim@a   
      \PTR@stropha@indent = \TXN@dim@a \TXN@safe
    \fi
  \fi
%    \end{macrocode}
% Check if final line of a stropha.
%    \begin{macrocode}
  \ifx \empty \PTR@FormaStrophae
  \else
    \ifnum \PTR@stropha@counter = \PTR@stropha@length \TXN@safe
      \ifnum \PTR@explicit@stropha > \z@
        \global \advance \PTR@stropha@counter by \m@ne
      \else
        \ifnum \PTR@stropha@start > \z@
          \global \PTR@stropha@counter = \PTR@stropha@start 
          \edef \PTR@stropha@start {-\PTR@stropha@start}%
        \else
          \count@ = \PTR@stropha@start \TXN@safe
          \ifnum \count@ < \z@
            \count@ = -\count@
          \fi
          \global \PTR@stropha@counter = \count@  
        \fi
        \PTR@after@strophatrue
      \fi
    \fi
  \fi
%<debug>  \TXN@trace@dim \PTR@stropha@indent
}
\def \PTR@get@stropha@indent@bis {%
%<debug>  \TXN@trace \PTR@get@stropha@indent@bis
  \PTR@after@strophafalse
%<debug>  \TXN@trace@count [counter before]\PTR@stropha@counter
  \@tempcnta = \PTR@stropha@counter  
  \begingroup
    \gdef \TXN@indent{}%
    \long \def \\##1{%
      \TXN@NameList@check {##1}{\TXN@NameList@spatium}%
      \ifTXN@sw
        \ifnum \@tempcnta = \z@ 
          \ifnum \PTR@stropha@counter = \PTR@stropha@length \TXN@safe
            \xdef \PTR@SpatiumInfra@line {##1}%
          \fi
        \else
          \ifnum \@tempcnta = \@ne 
            \xdef \PTR@SpatiumSupra@line {##1}%
          \fi
        \fi 
      \else
        \advance \@tempcnta by \m@ne
        \ifnum \@tempcnta = \z@ 
          \gdef \TXN@indent {##1}%
        \fi
      \fi
    }%
    \PTR@FormaStrophae 
  \endgroup
  \ifx \TXN@indent \TXN@safe
    \PackageError {POETRY}
                  {This can't happen (4).}
                  {Please report the error to the author}%
  \else
    \ifx \empty \TXN@indent 
      \PackageError {POETRY} {This can't happen (5).}
                    {Please report the error to the author}%
    \fi
    \ifnum -\@M = \TXN@indent \TXN@safe
      \PTR@stropha@indent = \TXN@measure 
      \advance \PTR@stropha@indent by -\wd\PTR@box@ind
      \divide \PTR@stropha@indent by \tw@
    \else
      \dimen@ = \PTR@stropha@unit \TXN@safe
      \ifnum -9999 = \TXN@indent \TXN@safe
        \PTR@stropha@indent = \z@
        \ifNewPage 
          \PTR@stropha@indent = \dimen@ \TXN@safe
        \fi
      \else
        \PTR@stropha@indent = \TXN@indent \dimen@ \TXN@safe
      \fi
    \fi
  \fi
}
%    \end{macrocode}
% \section{\textit{Typesetting the line}} 
%
% \subsection{Check for the start of a strophe}
%    \begin{macrocode}
\def \PTR@check@start@of@stropha {%
%<debug>  \TXN@trace \PTR@check@start@of@stropha
  \TXN@sw@false
  \ifnum \PTR@explicit@stropha > \z@
    \ifnum \PTR@explicit@stropha = \tw@
      \def \PTR@explicit@stropha {1}%
      \TXN@sw@true
    \fi
  \else
    \ifx \empty \PTR@FormaStrophae 
    \else
      \count@ = \PTR@stropha@start \TXN@safe
      \ifnum \count@ < \z@
        \count@ = -\count@
      \fi
      \ifnum \PTR@save@stropha@counter = \count@
        \TXN@sw@true
      \fi
    \fi
  \fi
  \ifTXN@sw
%    \end{macrocode}
% The null |\vskip| prevents the preceding |\vskip| being removed
% by |\addvspace|. 
%    \begin{macrocode}
    \ifx \empty \PTR@FaciesStrophae 
      \ifdim \PTR@lastskip = \z@ 
        \ifhmode
          \endgraf
          \vskip \prevdepth
          \vskip -\baselineskip
          \vskip \z@skip
        \fi
        \ifx \empty \PTR@SpatiumSupraStropham
        \else
            \TXN@spatium@vertical \PTR@SpatiumSupraStropham
        \fi
      \fi
    \else
      \endgraf
      \vskip \prevdepth
      \vskip -\baselineskip
      \vskip \z@skip
      \begingroup
        \TXN@withinFaciesStrophaetrue
        \PTR@FaciesStrophae
      \endgroup
    \fi
  \fi
}
%    \end{macrocode}
% \subsection{Check for line folding}
%    \begin{macrocode}
\def \PTR@check@folding {%
%<debug>  \TXN@trace \PTR@check@folding
%    \end{macrocode}
% Get the maximum acceptable badness (if any) for the line after
% folding
%    \begin{macrocode}
  \def \PTR@excessus@badness {}%
  \edef \TXN@temp {\@nameuse{TXN@textus[\TXN@e]flagsModus@\TXN@theFolio}}%
  \if \TXN@option \TXN@o@Justified \TXN@temp
    \edef \PTR@excessus@badness 
      {\@nameuse {TXN@textus[\TXN@e]field@\TXN@theFolio}}%
  \fi
%    \end{macrocode}
% Check if folding is requested / needed
%    \begin{macrocode}
  \ifdim \wd\PTR@box@excessus > \z@
    \PTR@explicit@fold
  \else
    \ifdim \wd\PTR@box@full@line > \TXN@measure
      \ifdim \PTR@locus@excessus < \maxdimen
        \PTR@automatic@fold 
      \else
        \ifPTR@overfull@box
        \else
          \setbox \z@ = \hbox {\unhcopy\PTR@box@full@line\unskip}%
          \ifdim \wd\z@ > \TXN@measure
            \dimen@ = \wd\PTR@box@full@line
            \advance \dimen@ by -\TXN@measure
            \TXN@Warning* {The line is too long (by \the\dimen@)\MessageBreak
                          (and you have not defined \space
                          \protect\Locus\space \protect\excessus)}%
          \fi
        \fi
      \fi
    \fi
  \fi
%    \end{macrocode}
%
%    \begin{macrocode}
  \ifdim \wd\PTR@box@excessus > \z@
    \setbox \PTR@box@full@line  = \null
  \fi
}
%    \end{macrocode}
% Explicit folding.
%    \begin{macrocode}
\def \PTR@explicit@fold {%
%<debug>  \TXN@trace \PTR@explicit@fold
  \ifdim \PTR@locus@excessus = \maxdimen
      \PackageError {POETRY}
        {You have requested line folding\MessageBreak
         but you have not defined \space \protect\Locus\space 
         \protect\excessus}
        {}%
  \fi
  \xdef \TXN@line@length {\the\wd\PTR@box@full@line}%
  \TXN@sw@false
  \ifx \empty \PTR@excessus@badness 
  \else
    \ifnum \PTR@excessus@badness = \m@ne
    \else
      \TXN@sw@true
    \fi
  \fi
  \def \PTR@folded@line {1}%
  \TXN@attach@textus{\z@}% 
  \TXN@process@line@numbers
  \ifTXN@sw
    \begingroup
      \hbadness \@M
      \global \setbox \PTR@hbox = \hbox to \TXN@measure {%
        \spaceskip .33\PTR@em plus 1fil\unhbox \PTR@box@full@line}%
    \endgroup
  \else
    \global \setbox \PTR@hbox = \hbox to \TXN@measure {%
      \unhbox \PTR@box@full@line \hss}%
  \fi
  \PTR@line@to@page \PTR@hbox 
  \endgraf
  \penalty 1000\relax
}
%    \end{macrocode}
% Automatic fold.
%    \begin{macrocode}
\def \PTR@automatic@fold {%
%<debug>  \TXN@trace \PTR@automatic@fold
  \PTR@split@line \PTR@box@full@line \TXN@measure
  \xdef \TXN@line@length {\the\wd\@ne}%
  \TXN@sw@false
  \ifnum \TXN@prevgraf > \tw@
    \TXN@sw@true
  \else
    \ifnum \TXN@prevgraf = \tw@
      \TXN@dim@a = \ifdim \PTR@locus@excessus = \maxdimen
                     \z@
                   \else
                     \PTR@locus@excessus \TXN@safe
                   \fi
      \advance \TXN@dim@a by \wd\tw@
      \ifdim \TXN@dim@a > \TXN@measure
        \TXN@sw@true
      \fi
    \fi
  \fi
  \ifTXN@sw
      \PTR@loong@line
  \else
    \def \PTR@folded@line {1}%
    \leavevmode
    \ifx \empty \PTR@excessus@badness 
      \xdef \PreviousLineWidth {\TXN@line@length}%
      \ifdim \PreviousLineWidth > \MaxLineWidth 
        \xdef \MaxLineWidth {\PreviousLineWidth}%
      \fi
      \global \setbox \PTR@hbox = \hbox {\unhbox \@ne}%
      \PTR@set@line@margins \PTR@hbox
      \TXN@attach@textus {\z@}% 
      \TXN@process@line@numbers
      \begingroup
        \TXN@leadersfalse
        \PTR@line@to@page \PTR@hbox
      \endgroup
      \endgraf
    \else
      \begingroup
        \hbadness = \@M
        \hfuzz = \maxdimen 
        \global \setbox \PTR@hbox = \hbox to \TXN@measure {%
            \spaceskip = .33\PTR@em plus 1fill minus .22\PTR@em\relax
            \unhcopy\@ne\unskip}%
        \xdef \PreviousLineWidth {\the\TXN@measure}%
        \ifdim \PreviousLineWidth > \MaxLineWidth 
          \xdef \MaxLineWidth {\PreviousLineWidth}%
        \fi
        \xdef \PTR@line@badness {\the\badness}%
        \ifnum \PTR@excessus@badness = \m@ne
          \TXN@assign \dimen@ = {TXN@textus[\TXN@theTextus]offset@\TXN@theFolio}%
          \advance \dimen@ by \TXN@measure
          \setbox \TXN@marginalia = \hbox to \z@ {%
            \box \TXN@marginalia \kern \dimen@ 
            \rlap{\ \tiny\upshape\PTR@line@badness}}%
          \PTR@set@line@margins \PTR@hbox
          \TXN@attach@textus {\z@}% 
          \TXN@process@line@numbers
          \PTR@line@to@page \PTR@hbox
        \else
          \ifnum \PTR@excessus@badness < \PTR@line@badness
            \TXN@Warning* {If justified, the line would have a badness of%
                          \MessageBreak
                          \PTR@line@badness, greater than the limit you have%
                          set (\number\PTR@excessus@badness)}%
            \ifnum \TXN@warnings@level > \@ne
              \advance \dimen@ by \TXN@measure
              \setbox \TXN@marginalia = \hbox to \z@ {%
                \box \TXN@marginalia \kern \dimen@ 
                \rlap{\ \tiny\upshape\PTR@line@badness}}%
            \fi
          \fi
          \PTR@set@line@margins \PTR@hbox
          \TXN@attach@textus {\z@}% 
          \TXN@process@line@numbers
          \PTR@line@to@page \PTR@hbox
        \fi
        \endgraf
      \endgroup
    \fi
    \penalty 1000\relax
    \setbox \PTR@box@excessus = \box \tw@
  \fi
}
%    \end{macrocode}
% \subsection{Split a long line to be folded}
% Split a line (in hbox |#1|) into two lines, the first of which has a width
% not exceeding the value of |#2|.  The two lines are in |\box1| and |\box2|.
% On exit:
%   |\TXN@counter| the number of lines (may be \textgreater{} 2 for pathological lines) 
%    \begin{macrocode}
\def \PTR@split@line #1#2{%
%<debug>  \TXN@trace \PTR@split@line
%    \end{macrocode}
% In |\TXN@dim@a| we put the offset of |\excessus| if the |\Locus| is
% defined, otherwise |\z@|.
% In |\TXN@@counter@a|, |\z@| if |\unhyphenated|.
%    \begin{macrocode}
  \TXN@dim@a = \ifdim \PTR@locus@excessus = \maxdimen
                 \z@
               \else
                 \PTR@locus@excessus \TXN@safe
               \fi
  \TXN@counter@a = \@ne
  \if \TXN@empty {TXN@textus[\TXN@e]flagsModus@\TXN@theFolio}%
  \else
    \edef \TXN@flags {\@nameuse {TXN@textus[\TXN@e]flagsModus@\TXN@theFolio}}%
    \if \TXN@option \TXN@o@Unhyphenated \TXN@flags
      \TXN@counter@a = \z@
    \fi
    \if \TXN@option \TXN@o@RangedRight \TXN@flags
      \TXN@dim@a = \z@
    \fi
  \fi
%    \end{macrocode}
% First we must achieve a split.
%    \begin{macrocode}
  \dimen@ = #2\relax
  \dimen@@ = .5\PTR@em % 
  \xdef \TXN@prevgraf {\z@}%
  \loop
    \PTR@try@split@line #1\TXN@counter@a 
  \ifnum \TXN@prevgraf < \tw@
    \advance \dimen@ by -.5em\relax
  \repeat
%    \end{macrocode}
% As overfull boxes cannot be detected, we must do all
% checking ourselves and repeat the process until a satisfactory
% spli is achieved.
%    \begin{macrocode}
  \loop
  \ifdim \wd\@ne > \dimen@ 
    \advance \dimen@ by -.1em\relax
    \PTR@try@split@line #1\TXN@counter@a
  \repeat
}
%    \end{macrocode}
% To split the line, we typeset it a vbox with the width in |\dimen@|
%    \begin{macrocode}
\def \PTR@try@split@line #1#2{%
    \setbox \z@ = \vbox {%
      \hsize \dimen@  
      \rightskip = \z@ plus \dimen@@   
      \parindent = \z@skip
      \hbadness = \@M   
      \hfuzz = \maxdimen 
      \widowpenalty = \z@   
      \clubpenalty = \z@   
      \hyphenpenalty = \z@   
      \finalhyphendemerits = \z@ 
      \ifnum #2 = \@ne
        \pretolerance = 100\relax   
      \else
        \pretolerance = \@M
      \fi
      \global \TXN@baselineskip = \baselineskip
      \unhcopy #1\relax
      \PTR@remove@hboxes
      \endgraf
      \xdef \TXN@prevgraf {\the \prevgraf}%
    }% 
  \ifnum \TXN@prevgraf > \@ne
    \ifnum \TXN@prevgraf = \tw@
      \splittopskip = \z@skip
      \dimen@ii = \ht\z@ 
      \advance \dimen@ii by -\TXN@baselineskip
      \global \setbox \@ne = \vsplit\z@ to \dimen@ii %
%    \end{macrocode}
% We do all unboxing inside a throw-away box, to trap any stray pieces
% which would otherwise migrate to the page.
%    \begin{macrocode}
      \setbox \z@ = \vbox{%
        \unvbox \@ne \unskip \global \setbox \@ne = \lastbox 
        \global \setbox \@ne = \hbox {\unhbox \@ne}%
        \unvbox \z@ \unskip \unskip \unpenalty \setbox \z@ = \lastbox 
        \global \setbox \thr@@ = \hbox {\unhbox \z@}%
        \advance \TXN@dim@a by \wd\thr@@
        \ifdim \TXN@dim@a > \TXN@measure
%    \end{macrocode}
%  We force the loop to stop (this is a loong line) and set the line
%  counter to a value > 2.
%    \begin{macrocode}
          \wd\@ne = \z@
          \xdef \TXN@prevgraf {\thr@@}%
       \fi
      }%
      \setbox \tw@ = \box \thr@@
    \else
%    \end{macrocode}
%  We force the loop to stop (this is a loong line).
%    \begin{macrocode}
      \wd \@ne = \z@
    \fi
  \else
%    \end{macrocode}
%  We force the loop to continue.
%    \begin{macrocode}
    \global \setbox \@ne = \hbox to 2\dimen@ {}%
  \fi
}
\def \PTR@remove@hboxes {%
  \setbox \z@ = \lastbox
  \ifhbox \z@ {\PTR@remove@hboxes}\unhbox \z@ \fi
}
%    \end{macrocode}
% \subsection{Process a loong line}
% We have a line of verse [sic] that will not fit in two physical lines.
% We re-set it as a paragraph with hanging indentation.
%    \begin{macrocode}
\def \PTR@loong@line {%
%<debug>  \TXN@trace \PTR@loong@line
  \ifdim \PTR@locus@excessus = \maxdimen
    \PackageError {POETRY}
      {A very long `line' cannot be typeset because\MessageBreak
       \protect\Locus\space \protect\excessus\space is not on the left side}
      {}%
  \else
    \TXN@dim@a = \PTR@locus@excessus \TXN@safe
  \fi
  \global \setbox \PTR@vbox = \vbox {%
    \hsize = \TXN@measure
    \hbadness = \@M
    \hfuzz = \maxdimen
    \parindent = \z@skip
    \parskip = \z@skip
    \topskip = \z@skip
    \widowpenalty = \z@   
    \clubpenalty  = \z@   
    \global \TXN@baselineskip = \baselineskip
    \hangafter  \@ne
    \hangindent \TXN@dim@a
    \unhbox \PTR@box@full@line
    \xdef \TXN@badness  {\the \badness}%
    \endgraf
    \xdef \TXN@prevgraf {\the \prevgraf}%
  }% 
  \ifnum \TXN@badness < \@M
    \xdef \PTR@loong@lines {\TXN@prevgraf}%
    \xdef \PTR@loong@counter {1}%
    \@whilenum \PTR@loong@lines > \@ne \do{%
       \setbox\tw@ = \vbox {%
         \vbadness = \@M
         \splittopskip = \z@
         \global \setbox \@ne = \vsplit \PTR@vbox to \TXN@baselineskip
         \global \setbox \PTR@vbox = \box \PTR@vbox
         \unvbox \@ne \global \setbox \PTR@hbox = \lastbox
       }%
       \global \setbox \PTR@hbox = \hbox to \TXN@measure {\hss\box\PTR@hbox}%
       \edef \PTR@folded@line {\PTR@loong@counter}%
       \PTR@set@line@margins \PTR@hbox
       \TXN@attach@textus {\z@}% 
       \TXN@process@line@numbers
       \PTR@line@to@page \PTR@hbox 
       \TXN@gincr \PTR@loong@counter
       \TXN@gdecr \PTR@loong@lines 
       \ifnum \PTR@loong@lines > \@ne
         \leavevmode
       \fi
    }%
    \def \PTR@folded@line {0}%
    \unvbox \PTR@vbox 
    \setbox \PTR@box@excessus = \lastbox
  \else
    \PTR@cannot@typeset@properly 
    \PTR@overfull@boxtrue
  \fi
}
%    \end{macrocode}
% \subsection{Re-set the line}
% Try typesetting the line again to fit the measure: the inter-word
% glue may shrink enough to make this possible.
%    \begin{macrocode}
\def \PTR@reset@line {%
%<debug>  \TXN@trace \PTR@reset@line
  \TXN@dim@a = \wd\PTR@box@full@line
  \advance \TXN@dim@a by -\TXN@measure
% \end{macrocode}
% Prevent an \texttt{Overfull box} message
%    \begin{macrocode}
  \TXN@counter = \hbadness
  \TXN@dim@b = \hfuzz
  \hbadness = \@M
  \hfuzz = \maxdimen
  \setbox \PTR@box@full@line = \hbox to \TXN@measure {%
    \unhbox\PTR@box@full@line \unskip}%
  \hbadness = \TXN@counter 
  \hfuzz = \TXN@dim@b
  \TXN@counter = \badness
  \setbox \z@ = \copy \PTR@box@full@line
  \ifnum \TXN@counter > \hbadness
    \TXN@dim@a = \wd\PTR@box@full@line
    \advance \TXN@dim@a by -\TXN@measure
    \ifdim \TXN@dim@a = \z@
      \PTR@cannot@typeset@properly 
      \setbox \PTR@box@full@line = \hbox to \TXN@measure {%
        \unhbox\PTR@box@full@line \unskip}%
    \else
      \PTR@cannot@typeset@properly 
    \fi
    \PTR@overfull@boxtrue
  \fi
  \PTR@count@text@boxes 
  \ifnum \TXN@counter@a > \z@
    \PTR@line@to@page \PTR@box@full@line 
    \setbox \PTR@box@full@line = \copy \voidb@x
    \PTR@text@width = \z@skip
  \fi
}
%    \end{macrocode}
% \subsection{Move a line to the page} 
%    \begin{macrocode}
\def \PTR@line@to@page #1{%
%<debug> \TXN@trace \PTR@line@to@page
  \ifnum \TXN@theTextus = \z@ 
%    \end{macrocode}
% Update area info
%    \begin{macrocode}
    \ifnum \TXN@active@areas > \z@
      \TXN@process@area@line@Versus {#1}%
    \fi
    \TXN@assign \dimen@ = {TXN@textus[\TXN@theTextus]offset@\TXN@theFolio}%
    \ifvbox #1\relax
      \PackageError {POETRY} {This can't happen (6).}
                    {Please report the error to the author}%
      \unvbox#1\relax
    \else
      \ifTXN@leaders
        \dimen@@ = \TXN@leaders@width \TXN@safe
        \setbox \z@ = \hbox to \TXN@measure {\kern \dimen@\box#1%
          \leaders \hbox to \dimen@@ {\hss.\hss}\hfill}%
      \else
        \setbox \z@ = \hbox {\kern \dimen@\box#1}%
      \fi
%<*debug>
      \ifPTR@showline
        \global \PTR@showlinefalse
        \showbox \z@
      \fi
%</debug>
      \begingroup
        \hsize \linewidth
        \ifvoid\TXN@marginalia \else \box \TXN@marginalia \fi \box\z@
        \par
      \endgroup
    \fi
  \else
    \ifvoid\TXN@marginalia \else \box \TXN@marginalia \fi \box#1\relax
  \fi
  \ifx \PTR@box@full@line #1\relax
    \PTR@text@width = \z@skip
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \PTR@set@text@indent {%
  \ifPTR@speech@heading
    \PTR@speech@indent = \z@skip
  \else
    \PTR@get@speech@indent \empty
  \fi
  \PTR@text@indent = \PTR@textus@shift 
  \advance \PTR@text@indent by \PTR@speech@indent \TXN@safe
  \PTR@get@stropha@indent
  \advance \PTR@text@indent by \PTR@stropha@indent \TXN@safe
  \ifdim \TXN@leading@space = \maxdimen 
    \global \TXN@leading@space = \PTR@text@indent \TXN@safe
  \fi
}
%    \end{macrocode}
% \section{Multi-split lines} 
%
% The number of splits (number of fragments - 1).
%    \begin{macrocode}
\gdef \PTR@split@count {0}%
%    \end{macrocode}
% The input line number for the line at which the first split occurs.
%    \begin{macrocode}
\gdef \PTR@multisplit@line {0}%
%    \end{macrocode}
% \subsection{Collect information about the multi-split} 
%    \begin{macrocode}
\def \PTR@check@multisplit {%
%<debug>  \TXN@trace \PTR@check@multisplit
  \ifnum \TXN@pass = \tw@
    \ifnum \inputlineno = \PTR@multisplit@line \TXN@safe
      \xdef \PTR@SpatiumEscEsc@corr {-\PTR@multisplit@delta}%
    \fi
  \fi
  \ifPTR@is@fragment
%    \end{macrocode}
% An intermediate (not the initial) fragment.
%    \begin{macrocode}
    \ifdim \PTR@next@split@skip > \z@
%    \end{macrocode}
% Not the last fragment.
%    \begin{macrocode}
      \ifnum \TXN@pass = \tw@
      \else
        \ifnum \PTR@split@count = \z@
%    \end{macrocode}
% The first intermediate fragment. |\PTR@multisplit@spacing| will hold
% the sum of all fragment lengths minus the text measure;
% |\PTR@multisplit@line|  records  the  position at which the multi-split
% starts. |\PTR@split@count| counts the inter-fragment `holes'.
%    \begin{macrocode}
          \gdef \PTR@multisplit@spacing {\z@}%
          \ifnum \PTR@multisplit@line = \z@
            \xdef \PTR@multisplit@line {\the\inputlineno}%
          \else
            \gdef \PTR@split@count {\@ne}%
          \fi
        \else
%    \end{macrocode}
% Not the first intermediate fragment: just increment the  count.
%    \begin{macrocode}
          \TXN@gincr \PTR@split@count
        \fi
      \fi
    \else
%    \end{macrocode}
% The last fragment.
%    \begin{macrocode}
      \ifnum \PTR@split@count = \z@
      \else
        \dimen@ = \wd\PTR@box@full@line 
        \dimen@@ = \PTR@multisplit@spacing \TXN@safe
        \advance \dimen@ by \dimen@@
%    \end{macrocode}
% The line does not fit in the text measure. We write a line to
% .aux containing the macro |\PTR@multisplit| with two arguments:
% the input line number at which the multisplit starts and the
% value that should be used for spacing between fragments.
%    \begin{macrocode}
        \ifdim \dimen@ > \TXN@measure
          \TXN@gincr \PTR@split@count
          \advance \dimen@ by -\TXN@measure
          \divide \dimen@ by \PTR@split@count \TXN@safe
          \advance \dimen@ by \ifdim \dimen@ < \z@ -\fi 1sp %
          \protected@write \@auxout {}{%
             \string\PTR@multisplit
             {\PTR@multisplit@line}{\the\dimen@}}%
          \TXN@run@LaTeX@again@reason \TXN@run@LaTeX@again@split
        \fi
        \gdef \PTR@split@count {0}%
      \fi
      \ifdim \PTR@SpatiumEscEsc@corr < \maxdimen
        \xdef \PTR@SpatiumEscEsc@corr {\the\maxdimen}%
        \PTR@multisplit@next
      \fi
    \fi
  \else
%    \end{macrocode}
% Possibly the first fragment.
%    \begin{macrocode}
    \ifdim \PTR@text@width > \z@
      \ifdim \PTR@next@split@skip > \z@
        \ifnum \TXN@pass = \tw@
        \else
%    \end{macrocode}
% It is the first fragment.
%    \begin{macrocode}
          \xdef \PTR@multisplit@line {\the\inputlineno}%
        \fi
      \else
%    \end{macrocode}
% Not a split line: clear the count.
%    \begin{macrocode}
        \gdef \PTR@split@count {0}%
      \fi
    \fi
  \fi
}
%    \end{macrocode}
% \subsection{Process the information about the multi-split} 
%
% As the .aux file is read in, on the second pass, the information
% (input line number/the excess length) is recorded in control
% sequences of the form |\PTR@multisplit|\textit{nn}
%    \begin{macrocode}
\gdef \PTR@multisplit@cs {0}%
\def  \PTR@multisplit #1#2{%
  \TXN@gincr \PTR@multisplit@cs
  \TXN@gdef {PTR@multisplit\PTR@multisplit@cs}{{#1}{#2}}%
}
%    \end{macrocode}
% For the run through .aux at the end of the first pass.
%    \begin{macrocode}
\AtEndDocument{\let \PTR@multisplit \@gobbletwo}
%    \end{macrocode}
% Fetch the next linenumber/spacing pair from the macro (if
% any) created during the run through .aux at the start of the
% second pass (|\PTR@multisplit|\textit{nn}).
%    \begin{macrocode}
\def \PTR@multisplit@next {%
%<debug>  \TXN@trace \PTR@multisplit@next
  \TXN@gincr \PTR@multisplit@cs
  \if \TXN@relax {PTR@multisplit\PTR@multisplit@cs}%
    \gdef \PTR@multisplit@line {0}%
    \gdef \PTR@multisplit@delta {\z@}%
  \else
    \expandafter 
    \PTR@multisplit@get \csname PTR@multisplit\PTR@multisplit@cs\endcsname
   \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \PTR@multisplit@get #1{%
  \expandafter \PTR@multisplit@get@bis #1\relax
}
\def \PTR@multisplit@get@bis #1#2{%
  \gdef \PTR@multisplit@line {#1}%
  \gdef \PTR@multisplit@delta {#2}%
}
%    \end{macrocode}
% \section{The \texttt{\char`\\auto} option} 
%    \begin{macrocode}
\newif \ifPTR@auto@no
\newif \ifPTR@auto@explicit
\newskip  \PTR@auto@textwidth
\def   \PTR@auto@mode {}%
\def   \PTR@auto@count {0}
%    \end{macrocode}
% Stepped up for each |\versus| |\endversus| pair.
%    \begin{macrocode}
\gdef  \PTR@versus@count {1}
%    \end{macrocode}
% \subsection{On entry to \textit{Versus}} 
%    \begin{macrocode}
\def \PTR@auto@setup {%
%<debug>  \TXN@trace \PTR@auto@setup
%<debug>  \TXN@trace@macro \PTR@versus@count
  \ifnum \TXN@pass = \@ne
%    \end{macrocode}
%    First pass: start the mechanism.
%    \begin{macrocode}
    \TXN@run@LaTeX@again@reason \TXN@run@LaTeX@again@auto
    \PTR@auto@textwidth = \z@skip
    \def \PTR@auto@count {0}%
    \def \auto {\unskip \global \PTR@auto@explicittrue}%
  \fi
  \ifnum \TXN@pass = \tw@
%    \end{macrocode}
%    Second pass: set the \texttt{textus} shift.
%    \begin{macrocode}
    \def \auto {}%
    \PTR@auto@fetch {\PTR@versus@count}%
    \TXN@dim@a = \dimen@
    \TXN@dim@b = \dimen@@
    \PTR@auto@check@delta
    \dimen@ = \TXN@measure
    \advance \dimen@ by -\TXN@dim@a  
    \divide \dimen@ by \tw@ 
    \ifdim \dimen@ < \z@
      \dimen@ = \z@
      \TXN@PackageWarningNoLine {POETRY}
        {Input line \number\inputlineno: \MessageBreak
         The \@backslashchar textus shift set by \@backslashchar Locus
         {\@backslashchar auto} (or {\@backslashchar Auto})\MessageBreak 
         is negative. Replaced by a null shift of 0pt}
    \fi
    \TXN@edef {TXN@textus[\TXN@theTextus]shift}{\the\dimen@}%
  \fi
}
%    \end{macrocode}
% \subsection{Update \texttt{\char`\\auto} information} 
%    \begin{macrocode}
\def \PTR@auto@update {%
%<debug> \TXN@trace \PTR@auto@update
  \ifx \empty \PTR@auto@mode 
  \else
    \expandafter \PTR@auto@update@bis
  \fi
}
\def \PTR@auto@update@bis {%
  \ifPTR@auto@explicit
    \PTR@auto@textwidth = \PTR@text@width
    \global \PTR@auto@explicitfalse
    \if a\PTR@auto@mode 
      \def \PTR@auto@mode {A}%
    \else
      \if m\PTR@auto@mode 
        \def \PTR@auto@mode {M}%
      \fi
    \fi
  \fi
  \if m\PTR@auto@mode 
    \ifdim \PTR@text@width > \PTR@auto@textwidth
      \PTR@auto@textwidth = \PTR@text@width
    \fi
  \fi
  \if a\PTR@auto@mode 
    \count@ = \PTR@auto@count \TXN@safe
    \ifnum \count@ > \tw@
%    \end{macrocode}
%  We ignore very short lines to avoid skewing the mean.
%    \begin{macrocode}
      \dimen@ = \PTR@auto@textwidth
      \divide \dimen@ by \count@
      \dimen@ = .75\dimen@
    \else
      \dimen@ = \z@
    \fi
%    \end{macrocode}
% The maximum legal dimensione is 5.7583 metres.
%    \begin{macrocode}
    \ifdim \PTR@auto@textwidth < 550cm\relax
      \ifdim \PTR@text@width > \dimen@
        \advance \PTR@auto@textwidth by \PTR@text@width
        \advance \count@ by \@ne
        \edef \PTR@auto@count {\the\count@}%
      \fi
    \fi
  \fi
}
%    \end{macrocode}
% \subsection{On exit from \textit{Versus}} 
%
% Record the information on .aux
%    \begin{macrocode}
\def \PTR@auto@record {%
  \ifx \empty \PTR@auto@mode 
  \else
    \expandafter \PTR@auto@record@bis
  \fi
}
\def \PTR@auto@record@bis {%
  \TXN@counter@a = \PTR@versus@count
  \if a\PTR@auto@mode
    \count@ = \PTR@auto@count \TXN@safe
    \ifnum \count@ = \z@
%    \end{macrocode}
%       Someone wrote |\versus \endversus|.
%    \begin{macrocode}
    \else
      \divide \PTR@auto@textwidth by \count@
    \fi
  \fi
  \let \auto = \PTR@save@auto@def 
  \ifnum \TXN@pass = \@ne
    \TXN@dim@a = \TXN@auto@delta \TXN@safe
    \protected@write\@auxout{}{\string\PTR@auto 
                               {\the\TXN@counter@a}%
                               {{\the\PTR@auto@textwidth}%
                               {\the\TXN@dim@a}}%
    }%
  \fi
  \advance \TXN@counter@a by \@ne
  \xdef \PTR@versus@count {\the\TXN@counter@a}% 
%    \end{macrocode}
% Restore the standard values that were overwritten at an explicit
% |\auto|.
%    \begin{macrocode}
  \if A \PTR@auto@mode
    \def \PTR@auto@mode {a}%
  \else
    \if M \PTR@auto@mode
      \def \PTR@auto@mode {m}%
    \fi
  \fi
}
%    \end{macrocode}
% \subsection{Process the \texttt{\char`\\auto} information} 
%
% At the start of the second pass, as .aux is read in, a control
% sequence of the form |\PTR@|\textit{n}|@| records, for the
%\textit{n}-th \textit{Versus} domain, the following information:\\
% 1) The average (for |\auto|) or maximum (for |\Auto|) line length;\\ 
% 2) The `delta' value used for comparison with the alignment of
% the previous two domains. 
%
%    \begin{macrocode}
\def \PTR@auto #1#2{%
  \TXN@gdef {PTR@#1@}{#2}%
}
%    \end{macrocode}
% Get the auto information for the |#1|-th domain.
%    \begin{macrocode}
\def \PTR@auto@fetch #1{%
  \edef \TXN@temp {\@nameuse{PTR@#1@}}%
  \expandafter \PTR@auto@fetch@bis \TXN@temp 
}
\def \PTR@auto@fetch@bis #1#2{%
  \dimen@ = #1\relax
  \dimen@@ = #2\relax
}
%    \end{macrocode}
% Compare the \texttt{textus} shift for this domain to the shift for the
% previous two domains; if the difference is less than `delta', use
% the previous shift.
%    \begin{macrocode}
\def \PTR@auto@check@delta {%
  \TXN@counter = \PTR@versus@count \TXN@safe
  \ifnum \TXN@counter  > \@ne
    \TXN@counter@a = \tw@
    \ifnum \TXN@counter  = \tw@
      \TXN@counter@a = \@ne
    \fi
    \loop
      \advance \TXN@counter@a by \m@ne
      \advance \TXN@counter by \m@ne
      \PTR@auto@fetch {\the\TXN@counter}%
      \dimen@@ = \dimen@
      \advance \dimen@@ by -\TXN@dim@a
      \ifdim \dimen@@ < \z@
        \dimen@@ = -\dimen@@
      \fi
      \ifdim .5\dimen@@ < \TXN@dim@b
        \TXN@dim@a = \dimen@
        \TXN@xdef {PTR@\PTR@versus@count @}%
          {{\the\TXN@dim@a}{\the\TXN@dim@b}}% 
        \TXN@counter@a = \z@
      \fi
    \ifnum \TXN@counter@a > \z@
    \repeat
  \fi
}
%    \end{macrocode}
% \section{The index of first lines} 
%
% The first line is fetched from the source file. Two streams
% are opened on the file and are read in parallel: on the first
% the line is read with all punctuation characters made inactive
% (the line is used to build the sort key) while on the second
% it is read with punctuation characters keeping their
% current |\catcode|, which may be |\active| (the line is printed
% `as is' in the index).
%
% On both files, the lines preceding the line to be fetched are
% read after setting the |\catcode| for braces to `other'. This
% is necessary because some lines almost certainly contain unbalanced
% braces.
%    \begin{macrocode}
\def \PTR@process@first@line {%
%<debug> \TXN@trace \PTR@process@first@line
  \TXN@get@page@column {\TXNl@linenumber}%
  \TXN@toks@a = {}%
  \TXN@toks@b = {}%
  \ifTXN@index@next@first@line
    \TXN@toks@b = \expandafter {\TXN@index@pending@key}%
  \fi
%    \end{macrocode}
% Skip preceding lines in the source file
%    \begin{macrocode}
  \TXN@counter = \inputlineno
  \advance \TXN@counter by \m@ne
  \loop
  \ifnum \PTR@fl@count < \TXN@counter
    \begingroup
      \catcode`\{=12 
      \catcode`\}=12 
      \catcode`\^^M=5 
      \def \^^M{}%
    \global \advance \PTR@fl@count by \@ne
    \global \read \PTR@fl to \PTR@fl@line
    \global \read \PTR@fl@bis to \PTR@fl@line@bis
    \endgroup
  \repeat
  \PTR@read@first@line
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \PTR@read@first@line {%
%<debug> \TXN@trace \PTR@read@first@line
  \def \TXN@flags {l}%
  \begingroup
    \catcode`!=12 
    \catcode`?=12 
    \catcode`;=12 
    \catcode`:=12 
    \catcode`.=12 
    \catcode`,=12 
    \catcode`"=12 
    \catcode``=12 
    \catcode`'=12 
    \catcode`\^^M=5 
    \def \^^M{}%
    \global \read \PTR@fl to \PTR@fl@line
  \endgroup
  \begingroup
    \catcode`\^^M=5 
    \def \^^M{}%
    \global \read \PTR@fl@bis to \PTR@fl@line@bis
  \endgroup
  \PTR@write@index@file
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \PTR@write@index@file {%
  \global \advance \PTR@fl@count by \@ne
  \TXN@make@sort@key {\PTR@fl@line}%
  \toks@ = \expandafter {\PTR@fl@line@bis}%
  \PTR@check@line@fragment {\the\toks@}%
%    \end{macrocode}
%
%    \begin{macrocode}
  
  \ifx \@undefined \TXN@index@numeri@l
     \xdef \TXN@index@numeri@l {}%
  \fi
  \ifTXN@index@first@lines
    \immediate \write \TXN@idy {%
      {\the\TXN@toks@a\the\toks@i}{\the\toks@}%
      {\TXN@flags}{\TXN@page@number}{\TXN@index@numeri@l}}%
  \fi
  \ifTXN@index@next@first@line
    \ifx \empty \TXN@index@pending 
    \else
      \PTR@write@index@pending
      \edef \TXN@temp {\toks@ = {\hskip 1em\relax\the\toks@}}%
      \TXN@temp
    \fi
    \immediate \write \TXN@idy {%
      {\the\TXN@toks@b\the\toks@i}{\the\toks@}%
      {\TXN@flags+}{\TXN@page@number}%
      {\TXN@index@numeri@l}%
      }%
  \fi
%    \end{macrocode}
% Write all line fragments
%    \begin{macrocode}
  \if \TXN@option *\TXN@flags
    \edef \TXN@temp {\TXN@toks@a = {\the\TXN@toks@a\the\toks@i}}%
    \TXN@temp
    \edef \TXN@temp {\TXN@toks@b = {\the\TXN@toks@b\the\toks@i}}%
    \TXN@temp
    \expandafter \PTR@read@first@line
  \else
    \global \TXN@index@next@first@linefalse
  \fi
}
\def \PTR@write@index@pending {%
  \expandafter \PTR@write@index@pending@bis \TXN@index@pending
}
\def \PTR@write@index@pending@bis #1#2#3#4#5{%
  \immediate \write \TXN@idy {%
     {\the\TXN@toks@b\the\toks@i}{#2}{#3}{#4}{#5}}%
  \gdef \TXN@index@pending {}%
}
%    \end{macrocode}
% Check for a line fragment (|\\| at the end of the line)
% If so, set the '*' flag.
%    \begin{macrocode}
\def \PTR@check@line@fragment #1{%
%<debug> \TXN@trace \PTR@check@line@fragment
  \count@ = \z@
  \@tempcnta = \z@
  \expandafter \PTR@check@line@fragment@bis #1\TXN@nil
}
%    \end{macrocode}
% Is |\\| the last token ?
%    \begin{macrocode}
\def \PTR@check@line@fragment@bis #1{%
  \let \next = \PTR@check@line@fragment@bis
  \ifx \TXN@nil #1\relax
    \ifnum \count@ > \z@
      \ifnum \@tempcnta = \count@
        \edef \TXN@flags {\TXN@flags*}%
      \fi
    \fi
    \let \next = \relax
  \else
    \ifx \\#1\relax
      \advance \@tempcnta by \@ne
      \count@ = \@tempcnta
    \else
      \advance \@tempcnta by \@ne
    \fi
  \fi
  \next
}
%<*debug>
%    \end{macrocode}
% \section{Debugging code} 
%    \begin{macrocode}
\def \PTR@do@showboxes {%
  \begingroup
    \fontfamily{cmr}\selectfont
    \hbadness = \@M  \hfuzz=\maxdimen
    \count@ = \PTR@box@line
    \advance \PTR@box@ind by \@ne
    \loop 
    \ifnum \count@ < \PTR@box@ind
      [%
      \expandafter \ifcase \csname PTR@box@type\the\count@\endcsname
        t\or p\or b\or pb\or s\else ?\fi
      \if \TXN@empty {PTR@box@flags\the\count@}%
      \else
        \edef \TXN@temp {\csname PTR@box@flags\the\count@\endcsname}%
        \ \texttt{\TXN@temp}%
      \fi
      ] %
      (\the\wd\count@) %
      \if \TXN@num {PTR@box@type\the\count@} = \PTR@box@split
      \else
        /\copy\count@/%
      \fi
      \advance \count@ by \@ne
      \endgraf
    \repeat
  \endgroup
}
\newif \ifPTR@showline
\def \PTRshowline {\global \PTR@showlinetrue}
%    \end{macrocode}
%
%    \begin{macrocode}
\global \let \PTR@showboxes = \relax
\def \PTRshowboxes #1{%
  \ifx +#1\relax
    \global \let \PTR@showboxes = \PTR@do@showboxes
  \else
    \global \let \PTR@showboxes = \relax
  \fi
}
%</debug>
%    \end{macrocode}
%% \Finale
%
\endinput
