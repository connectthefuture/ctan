% \iffalse meta-comment
%
% 
%                   COPYRIGHT NOTICE AND LICENSE
% 
% 
% COPYRIGHT
% =========
% 
%    Copyright Gianfranco Boggio-Togna 2006
% 
% 
% DEFINITIONS
% ===========
% 
% In this document the following terms are used:
% 
%    `Work'
%     The files TEXNIKA.dtx, poetry.dtx, drama.dtx, technica.ins and
%     the derived files TEXNIKA.sty, poetry.sty, drama.sty
%     
%     'Copyright Holder'
%     Gianfranco Boggio-Togna
% 
%    `Derived Work'
%     Any work that under any applicable law is derived from the Work.
% 
%    `Modification' 
%     Any procedure that produces a Derived Work under any applicable
%     law -- for example, the production of a file containing an
%     original file associated with the Work or a significant portion of
%     such a file, either verbatim or with modifications and/or
%     translated into another language.
% 
%    `Modify'
%     To apply any procedure that produces a Derived Work under any
%     applicable law.
%     
%    `Distribution'
%     Making copies of the Work available from one person to another, in
%     whole or in part.  Distribution includes (but is not limited to)
%     making any electronic components of the Work accessible by
%     file transfer protocols such as FTP or HTTP or by shared file
%     systems such as Sun's Network File System (NFS).
% 
% 
% CONDITIONS ON DISTRIBUTION AND MODIFICATION
% ===========================================
% 
% 1.  You may distribute a complete, unmodified copy of the Work as you
% received it.  Distribution of only part of the Work is considered
% modification of the Work, and no right to distribute such a Derived
% Work may be assumed under the terms of this clause.
% 
% 2. The Copyright Holder may, without restriction, modify the Work,
% thus creating a Derived Work. The Copyright Holder may also distribute
% the Derived Work without restriction. Derived Works distributed in
% this manner by the Copyright Holder are considered to be updated
% versions of the Work.
% 
% 3.  If you are not the Copyright Holder, you are not allowed
% to modify the Work.
% 
% 4.  The conditions above are not intended to prohibit, and hence do
% not apply to, the modification, by any method, of any component so that it
% becomes identical to an  updated version of that component of the Work as
% it is distributed by the Copyright Holder under Clause 2, above.
% 
% 5. Distribution of the Work in an alternative format, where the Work
% is then produced by applying some process to that format, does not
% relax or nullify any sections of this license as they pertain to the
% results of applying that process.
% 
% 6. This license places no restrictions on works that are unrelated to
% the Work, nor does this license place any restrictions on aggregating
% such works with the Work by any means.
% 
% 7.  Nothing in this license is intended to, or may be used to, prevent
% complete compliance by all parties with all applicable laws.
% 
% 
% CONDITIONS ON USE
% =================
% 
% The Work may be used without charge for non-commercial private
% or academic purposes. Use of the Work for commercial purposes is
% prohibited. To use the Work for commercial purposes you must obtain a
% license for commercial use from the Copyright Holder.
% 
% 
% NO WARRANTY
% ===========
% 
% There is no warranty for the Work.  Except when otherwise stated in
% writing, the Copyright Holder provides the Work `as is', without
% warranty of any kind, either expressed or implied, including, but not
% limited to, the implied warranties of merchantability and fitness for
% a particular purpose.  The entire risk as to the quality and performance
% of the Work is with you.  Should the Work prove defective, you
% assume the cost of all necessary servicing, repair, or correction.
% 
% In no event unless agreed to in writing will the Copyright Holder or
% any other party who may distribute the Work as permitted above, be
% liable to you for damages, including any general, special, incidental
% or consequential damages arising out of any use of the Work or out
% of inability to use the Work (including, but not limited to, loss of
% data, data being rendered inaccurate, or losses sustained by anyone
% as a result of any failure of the Work to operate with any other
% programs), even if the Copyright Holder or said other party has been
% advised of the possibility of such damages.
% 
%<*driver>
\documentclass{ltxdoc}
\usepackage[ibycus,english]{babel}
\usepackage[pagestyles]{titlesec}
\newpagestyle {TEXNIKA@page} {

  \sethead   {}
             {\large {\itshape The} \texttt{TEXNIKA} {\itshape package}} 
             {\textup{\thepage}}
  \setfoot   {}
             {Copyright \copyright\ Gianfranco Boggio--Togna 2006}
             {}%
  \setmarks  {section}{subsection}

}
\setlength{\parindent}{0pt}
\setlength{\textwidth}{5.5in}
\setlength{\textheight}{8.5in}
\setlength{\parskip}{\smallskipamount}
\setcounter{tocdepth}{4}
\MakeShortVerb{|}
\AlsoImplementation
\begin{document}
\DocInput{texnika.dtx}
\end{document}
%</driver>
%
% \fi
%\iftrue \CheckSum{16391}\fi
%
% \def\fileversion{0.99}
% \def\filedate{2006/11/11}
%
\def\TEXNIKA {%
  \expandafter
  \ifx \csname l@polutonikogreek\endcsname \relax
    \expandafter
    \ifx \csname l@ibycus\endcsname \relax
       $\tau\kern-.05em\epsilon\chi\nu\kern-.05em\iota
       \kappa\kern.04em\acute\alpha$%
    \else
      \foreignlanguage{ibycus}{texnika'}%
    \fi
  \else
      \foreignlanguage{polutonikogreek}{teqnik'a}%
  \fi
}
\def \TeXbook {\textit{The \TeX{}book}{}}
\def \TXN@cmd#1{\texttt{\protect\bslash #1}}%
%
% \thispagestyle{empty}
% \begin{centering}
% {\large \textsc{Gianfranco Boggio\,--Togna}}\par
% \vspace*{1in}
% {\Huge \TEXNIKA}\par 
% \vspace*{.15in}
% {\LARGE Typesetting for the Humanities}\par
% \vspace*{.5in}
% {\Large The {\normalsize TEXNIKA} package}\par
% \vfill
% {\Large Version 0.9}\par
% \end{centering}
% \newpage
% \thispagestyle{empty}
% \vspace{6ex}
% \section*{Copyright notice}
% \noindent Copyright \copyright\ Gianfranco Boggio--Togna 2006\par
%        Author's address: C.P. 14021, I-20140 Milano\\
%                  Email: \textsl{gbt\kern .08em @\kern .1em acm.org}
% \vspace{6ex}
% \section*{License}
% \noindent This program is distributed under the terms of the license
% that appears at the start of the file \texttt{TEXNIKA.dtx} (this file)
% and in file \texttt{license.txt} 
%  
% This program consists of the files \texttt{TEXNIKA.dtx} and 
% \texttt{technica.ins} 
%  
% \newpage
% \pagenumbering{roman}
% \tableofcontents
% \newpage
% \pagenumbering{arabic}
% \pagestyle {TEXNIKA@page}
% 
% \StopEventually{}
% \section{Preliminaries} 
% \subsection{External dependencies}
%    \begin{macrocode}
\def \TXN@temp {LaTeX2e}
\def \TXN@temp@bis {2003/12/01}
\@tempswafalse
\ifx \fmtname \TXN@temp
  \ifx \fmtversion \TXN@temp@bis
  \else
    \def \TXN@temp@bis {2005/12/01}
    \ifx \fmtversion \TXN@temp@bis
    \else
      \@tempswatrue
    \fi
  \fi
\else
    \@tempswatrue
\fi
\if@tempswa
   \PackageError {TEXNIKA}
     {The Technica suite requires the LaTex\MessageBreak
      release dated `2003/12/01' or `2005/12/01'}
     {}
   \def\recurse{(\recurse)}\recurse
\fi
%    \end{macrocode}
%
%    \begin{macrocode}
\ProvidesPackage {TEXNIKA}[2006/11/11]
\def \TXN@option@repeat  {n}
\def \TXN@option@stats   {y}
\def \TXN@warnings@level {2}
\def \TXN@showlineno     {n}
\DeclareOption {repeat} {\def\TXN@option@repeat{y}}
\DeclareOption {norepeat} {\def\TXN@option@repeat{n}}
\DeclareOption {nostats} {\def\TXN@option@stats{n}}
\DeclareOption {nowarnings} {\def\TXN@warnings@level{0}}
\DeclareOption {warnings} {\def\TXN@warnings@level{1}}
\DeclareOption {inplacewarnings} {\def\TXN@warnings@level{2}}
\DeclareOption {lineno} {\def\TXN@showlineno{y}}
\ProcessOptions
\RequirePackage {keyval}[1999/03/16 v1.13]
\RequirePackage {calc}[1998/07/07 v4.1b] 
\RequirePackage {txnline}
\RequirePackage {txntitle}
\RequirePackage {txndrop}
\RequirePackage {ifmtarg}[2000/03/24 v1.2]
\RequirePackage {ifthen}[2001/05/26 v1.1c]
\RequirePackage {soul}[2003/11/17 v2.4]
%    \end{macrocode}
% \newpage
% \subsection{Booleans}
%    \begin{macrocode}
%    \end{macrocode}
% A general-purpose switch, always used globally.
%    \begin{macrocode}
\newif \ifTXN@sw
\def   \TXN@sw@true  {\global\TXN@swtrue}
\def   \TXN@sw@false {\global\TXN@swfalse}
%    \end{macrocode}
%
%    \begin{macrocode}
\newif \ifTXN@withinVersus
\newif \ifTXN@withinProsa
\newif \ifTXN@withinDrama
\newif \ifTXN@withinSD
\newif \ifTXN@withinPersona
\newif \ifTXN@withinAd
\newif \ifTXN@withinFaciesStrophae
\newif \ifTXN@withinIndexes
%    \end{macrocode}
%
%    \begin{macrocode}
\newif \ifTXN@milestones
\newif \ifTXN@replay
\newif \ifTXN@lineating
\newif \ifTXN@folio@set
%    \end{macrocode}
%
%    \begin{macrocode}
\newif \ifTXN@poetry
\newif \ifTXN@leaders
\newif \ifTXN@outside@preamble
\newif \ifTXN@blank@line
\newif \ifTXN@after@Spatium
\newif \ifTXN@internal
%    \end{macrocode}
% Visible to the user
%    \begin{macrocode}
\newif \ifNewPage
%    \end{macrocode}
% \subsection{Registers}
% We stick to the rules for scratch registers.
% Registers with names ending in `@' are even-numbered and used only
% with local assignments; odd-numbered registers are used only with
% global assignments.
%    \begin{macrocode}
\dimendef \dimen@iii = 3
\dimendef \dimen@@   = 4
\toksdef  \toks@i    = 1
\toksdef  \toks@@    = 2
\toksdef  \toks@iii  = 3
\toksdef  \toks@v    = 5
\skipdef  \skip@i    = 1
\skipdef  \skip@@    = 2
%    \end{macrocode}
% Work registers
%    \begin{macrocode}
\newcount \TXN@counter
\newcount \TXN@counter@a
\newcount \TXN@counter@b
%    \end{macrocode}
%    \begin{macrocode}
\newdimen \TXN@dim@a
\newdimen \TXN@dim@b
\newdimen \TXN@dim@c
%    \end{macrocode}
%    \begin{macrocode}
\newskip  \TXN@skip@a
\newskip  \TXN@skip@b
\newskip  \TXN@skip@c
%    \end{macrocode}
%    \begin{macrocode}
\newtoks \TXN@toks@a
\newtoks \TXN@toks@b
\newtoks \TXN@toks@c
%    \end{macrocode}
% Dedicated registers
%    \begin{macrocode}
\newskip  \TXN@skip@depth@cclv
%    \end{macrocode}
% Where the paragraph parameters are saved
%    \begin{macrocode}
\newskip  \TXN@baselineskip
\newskip  \TXN@leftskip
\newskip  \TXN@rightskip
\newskip  \TXN@hangindent
\newskip  \TXN@hangafter
%    \end{macrocode}
% The leading space in the line, for both \textit{Versus} and \textit{Prosa}
%    \begin{macrocode}
\newskip  \TXN@leading@space
%    \end{macrocode}
% The output of |\TXN@trim|
%    \begin{macrocode}
\newtoks \TXN@trimmed
%    \end{macrocode}
% The text measure
%    \begin{macrocode}
\newdimen \TXN@measure
\let \Measure = \TXN@measure
%    \end{macrocode}
% \subsection{Boxes}
% Work boxes
%    \begin{macrocode}
\newbox \TXN@vbox
\newbox \TXN@hbox
%    \end{macrocode}
% Dedicated boxes
%    \begin{macrocode}
\newbox \TXN@object@numerus
\newbox \TXN@object@textus
\newbox \TXN@marginalia
\newbox \TXN@standalone
%    \end{macrocode}
% A box for inserts (used for milestones)
%    \begin{macrocode}
  \@next \TXN@insert \@freelist \relax \relax
\def \TXN@max@floats {256\relax}
%    \end{macrocode}
% \subsection{Options} 
% Options marked with an asterisk can be set/tested by the user:
% the value must not be changed.
%    \begin{macrocode}
%    \end{macrocode}
% Paragraph shape
%    \begin{macrocode}
\def \TXN@o@Justified      {j} % *
\def \TXN@o@RangedLeft     {l} % *
\def \TXN@o@RangedRight    {r} % *
\def \TXN@o@Centred        {c} % *
\def \TXN@o@CentredFinal   {f} % *
%    \end{macrocode}
% Areas
%    \begin{macrocode}
\def \TXN@o@AttachedToArea {A}
\def \TXN@o@AreaBottom     {B}
\def \TXN@o@AreaMiddle     {M}
\def \TXN@o@AreaTop        {T}
\def \TXN@o@AreaWrap       {W}
\def \TXN@o@AreaExtend     {E}
%    \end{macrocode}
% Spacing
%    \begin{macrocode}
\def \TXN@o@NoSpatiumAnte  {a} % *
\def \TXN@o@NoSpatiumPost  {p} % *
\def \TXN@o@NoSpatiumSupra {s} % *
\def \TXN@o@NoSpatiumInfra {i} % *
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@o@SpatiumStar         {*}
\def \TXN@o@SpatiumExclude      {x}
\def \TXN@o@SpatiumExcludeDim   {d}
\def \TXN@o@SpatiumExcludeEject {[}
%    \end{macrocode}
% Alignment
%    \begin{macrocode}
\def \TXN@o@AlignedAxis    {a}
\def \TXN@o@AlignedBottom  {b}
\def \TXN@o@AlignedTop     {t}
\def \TXN@o@AlignedMiddle  {m}
\def \TXN@o@AlignedCentre  {C}
\def \TXN@o@AlignedLeft    {L}
\def \TXN@o@AlignedRight   {R}
\def \TXN@o@AlignedTail    {y}
\def \TXN@o@FieldAutoWidth {f}
%    \end{macrocode}
% Drama
%    \begin{macrocode}
\def \TXN@o@PersonaNormal  {n}  
\def \TXN@o@PersonaCentre  {c}  
\def \TXN@o@PersonaLeft    {l} 
\def \TXN@o@DetachedSD     {d} % *
\def \TXN@o@EmbeddedSD     {e} % *
\def \TXN@o@InitialSD      {b} % *
\def \TXN@o@LeftSD         {l} % *
\def \TXN@o@RightSD        {r} % *
\def \TXN@o@NoHangindent   {h} % *
\def \TXN@o@NoFirstIndent  {q} % *
\def \TXN@o@FullWidth      {w} % *
%    \end{macrocode}
% |\textus|
%    \begin{macrocode}
\def \TXN@o@Unhyphenated   {u}
\def \TXN@o@Multiples      {x}
\def \TXN@o@Leaders        {.}
%    \end{macrocode}
% |\numerus|
%    \begin{macrocode}
\def \TXN@o@Pagewise       {p}
%    \end{macrocode}
% Delimiters
%    \begin{macrocode}
\def \TXN@o@DelimiterAtStart {s}
\def \TXN@o@DelimiterAtEnd   {e}
%    \end{macrocode}
% Miscellaneous
%    \begin{macrocode}
\def \TXN@o@NoArgument       {0}
\def \TXN@o@NoFacies         {1}
%    \end{macrocode}
% \subsection{Short-hands}
%    \begin{macrocode}
\def \TXN@exxxpandafter {\expandafter\expandafter\expandafter}
\def \TXN@c {\the\TXN@counter}
%    \end{macrocode}
% Most control sequence names in the suite are built with |\csname|
% |\endcsname|.  These macros make the code somewhat more
% readable (and writable :)
%    \begin{macrocode}
\def \TXN@def  #1{\expandafter\def\csname #1\endcsname}
\def \TXN@edef #1{\expandafter\edef\csname #1\endcsname}
\def \TXN@gdef #1{\expandafter\gdef\csname #1\endcsname}
\def \TXN@xdef #1{\expandafter\xdef\csname #1\endcsname}
%    \end{macrocode}
%    \begin{macrocode}
\def \TXN@let #1=#2{\expandafter\let\expandafter#1\csname #2\endcsname\relax}
\def \TXN@assign #1=#2{\expandafter #1 \csname #2\endcsname\relax}
%    \end{macrocode}
% These macros are used after |\if| (a trick from the Grand Wizard himself...)
%    \begin{macrocode}
\def \TXN@empty #1{00\fi\expandafter \ifx \csname #1\endcsname \empty}
\def \TXN@relax #1{00\fi\expandafter \ifx \csname #1\endcsname \relax}
\def \TXN@num #1#2#3{00\fi\expandafter \ifnum \csname #1\endcsname#2#3\relax}
\def \TXN@x #1{00\fi\expandafter \ifx \csname #1\endcsname}
\def \TXN@option #1#2{00\fi\TXN@test@option #1#2\if@tempswa} 
%    \end{macrocode}
% Two macros used to handle CR within \textit{Versus}
%    \begin{macrocode}
\def \TXN@normalCR {\catcode`\^^M=5 } 
\def \TXN@activeCR {\catcode`\^^M=\active}
\def \Strut {\leavevmode
  \hbox{\vrule height \ht\strutbox depth \dp\strutbox width .25pt}}
%    \end{macrocode}
% Macros to increment/decrement a number held in a control sequence
%    \begin{macrocode}
\def \TXN@incr #1{%
  \count@ = #1\relax
  \advance \count@ by \@ne
  \edef #1{\the\count@}%
}
\def \TXN@gincr #1{%
  \count@ = #1\relax
  \advance \count@ by \@ne
  \xdef #1{\the\count@}%
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@decr #1{%
  \count@ = #1\relax
  \advance \count@ by \m@ne
  \edef #1{\the\count@}%
}
\def \TXN@gdecr #1{%
  \count@ = #1\relax
  \advance \count@ by \m@ne
  \xdef #1{\the\count@}%
}
%    \end{macrocode}
%
% \subsection{Miscellaneous macros}
%
% The pass number
%    \begin{macrocode}
\gdef \TXN@pass {1}%
\def  \TXN@theTextus {0}%
%    \end{macrocode}
% A `sentinel' placed at the end of the parameter list for a macro
%    \begin{macrocode}
\def \TXN@nil {}
%    \end{macrocode}
% Self-explanatory
%    \begin{macrocode}
\def \TXN@self #1{#1}
%    \end{macrocode}
% This macro is placed wherever there is the risk (for example, after macros
% that expand to numerals) of unwanted expansion as \TeX{} looks ahead.
% It is also used in |\ifx| tests to check if a macro holds |\relax|,
% so the definition must NOT be changed.
%    \begin{macrocode}
\def \TXN@safe {\relax}
%    \end{macrocode}
% Makes a new test available in |\ifthenelse|
%    \begin{macrocode}
\def \isempty #1{\boolean{\ifx \empty#1true\else false\fi}}
%    \end{macrocode}
% Used in some debugging output (and available to the user)
%    \begin{macrocode}
\newcommand {\TXNcmr}{%
  \fontencoding{OT1}\fontfamily{cmr}\fontseries{m}%
  \fontshape{n}\selectfont
}
%    \end{macrocode}
% \section{Service macros} 
% 
% \subsection{Lists} 
%
%  Two types of lists are available.  The first (\textit{Simple List}) has
%  the format described in section 3 of the \textit{Dirty Tricks}
%  chapter.  The second (\textit{Name List}) holds named elements, each
%  consisting of a control sequence (the name) and a value (enclosed
%  within braces).
%
%  A \textit{Simple List} is created by |\TXN@SimpleList|.
%  For \textit{Name List}s, |\TXN@NameList| defines a prototype, which
%  is never used directly. An instance of the \textit{Name List}
%  is created by means of an |\edef| using the prototype as argument;
%  for instance:
%
%     |\TXN@NameList\ThePrototype{\first \second \third}|\par
%     |\edef\AnInstance{\ThePrototype}|
%
% Lists are defined and modified by \textbf{local} assignements.  
% If a list is a global structure the next boolean must be set
% to |true| before calling a macro that modifies the list (the
% boolean is automatically reset to |false| after use).
%
%    \begin{macrocode}
\newif \ifTXN@global@list
\let \TXN@listname = \relax
%    \end{macrocode}
%  \subsubsection{Creating a list}
%
%  Create a \textit{Simple List}.\\ 
%  |#1|  the list name \\
%  |#2|  the number of elements
%    \begin{macrocode}
\def \TXN@SimpleList #1#2{%
  \begingroup
    \let \\ = \relax
    \gdef#1{}%
    \@tempcnta = #2\relax
    \loop
    \ifnum \@tempcnta > \z@ 
      \xdef#1{#1\\{}}%
      \advance \@tempcnta by \m@ne
    \repeat
  \endgroup
}
\TXN@SimpleList \TXN@SimpleList@work \z@
%    \end{macrocode}
%  Define a \textit{Name List} prototype. \\
%  |#1|  the \textit{Name List} prototype name\\
%  |#2|  the list element names\\
%  All the list element names are |\let| equal to |\relax|
%    \begin{macrocode}
\def \TXN@NameList #1#2{%
  \count@ = \escapechar
  \escapechar = \m@ne
  \edef #1{\TXN@listname {\string#1}}%
  \escapechar = \count@ 
  \def \TXN@temp {#1}%
  \TXN@NameList@bis #2\TXN@nil
}
\def \TXN@NameList@bis #1{%
  \ifx \TXN@nil #1\relax
  \else
     \let #1 = \relax
     \expandafter
     \edef \TXN@temp {\TXN@temp #1{\relax}}%
     \expandafter \TXN@NameList@bis
  \fi
}
%    \end{macrocode}
%  Check if |#1| is \textit{Name List} of type |#2|
%    \begin{macrocode}
\def \TXN@NameList@check #1#2{%
  \count@ = \z@
  \TXN@sw@false
  \TXN@NameList@check@bis #1\TXN@nil
  \ifTXN@sw
    \TXN@sw@false
    \begingroup
      \TXN@List@gobble {#2}%
      \def \TXN@listname ##1{%
        \if \TXN@x {##1}#2\relax
          \TXN@sw@true
        \fi
      }%
      \setbox\z@ = \hbox {#1}%
    \endgroup
  \fi
}
\def \TXN@NameList@check@bis #1{%
  \let \next = \TXN@NameList@check@bis
  \def \TXN@parameter {#1}%
  \ifx \empty \TXN@parameter
  \else
    \ifx \TXN@nil #1\relax
      \let \next = \relax
    \else
      \ifnum \count@ = \z@
        \ifx \TXN@listname #1\relax
         \TXN@sw@true
        \fi
      \fi
      \advance \count@ by \@ne
    \fi
  \fi
  \next
}
%    \end{macrocode}
%  \subsubsection{Service macros for lists}
%  Make all the elements of a \textit{Name List} equivalent to |\@gobble|.\\
%  |#1| is the list name.
%    \begin{macrocode}
\def \TXN@List@gobble #1{%
  \let \TXN@listname = \@gobble
  \expandafter \TXN@List@gobble@bis #1\TXN@nil
}
\def \TXN@List@gobble@bis #1#2#3\TXN@nil{%
  \TXN@List@gobble@ter #3\TXN@nil
}
\def \TXN@List@gobble@ter #1{%
  \ifx \TXN@nil #1\relax
  \else
    \def \TXN@parameter {#1}%
    \ifx \empty \TXN@parameter
    \else
      \ifx \TXN@parameter \TXN@safe
      \else
        \let #1 = \@gobble
      \fi
    \fi
    \expandafter \TXN@List@gobble@ter
  \fi
}
%    \end{macrocode}
%
%  Determine the list type.\\
%  The argument of the macro call is the expanded list.\\ 
%  If \textit{Simple List},  |\TXN@list@type| is |\empty|\\ 
%  If \textit{Name List},    |\TXN@list@type| is the list prototype 
%
%    \begin{macrocode}
\def \TXN@check@list@type #1{%
  \gdef \TXN@list@type {}%
  \def \TXN@parameter {#1}%
  \ifx \empty \TXN@parameter
  \else
    \expandafter \TXN@check@list@type@bis #1\TXN@nil
  \fi
}
\def \TXN@check@list@type@bis #1#2#3\TXN@nil{%
  \begingroup
    \def \TXN@listname{\TXN@listname}%
    \ifx \TXN@listname #1\relax
      \gdef \TXN@list@type {#2}%
    \fi
  \endgroup
}
%    \end{macrocode}
%
%  Check that the element name is defined for the \textit{Name List}
%  (to catch typos during development). |#1| is the list name,
%  |\TXN@token| holds the element name.
%
%    \begin{macrocode}
\def \TXN@check@name #1{%
%  \count@ = \@ne
%  \expandafter \TXN@check@name@bis #1\TXN@nil
   \count@ = \z@
}
\def \TXN@check@name@bis #1#2#3\TXN@nil{%
  \TXN@check@name@ter #3\TXN@nil
%  \expandafter \TXN@check@name@ter #3\TXN@nil
}
\def \TXN@check@name@ter #1{%
  \ifx \TXN@nil #1\relax
  \else
    \expandafter
    \ifx \TXN@token #1\relax
      \count@ = \z@
    \fi
    \expandafter \TXN@check@name@ter
  \fi
}
%    \end{macrocode}
%  Returns the number of list elements in |\@tempcnta|.\\
%  |#1| is the list name. 
%    \begin{macrocode}
\def \TXN@SimpleList@length #1{%
  \@tempcnta = \z@
  \def \TXN@parameter {#1}%
  \ifx \empty \TXN@parameter
  \else
    \begingroup
      \def \\##1{\global\advance \@tempcnta by \@ne}%
      #1%
    \endgroup
  \fi
}
%    \end{macrocode}
%  \subsubsection{Getting a list element}
%
%  The |\TXN@get| command fetches the value of a list element.\\
%  |#1|  the list name, followed by a dot followed by...\\ 
%  |#2|  the element name\\
%  |#3|  a control sequence to which the value is assigned
%
%  The macro first check |#1| to determine the list type and
%  then calls the appropriate macro.
%
%    \begin{macrocode}
\def \TXN@get #1{%
  \TXN@check@list@type #1\relax
  \ifx \empty \TXN@list@type
     \expandafter \TXN@SimpleList@get
  \else
     \expandafter \TXN@NameList@get
  \fi
#1%
}
%    \end{macrocode}
%
%  Get a value from a \textit{Simple List}
%
%    \begin{macrocode}
\def \TXN@SimpleList@get #1.#2#3{%
  \begingroup
  \global \toks@i = {}%
  \count@ = #2\relax
  \def \\##1{%
    \ifnum \count@ = \z@
      \global \toks@i = {##1}%
    \fi
    \advance \count@ by \m@ne
  }%
  #1%
  \endgroup
  \edef #3{\the\toks@i}%
}
%    \end{macrocode}
%  Get a value from a \textit{Name List}
%
%  All list elements are |\let| equal to |\@gobble| except the
%  element being fetched and then the list is executed.
%
%    \begin{macrocode}
\def \TXN@NameList@get #1.#2#3{%
  \begingroup
  \def \TXN@token {#2}%
  \expandafter \TXN@check@name \csname \TXN@list@type\endcsname
  \ifodd \count@ 
    \PackageError {TEXNIKA}
      {\expandafter\protect\TXN@token\space
        undefined for NameList\space \protect#1}
      {Please report the error to the author}%
  \fi
  \expandafter \TXN@List@gobble \csname \TXN@list@type\endcsname
  \def #2##1{\global \toks@i={##1}}%
  #1%
  \endgroup 
  \edef #3{\the\toks@i}%
}
%    \end{macrocode}
%  \subsubsection{Setting a list element}
%        
%  The |\TXN@set| command sets the value of a list element\\
%  |#1|  the list name, followed by a dot followed by... \\
%  |#2|  the element name\\
%  |#3|  the new value 
%
%  The macro first check |#1| to determine the list type and
%  the calls the appropriate macro.
%
%    \begin{macrocode}
\def \TXN@set #1{%
 \TXN@check@list@type #1\relax
 \ifx \empty \TXN@list@type
     \expandafter \TXN@SimpleList@set
  \else
     \expandafter \TXN@NameList@set
  \fi
#1%
}
%    \end{macrocode}
%
%  Set the value of a \textit{Simple List} element.
%    \begin{macrocode}
\def \TXN@SimpleList@set #1.#2#3{%
   \begingroup
     \TXN@SimpleList \TXN@gtemp \z@
     \count@ = \z@
     \def \\##1{%
       \ifnum \count@ = #2\relax
         \TXN@SimpleList@append \TXN@gtemp{#3}%
       \else
         \TXN@SimpleList@append \TXN@gtemp{##1}%
      \fi
      \advance \count@ by \@ne
     }%
     #1%
     \ifnum \count@ < #2\relax
       \PackageError{TEXNIKA}%
         {Invalid element number for simple list}
         {Please report the error to the author}%
     \fi
   \endgroup
   \ifTXN@global@list \TXN@global@listfalse \global \fi
   \let #1= \TXN@gtemp
}
%    \end{macrocode}
%  Append an element to a \textit{Simple List}.
%  |#1|  the list name\\
%  |#2|  the element 
%    \begin{macrocode}
\def \TXN@SimpleList@append #1#2{%
  \begingroup
    \toks@ = \expandafter {#1}%
    \toks@@ =\expandafter {#2}%
    \xdef \TXN@gtemp{\the\toks@ \noexpand\\{\the\toks@@}}%
  \endgroup
  \ifTXN@global@list \TXN@global@listfalse \global \fi
  \let #1= \TXN@gtemp
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@SimpleList@set@extend #1.#2#3{%
   \begingroup
     \TXN@SimpleList\TXN@gtemp \z@
     \count@ = \z@
     \def \\##1{%
       \ifnum \count@ = #2\relax
         \TXN@SimpleList@append \TXN@gtemp{#3}%
       \else
         \TXN@SimpleList@append \TXN@gtemp{##1}%
      \fi
      \advance \count@ by \@ne
     }%
     #1%
     \ifnum #2 < \count@ 
     \else
       {\loop
        \ifnum \count@ < #2\relax
          \TXN@SimpleList@append \TXN@gtemp {}%
          \advance \count@ by \@ne
        \repeat
        \TXN@SimpleList@append \TXN@gtemp{#3}%
       }%
     \fi
   \endgroup
   \ifTXN@global@list \TXN@global@listfalse \global \fi
   \let #1 = \TXN@gtemp
}
%    \end{macrocode}
%  Set the value of a \textit{Name List} element
%
%  All list elements remain |\let| equal to |\relax| except the
%  element being set and then the list is redefined.
%
%    \begin{macrocode}
\def \TXN@NameList@set #1.#2#3{%
  \def \TXN@token {#2}%
  \count@=\@ne
  \expandafter \TXN@check@name \csname \TXN@list@type\endcsname
  \ifodd \count@ 
    \PackageError{TEXNIKA}%
      {\expandafter\protect\TXN@token\space
       undefined for NameList \protect#1}
      {Please report the error to the author}%
  \fi
  \def #2##1{\noexpand#2{#3}}%
  \edef#1{#1}%
  \let #2 = \relax
}
%    \end{macrocode}
% \subsection{Miscellanea} 
% \subsubsection{Issuing a warning message} 
%
% The starred form of the command is used when we are in |vmode|: it
% does not typeset the line number directly but adds it to the
% |\TXN@marginalia| box.
%    \begin{macrocode}
\newif \ifTXN@Warning@star
\newcommand {\TXN@Warning}{%
  \@ifstar {\TXN@Warning@startrue\TXN@Warning@bis}
           {\TXN@Warning@starfalse\TXN@Warning@bis}%
}
\newcommand {\TXN@Warning@bis}[2][0]{%
  \ifnum \TXN@warnings@level > \z@
    \PackageWarningNoLine {TEXNIKA}
                          {Input line \number\inputlineno: \MessageBreak #2}%
  \fi
  \ifnum \TXN@warnings@level > \@ne
    \begingroup
      \TXNcmr \footnotesize
      \dimen@ = \oddsidemargin
      \ifdim \dimen@ < \evensidemargin
        \dimen@ = \evensidemargin
      \fi
      \dimen@ = .5\dimen@
      \setbox \z@ = \hbox {\lower .45ex \hbox{*}}%
      \if@twocolumn
        \if@firstcolumn
          \setbox \tw@= \llap {%
            \copy \z@ \number\inputlineno \copy \z@ \kern \dimen@}%
        \else
          \setbox \tw@= \rlap {\kern\TXN@measure
                \kern \dimen@ \copy \z@ \number\inputlineno \copy \z@}%
        \fi
      \else
        \setbox \tw@= \llap{%
          \copy \z@ \number\inputlineno \copy \z@ \kern \dimen@}%
      \fi
      \ifTXN@Warning@star
        \global \setbox \TXN@marginalia = \hbox to \z@ {%
          \unhbox \TXN@marginalia \unhbox \tw@}%
      \else
        \ifvmode
          \PackageError {TEXNIKA}
            {WARNING in vmode}
            {Please report the error to the author}%
        \fi
        \box\tw@
      \fi
    \endgroup
  \fi
}
\let \TXN@PackageWarningNoLine = \PackageWarningNoLine
%    \end{macrocode}
% Handling an error in the \texttt{keyval} package
%    \begin{macrocode}
\def \TXN@keyval@error #1{%
   \expandafter \TXN@keyval@error@bis \KV@prefix
   \PackageError {TEXNIKA}
     {Bad argument for \@backslashchar\TXN@temp}
     {Please report the error to the author}%
}
\def \TXN@keyval@error@bis KV@#1@{\def \TXN@temp {#1}}
%    \end{macrocode}
% \subsubsection{Checking for the beginning of a number} 
%    \begin{macrocode}
\newif \ifTXN@isdigit
\newif \ifTXN@issign
\def \TXN@check@start@of@number #1{%
  \TXN@check@start@of@number@bis #1\TXN@nil
}
\def \TXN@check@start@of@number@bis #1#2\TXN@nil{%
  \TXN@isdigittrue
  \TXN@issignfalse
  \ifx 0#1\else
  \ifx 1#1\else
  \ifx 2#1\else
  \ifx 3#1\else
  \ifx 4#1\else
  \ifx 5#1\else
  \ifx 6#1\else
  \ifx 7#1\else
  \ifx 8#1\else
  \ifx 9#1\else
    \TXN@isdigitfalse
    \TXN@issigntrue
    \ifx +#1\else
    \ifx -#1\else
      \TXN@issignfalse
  \fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi
}
%    \end{macrocode}
% \subsubsection{Checking for glue} 
%    \begin{macrocode}
\def \TXN@check@if@glue #1\TXN@nil{%
  \TXN@sw@true
  \begingroup
    \setbox \z@ = \hbox {\skip@ = #1 sp}%
      \ifdim \wd\z@ = \z@
        \TXN@sw@false
      \fi
   \endgroup
}
%    \end{macrocode}
% \subsubsection{Checking for not infinitely stretchable glue} 
%    \begin{macrocode}
\def \TXN@check@if@normal@glue #1{%
  \TXN@sw@true
  \begingroup
    \hbadness = \@M
    \setbox \z@ = \hbox to \maxdimen {\hskip #1}%
    \ifnum \badness = \z@  \TXN@sw@false \fi
  \endgroup
}
%    \end{macrocode}
% \subsubsection{\TXN@cmd{futurenonspacelet}}
% From \TeXbook
%    \begin{macrocode}
\def \futurenonspacelet #1{%
  \def \TXN@cs {#1}%
  \afterassignment \TXN@fnsl@bis \let \TXN@fnsl@token= }
\def \TXN@fnsl@bis {%
  \expandafter \futurelet \TXN@cs \TXN@fnsl@ter}
\def \TXN@fnsl@ter {%
  \expandafter
  \ifx \TXN@cs \@sptoken
    \expandafter \TXN@fnsl@quater
  \else
    \expandafter \TXN@fnsl@token
  \fi
}
\def \TXN@fnsl@quater {\afterassignment \TXN@fnsl@bis \let \next= }
%    \end{macrocode}
% \subsubsection{Checking for an option}
% If the option given in the first argument occurs in the option
% string given in the second argument, set  |\TXN@sw|
%    \begin{macrocode}
\def \TXN@test@option #1#2{%
  \@tempswafalse
  \edef \TXN@token {#1}%
  \expandafter \TXN@test@option@bis #2\TXN@nil
}
\def \TXN@test@option@bis #1{%
  \ifx \TXN@nil #1\relax
  \else
    \if #1\TXN@token
      \@tempswatrue
      \TXN@exxxpandafter \TXN@test@option@ter
    \else
      \TXN@exxxpandafter \TXN@test@option@bis
    \fi
  \fi
}
\def \TXN@test@option@ter #1\TXN@nil{}
%    \end{macrocode}
% \subsubsection{Trimming spaces from a string}
% The result is in the token register |\TXN@trimmed|.\\
% The code is taken from Michael Downes' Solution~5 to 
% exercise 15 of his wonderful \textit{Around the Bend} collection
% (\texttt{tex-archive/info/aro-bend}).
%    \begin{macrocode}
\catcode`\Q=3 %
\def \TXN@trim #1{%
  \begingroup
  \aftergroup \global
  \aftergroup \TXN@trimmed
  \aftergroup {%
  \expandafter \TXN@trim@bis \expandafter \noexpand#1Q Q}%
}
\def \TXN@trim@bis #1 Q{\TXN@trim@ter #1Q}
\def \TXN@trim@ter #1Q#2{%
  \afterassignment \endgroup
  \vfuzz = \the\vfuzz
  #1%
}
\catcode`\Q=11 %
%    \end{macrocode}
% \subsubsection{Checking for a parameter in a macro definition}
% Check if parameter `n' (`n' = |#1|) occurs in macro |#2|
%
%    \begin{macrocode}
{\catcode`\#=11 \global\def \TXN@hash{#}}
\def \TXN@check@parm #1#2{%
  \TXN@sw@false
  \def \TXN@parm@number {#1}%
  \edef\TXN@work{\expandafter\TXN@strip\meaning#2}%
  \expandafter \TXN@check@parm@bis \TXN@work \TXN@check@parm}
\def \TXN@check@parm@bis {%
  \afterassignment
  \TXN@check@parm@ter
  \let\token= }
\def \TXN@check@parm@ter {%
  \ifx \token \TXN@check@parm
    \let \next = \relax
  \else
    \let \next = \TXN@check@parm@bis
    \if \TXN@hash\token 
       \ifTXN@sw
       \else
         \let \next = \TXN@check@parm@quater
      \fi
    \fi
  \fi
  \next
}
\def \TXN@check@parm@quater #1{%
  \if \TXN@parm@number #1\relax
    \TXN@sw@true
  \fi
  \let \token = #1\relax
  \TXN@check@parm@ter
}
\def \TXN@strip #1>{}
%    \end{macrocode}
% 
% \section{Special typographic features} 
% \subsection{General purpose commands} 
% \subsubsection{Changing the font size} 
% Changing the font size (and the inter-line spacing)
%    \begin{macrocode}
\newcommand {\RelSize} [2] [\relax] {%
  \def \TXN@parameter {#1}%
  \ifx \TXN@parameter \TXN@safe
  \else
    \def \baselinestretch{#1}%
  \fi
%    \end{macrocode}
% The following code is from relsize.sty ver 2.0b, placed in the
% public domain by Donald Arseneau.
%    \begin{macrocode}
  \@tempcnta =
    \ifx \@currsize \normalsize   4\else   % funny order is to have most ...
    \ifx \@currsize \small        3\else   % ...likely sizes checked first
    \ifx \@currsize \footnotesize 2\else
    \ifx \@currsize \large        5\else
    \ifx \@currsize \Large        6\else
    \ifx \@currsize \LARGE        7\else
    \ifx \@currsize \scriptsize   1\else
    \ifx \@currsize \tiny         0\else
    \ifx \@currsize \huge         8\else
    \ifx \@currsize \Huge         9\else
    4%
    \fi\fi\fi\fi\fi\fi\fi\fi\fi\fi
  \advance \@tempcnta by #2\relax
  \ifnum \@tempcnta < \z@ 
     \@tempcnta = \z@ 
  \fi
  \ifcase \@tempcnta  
    \tiny 
    \or \scriptsize 
    \or \footnotesize 
    \or \small 
    \or \normalsize 
    \or \large 
    \or \Large 
    \or \LARGE 
    \or \huge 
    \or \Huge
    \else
      \Huge
  \fi
}
%    \end{macrocode}
% \subsubsection{Letter spacing, underlining etc.} 
%    \begin{macrocode}
\sodef \so {} {.15em\relax}{.66em plus .1em\relax}{.66em plus .15em\relax}
\newcommand {\LetterSpace}[2][\relax]{%
  \leavevmode
  \def \TXN@parameter {#1}%
  \ifx \TXN@parameter \TXN@safe
    \expandafter \so \expandafter {#2}%
  \else
    \begingroup
      \TXN@counter@a = \z@
      \TXN@counter@b = \@ne
      \TXN@LetterSpace@parm #1\TXN@nil
      \let \TXN@temp = \SOUL@sopreamble
      \let \SOUL@sopreamble = \relax
      \so{}%
      \SOUL@preamble
      \TXN@skip@a = \SOUL@soletterskip \TXN@safe
      \multiply \TXN@skip@a by \TXN@counter@a
      \divide \TXN@skip@a by \TXN@counter@b
      \TXN@skip@b = \SOUL@soinnerskip  \TXN@safe
      \multiply \TXN@skip@b by \TXN@counter@a
      \divide \TXN@skip@b by \TXN@counter@b
      \TXN@skip@c = \SOUL@soouterskip  \TXN@safe
      \multiply \TXN@skip@c by \TXN@counter@a
      \divide \TXN@skip@c by \TXN@counter@b
      \let \SOUL@sopreamble = \TXN@temp  
      \sodef \so {}{\TXN@skip@a}{\TXN@skip@b}{\TXN@skip@c}%
      \expandafter \so \expandafter {#2}%
    \endgroup
  \fi
}
\def \TXN@LetterSpace@parm #1{%
  \let \next = \TXN@LetterSpace@parm
  \ifx \TXN@nil #1\relax
    \let \next = \relax
  \else
    \ifx /#1\relax
    \else
      \ifnum \TXN@counter@a = \z@
        \TXN@counter@a = #1\relax
      \else
        \TXN@counter@b = #1\relax
      \fi
    \fi
  \fi
  \next
}
\newcommand {\LETTERspace}[2][\relax]{\MakeUppercase{\LetterSpace[#1]{#2}}}
\newcommand {\letterspace}[2][\relax]{\MakeLowercase{\LetterSpace[#1]{#2}}}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand{\Underline}[2][\relax]{%
  \leavevmode
  \def \TXN@parameter {#1}%
  \ifx \TXN@parameter \TXN@safe
  \else
    \begingroup
    \setul #1\relax
  \fi
  \expandafter \ul \expandafter {#2}%
  \ifx \TXN@parameter \TXN@safe
  \else
    \endgroup
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand{\Capitals}[1]{%
  \leavevmode
  \expandafter \caps \expandafter {#1}%
}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand{\StrikeOut}[1]{%
  \leavevmode
  \expandafter \st \expandafter {#1}%
}
\let \Strikeout = \StrikeOut
%    \end{macrocode}
% \subsubsection{\textit{guillemets}} 
%    \begin{macrocode}
\let \guillemetleft = \guillemotleft
\let \guillemetright = \guillemotright
%    \end{macrocode}
% \subsubsection{Old style numerals} 
% The same as |\oldstylenums| except that
% it leaves unaltered any non-digit tokens within the argument.
%    \begin{macrocode}
\newcommand {\OldStyleNums}[1]{%
  \count@ = \z@
  \toks@ = {}%
  \TXN@toks@a = {}%
  \TXN@OldStyleNums@bis #1\TXN@nil
}
\def \TXN@OldStyleNums@bis {\futurelet\TXN@token\TXN@OldStyleNums@ter}
\def \TXN@OldStyleNums@ter {%
  \ifx \TXN@token \@sptoken
     \expandafter \TXN@OldStyleNums@space
   \else
     \expandafter \TXN@OldStyleNums@quater
   \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@OldStyleNums@space {%
     \TXN@OldStyleNums@quater { }%
     \afterassignment \TXN@OldStyleNums@bis \let \TXN@token = }
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@OldStyleNums@quater #1{%
  \ifx \TXN@nil #1\relax
    \ifnum \count@ > \z@
      \edef \TXN@temp {%
        \the\TXN@toks@a\noexpand\oldstylenums{\the\toks@}}%
      \TXN@toks@a = \expandafter {\TXN@temp#1}%
    \fi
    \the\TXN@toks@a
  \else
     \@tempswatrue
     \ifx 0#1\else
     \ifx 1#1\else
     \ifx 2#1\else
     \ifx 3#1\else
     \ifx 4#1\else
     \ifx 5#1\else
     \ifx 6#1\else
     \ifx 7#1\else
     \ifx 8#1\else
     \ifx 9#1\else
       \@tempswafalse
     \fi\fi\fi\fi\fi\fi\fi\fi\fi\fi
     \if@tempswa
       \toks@ = \expandafter {\the\toks@#1}%
       \advance \count@ by \@ne
     \else
       \ifnum \count@ > \z@
         \edef \TXN@temp 
           {\the\TXN@toks@a\noexpand\oldstylenums{\the\toks@}}%
         \TXN@toks@a = \expandafter {\TXN@temp#1}%
       \else
         \TXN@toks@a = \expandafter {\the\TXN@toks@a#1}%
       \fi
       \count@ = \z@
       \toks@ = {}%
     \fi
    \ifx \@sptoken #1\relax
    \else
       \TXN@exxxpandafter \TXN@OldStyleNums@bis
    \fi
  \fi
}
%    \end{macrocode}
% \subsubsection{Roman numerals} 
%    \begin{macrocode}
\newcommand {\RomanNumeral}[1]{{\scshape \romannumeral#1}}
\newcommand {\ROMANnumeral}[1]{%
  \expandafter \uppercase \expandafter{\romannumeral#1}}
%    \end{macrocode}
% \subsubsection{Ordinals} 
%    \begin{macrocode}
\newcommand {\ordinal} [2] [m]{%
  \xdef \theordinal {\csname TXN@ordinal@%
                     \ifx \@undefined\languagename english\else
                     \languagename\fi\endcsname{#1}{#2}{\relax}%
                    }%
}
\newcommand {\Ordinal} [2] [m]{%
  \xdef \theordinal {\csname TXN@ordinal@%
                     \ifx \@undefined\languagename english\else
                     \languagename\fi\endcsname{#1}{#2}{i}%
                    }%
}
\def \TXN@ordinal@english #1#2#3{%
  \ifcase #2\relax
    ???%
  \or \if #3iF\else f\fi irst%
  \or \if #3iS\else s\fi econd%
  \or \if #3iT\else t\fi hird%
  \or \if #3iF\else f\fi ourth%
  \or \if #3iF\else f\fi ifth%
  \or \if #3iS\else s\fi ixth%
  \or \if #3iS\else s\fi eventh%
  \or \if #3iE\else e\fi ighth%
  \or \if #3iN\else n\fi inth%
  \or \if #3iT\else t\fi enth%
  \or \if #3iE\else e\fi leventh%
  \or \if #3iT\else t\fi welfth%
  \or \if #3iT\else t\fi hirteenth%
  \or \if #3iF\else f\fi ourteenth%
  \or \if #3iF\else f\fi ifteenth%
  \or \if #3iS\else s\fi ixteenth%
  \or \if #3iS\else s\fi eventeenth%
  \or \if #3iE\else e\fi ighteenth%
  \or \if #3iN\else n\fi ineteenth%
  \or \if #3iT\else t\fi wentieth%
  \or \if #3iT\else t\fi wenty-first%
  \or \if #3iT\else t\fi wenty-second%
  \or \if #3iT\else t\fi wenty-third%
  \or \if #3iT\else t\fi wenty-fourth%
  \or \if #3iT\else t\fi wenty-fifth%
  \or ??%
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@ordinal@german #1#2#3{%
  \ifcase #2\relax
    ??%
  \or\if #3iE\else e\fi rste%
  \or\if #3iZ\else z\fi weite%
  \or\if #3iD\else d\fi ritte%
  \or\if #3iV\else v\fi ierte%
  \or\if #3iF\else f\fi \"unfte%
  \or\if #3iS\else s\fi echste%
  \or\if #3iS\else s\fi iebente%
  \or\if #3iA\else a\fi chte%
  \or\if #3iN\else n\fi eunte%
  \or\if #3iZ\else z\fi ehnte%
  \or\if #3iE\else e\fi lfte%
  \or\if #3iZ\else z\fi w\"olfte%
  \or\if #3iD\else d\fi reizhente%
  \or\if #3iV\else v\fi ierzhente%
  \or\if #3iF\else f\fi \"unzhente%
  \or\if #3iS\else s\fi echzhente%
  \or\if #3iS\else s\fi iebzhente%
  \or\if #3iA\else a\fi chtzhente%
  \or\if #3iN\else n\fi eunzhente%
  \or\if #3iZ\else z\fi wanzigste%
  \or\if #3iE\else e\fi inundzwanzigste%
  \or\if #3iZ\else z\fi weiundzwanzigste%
  \or\if #3iD\else d\fi reiundzwanzigste%
  \or\if #3iV\else v\fi ierundzwanzigste%
  \or\if #3iF\else f\fi \"unfundzwanzigste%
  \else 
    ??%
  \fi
  \ifx f#1\else \ifx n#1\relax s\else r\fi\fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@ordinal@latin #1#2#3{%
  \ifcase #2\relax
    ??%
  \or \if #3iP\else p\fi rim%
  \or \if #3iS\else s\fi ecund%
  \or \if #3iT\else t\fi erti%
  \or \if #3iQ\else q\fi uart%
  \or \if #3iQ\else q\fi uint%
  \or \if #3iS\else s\fi ext%
  \or \if #3iS\else s\fi eptim%
  \or \if #3iO\else o\fi ctav%
  \or \if #3iN\else n\fi on%
  \or \if #3iD\else d\fi ecim%
  \or \if #3iU\else u\fi ndecim%
  \or \if #3iD\else d\fi uodecim%
  \or \if #3iT\else t\fi erti%
      \ifx f#1\relax a\else \ifx n#1\relax um\else us\fi\fi{} decim%
  \or \if #3iQ\else q\fi uart%
      \ifx f#1\relax a\else\ifx n#1\relax um\else us\fi\fi{} decim%
  \or \if #3iQ\else q\fi uint\ifx f#1\relax a%
      \else \ifx n#1\relax um\else us\fi\fi{} decim%
  \or \if #3iS\else s\fi ext\ifx f#1\relax a%
      \else \ifx n#1\relax um\else us\fi\fi{} decim%
  \or \if #3iS\else s\fi eptim\ifx f#1\relax a%
      \else \ifx n#1\relax um\else us\fi\fi{} decim%
  \or\if #3iD\else d\fi uodevicesim%
  \or\if #3iU\else u\fi ndevicesim%
  \or\if #3iV\else v\fi icesim%
  \or \if #3iU\else u\fi n%
      \ifx f#1\relax a\else \ifx n#1\relax um\else us\fi\fi{} et vigesim%
  \or \if #3iA\else a\fi lter%
      \ifx f#1\relax a\else \ifx n#1\relax um\else\fi\fi{} et vigesim%
  \or \if #3iT\else t\fi erti%
      \ifx f#1\relax a\else \ifx n#1\relax um\else us\fi\fi{} et vigesim%
  \or \if #3iQ\else q\fi uart%
      \ifx f#1\relax a\else \ifx n#1\relax um\else us\fi\fi{} et vigesim%
  \or \if #3iQ\else q\fi uint%
      \ifx f#1\relax a\else \ifx n#1\relax um\else us\fi\fi{} et vigesim%
  \else
    ??%
  \fi
  \ifx f#1\relax a\else \ifx n#1\relax um\else us\fi\fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@ordinal@italian #1#2#3{%
  \ifcase #2\relax
    ??%
  \or \if #3iP\else p\fi rim%
  \or \if #3iS\else s\fi econd%
  \or \if #3iT\else t\fi erz%
  \or \if #3iQ\else q\fi uart%
  \or \if #3iQ\else q\fi uint%
  \or \if #3iS\else s\fi est%
  \or \if #3iS\else s\fi ettim%
  \or \if #3iO\else o\fi ttav%
  \or \if #3iN\else n\fi on%
  \or \if #3iD\else d\fi ecim%
  \or \if #3iU\else u\fi ndicesim%
  \or \if #3iD\else d\fi odicesim%
  \or \if #3iT\else t\fi redicesim%
  \or \if #3iQ\else q\fi uattordicesim%
  \or \if #3iQ\else q\fi uindicesim%
  \or \if #3iS\else s\fi edicesim%
  \or \if #3iD\else d\fi iciassettesim%
  \or \if #3iD\else d\fi iciottesim%
  \or \if #3iD\else d\fi iciannovesim%
  \or \if #3iV\else v\fi entesim%
  \or \if #3iV\else v\fi entunesim%
  \or \if #3iV\else v\fi entiduesim%
  \or \if #3iV\else v\fi entitreesim%
  \or \if #3iV\else v\fi entiquattresim%
  \or \if #3iV\else v\fi enticinquesim%
  \else
    ??%
  \fi
  \ifx f#1\relax a\else o\fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@ordinal@french #1#2#3{%
  \ifcase #2
  \or \ifx f#1\relax
         \if #3iP\else p\fi remi\`ere%
       \else
         \if #3iP\else p\fi remier%
       \fi
  \or \if #3iD\else d\fi euxi\`eme%
  \or \if #3iT\else t\fi roisi\`eme%
  \or \if #3iQ\else q\fi uatri\`eme%
  \or \if #3iC\else c\fi inqui\`eme%
  \or \if #3iS\else s\fi ixi\`eme%
  \or \if #3iS\else s\fi epti\`eme%
  \or \if #3iH\else h\fi uiti\`eme%
  \or \if #3iN\else n\fi euvi\`eme%
  \or \if #3iD\else d\fi ixi\`eme%
  \or \if #3iO\else o\fi nzi\`eme%
  \or \if #3iD\else d\fi ouzi\`eme%
  \or \if #3iT\else t\fi reizi\`eme%
  \or \if #3iQ\else q\fi uatorzi\`eme%
  \or \if #3iQ\else q\fi uinzi\`eme%
  \or \if #3iS\else s\fi eizi\`eme%
  \or \if #3iD\else d\fi ix-septi\`eme%
  \or \if #3iD\else d\fi ix-huiti\`eme%
  \or \if #3iD\else d\fi ix-neuvi\`eme%
  \or \if #3iV\else v\fi ingti\`eme%
  \or \if #3iV\else v\fi ingt et uni\`eme%
  \or \if #3iV\else v\fi ingt-deuxi\`eme%
  \or \if #3iV\else v\fi ingt-troisi\`eme%
  \or \if #3iV\else v\fi ingt-quatri\`eme%
  \or \if #3iV\else v\fi ingt-cinqui\`eme%
  \else
    ????%
  \fi
}
%    \end{macrocode}
% \subsubsection{Mapping numbers to letters} 
% The command to define a new alphabet.  The first argument is the
% name of the alphabet; the second a series of pairs of values
% (lower case/upper case).
%    \begin{macrocode}
\newcommand {\alphabetum} [2][]{%
  \def \TXN@temp {#1}%
  \toks@ = {??}%
  \count@ = \z@
  \TXN@make@alphabetum #2\TXN@nil
}
%    \end{macrocode}
%    \begin{macrocode}
\def \TXN@make@alphabetum #1{%
  \ifx \TXN@nil #1\relax
    \expandafter \TXN@make@alphabetum@bis
  \else
    \ifodd \count@
      \toks@ = \expandafter{\the\toks@ {#1}}% 
    \else
      \toks@ = \expandafter{\the\toks@ \or {#1}}% 
    \fi
    \advance \count@ by \@ne
    \expandafter \TXN@make@alphabetum
  \fi
}
%    \end{macrocode}
%    \begin{macrocode}
\def \TXN@make@alphabetum@bis {%
  \ifodd \count@
    \PackageError {TEXNIKA}
      {The argument of \protect\alphabetum\space has an odd 
       number of entries}%
      {There must be an even number of entries\MessageBreak
       in the argument of \protect\alphabetum}%
  \else
    \divide \count@ by \tw@
    \TXN@edef {TXN@alphabetum@\TXN@temp @count}{\the\count@}%
    \toks@ = \expandafter{\the\toks@ \else??\fi}% 
  \fi
  \TXN@edef {TXN@alphabetum@\TXN@temp}{\the\toks@}%
}
%    \end{macrocode}
% The commands to map a number to a lower/upper case letter.\\
% The first (optional) argument is the name of the alphabet to use.
%    \begin{macrocode}
\newcommand {\letter} [2][]{%
  \TXN@letter {#1}{#2}%
  \expandafter
  \@firstoftwo \ifcase \the\count@\csname TXN@alphabetum@#1\endcsname
}
\newcommand {\Letter}[2][]{%
  \TXN@letter {#1}{#2}%
  \expandafter
  \@secondoftwo \ifcase \the\count@\csname TXN@alphabetum@#1\endcsname
}
%    \end{macrocode}
% Check and adjust the value of the number
%    \begin{macrocode}
\def \TXN@letter #1#2{%
  \TXN@counter = \csname TXN@alphabetum@#1@count\endcsname 
  \count@ = #2\relax
  \ifnum \count@ = \z@
    \PackageError {TEXNIKA}
      {The value of a \protect\numerus\space to be mapped to a letter 
       is zero}
      {The first letter corresponds to 1}%
  \else
    \loop
    \ifnum \count@ > \TXN@counter
      \advance \count@ by -\TXN@counter
    \repeat
  \fi
}
%    \end{macrocode}
% The default alphabet
%    \begin{macrocode}
\alphabetum  {aA bB cC dD eE fF gG hH iI jJ kK lL mM
              nN oO pP qQ rR sS tT uU vV wW xX yY zZ}
%    \end{macrocode}
% Other alphabets:
%    \begin{macrocode}
\alphabetum [latin]
             {aA bB cC dD eE fF gG hH iI kK lL mM
              nN oO pP qQ rR sS tT uU vV xX yY zZ}
%    \end{macrocode}
%    \begin{macrocode}
\alphabetum [italian]
             {aA bB cC dD eE fF gG hH iI lL mM
              nN oO pP qQ rR sS tT uU vV zZ}
%    \end{macrocode}
%    \begin{macrocode}
\alphabetum [ibycus]
             {aA bB gG dD eE zZ hH qQ iI kK lL mM
              nN cC oO pP rR sS tT uU fF xX yY wW}
%    \end{macrocode}
%    \begin{macrocode}
\alphabetum [greek]
             {aA bB gG dD eE zZ hH jJ iI kK lL mM
              nN xX oO pP rR sS tT uU fF qQ yY wW}
%    \end{macrocode}
% A special `alphabet'.
%    \begin{macrocode}
\alphabetum [symbol]
             {** \dag\dag \ddag\ddag \S\S \P\P {$\|$}{$\|$}}
%    \end{macrocode}
% A shorthand for referring to the special alphabet
%    \begin{macrocode}
\def \reference {\letter[symbol]}
%    \end{macrocode}
% \subsubsection{Number range} 
% The first two arguments are the lower and upper
% limits of a numeric range; the third argument (which must be a \LaTeX{}
% counter) is set to the value to be used instead of the second argument
% in printing the range. For instance:\\
% |\NumberRange {1961}{1975}{counter}| sets |counter| to 75;\\
% |\NumberRange {16}{18}{counter}| sets |counter| to 18.
%    \begin{macrocode} 
\newcommand {\NumberRange} [3]{%
  \ifnum #1 > #2\relax
    \PackageError {TEXNIKA}
      {The upper limit of the range is less than the lower limit}
      {\the#1-\the#2}%
  \fi
  \begingroup     % to protect the counters
  \TXN@counter = 10\relax 
  \loop
    \TXN@counter@a = #1\relax 
    \TXN@counter@b = #2\relax 
    \divide \TXN@counter@a by \TXN@counter
    \divide \TXN@counter@b by \TXN@counter
  \ifnum \TXN@counter@a < \TXN@counter@b 
    \multiply \TXN@counter by 10\relax 
  \repeat
  \count@ = #2 
  \multiply \TXN@counter@b by \TXN@counter
  \advance \count@ by -\TXN@counter@b
  \ifnum \TXN@counter = 10\relax 
     \TXN@counter@b = \TXN@counter@a
     \divide \TXN@counter@b by 10\relax 
     \multiply \TXN@counter@b by 10\relax 
     \advance \TXN@counter@a by -\TXN@counter@b
     \ifnum \TXN@counter@a = \@ne 
       \advance \count@ by 10\relax 
     \fi
  \fi
  \TXN@counter = #1\relax
  \divide \TXN@counter by 10\relax 
  \multiply \TXN@counter by -10\relax 
  \advance \TXN@counter by #2\relax
  \global \@nameuse {c@#3} = \count@ 
  \endgroup
}
%    \end{macrocode}
% \subsubsection{`Driving out' the text in an emergency} 
%    \begin{macrocode}
\newif \ifTXN@drive@out
\newcommand {\DriveOut} {%
  \@ifstar {\TXN@DriveOutPar}{\TXN@DriveOut}}
\def \TXN@DriveOutPar {%
  \global \TXN@drive@outtrue
  \begingroup 
  \TXN@DriveOut \def \par {\endgroup\global \TXN@drive@outfalse\par}}
\def \TXN@DriveOut {%
  \spaceskip .33em plus .33em minus .11em
  \xspaceskip .5em  
  \nonfrenchspacing
}
\let \DrivenOut = \DriveOut
%    \end{macrocode}
% \subsubsection{Allowing full hyphenation} 
%    \begin{macrocode}
\newcommand {\FullHyphenation} {%
  \pretolerance -1
  \hyphenpenalty 0
  \exhyphenpenalty 0
  \adjdemerits 0
  \doublehyphendemerits 0
  \finalhyphendemerits 0
}
%    \end{macrocode}
% \subsubsection{Generating some random text}
%    \begin{macrocode}
\newcommand {\lorem}[1][6]{\TXN@lorem #1\TXN@nil}
\def \TXN@lorem #1{%
  \ifx \TXN@nil #1\relax
  \else
    \count@ = #1\relax
    \loop
    \ifnum \count@ > \z@
      Lorem ipsum dolor sit amet, consectetur adipisicing elit,
      sed do eiusmod tempor incididunt ut labore et dolore magna
      aliqua. Ut enim ad minim veniam, quis nostrud exercitation
      ullamco laboris nisi ut aliquip ex ea commodo consequat.
      Duis aute irure dolor in reprehenderit in voluptate velit
      esse cillum dolore eu fugiat nulla pariatur. Excepteur sint
      occaecat cupidatat non proident, sunt in culpa qui officia
      deserunt mollit anim id est laborum.
    \advance \count@ by \m@ne
    \repeat
	\par
	\expandafter \TXN@lorem
  \fi
}
%    \end{macrocode}
% \subsubsection{Generating rules}
%    \begin{macrocode}
\newcommand{\TXN@rule}[1][]{%
  \gdef \TXN@rule@height {0pt}%
  \gdef \TXN@rule@Height {0pt}%
  \gdef \TXN@rule@depth {0pt}%
  \gdef \TXN@rule@level {\maxdimen}%
  \gdef \TXN@rule@type {0}%
  \define@key {rule}{height}[0pt]{\gdef\TXN@rule@height{##1}}%
  \define@key {rule}{Height}[0pt]{\gdef\TXN@rule@Height{##1}}%
  \define@key {rule}{depth}[0pt]{\gdef\TXN@rule@depth{##1}}%
  \define@key {rule}{level}[\maxdimen]{\gdef\TXN@rule@level{##1}}%
  \define@key {rule}{double}[1]{\gdef\TXN@rule@type{##1}}%
  \define@key {rule}{parallel}[2]{\gdef\TXN@rule@type{##1}}%
  \define@key {rule}{total}[3]{\gdef\TXN@rule@type{##1}}%
  \let \KV@errx = \TXN@keyval@error
  \setkeys {rule}{#1}%
  \dimen@ = \hsize
  \TXN@check@if@normal@glue \leftskip
  \ifTXN@sw
    \advance \dimen@ by -\leftskip
  \fi
  \TXN@check@if@normal@glue \rightskip
  \ifTXN@sw
    \advance \dimen@ by -\rightskip
  \fi
  \xdef \TXN@rule@width {\the\dimen@}%
  \ifcase \TXN@rule@type
      % single
    \ifdim \TXN@rule@height = \z@
      \gdef \TXN@rule@height {.4pt}%
    \fi
    \setbox \z@ = \hbox {\vrule width \TXN@rule@width
                                height \TXN@rule@height
                                depth \TXN@rule@depth}%
  \or % double
    \ifdim \TXN@rule@height = \z@
      \gdef \TXN@rule@height {.4pt}%
    \fi
    \setbox\z@ = \vbox {%
      \hrule width \TXN@rule@width 
             height \TXN@rule@height
             depth \TXN@rule@depth
      \dimen@ = \TXN@rule@height \TXN@safe
      \vskip 4\dimen@ \TXN@safe
      \hrule width \TXN@rule@width 
             height \TXN@rule@height 
             depth \TXN@rule@depth
    }%
  \or % parallel
    \ifdim \TXN@rule@height = \z@
      \gdef \TXN@rule@height {.2pt}%
    \fi
    \ifdim \TXN@rule@Height = \z@
      \gdef \TXN@rule@Height {1.6pt}%
    \fi
    \setbox\z@ = \vbox {%
      \hrule width \TXN@rule@width 
             height \TXN@rule@Height
             depth \TXN@rule@depth
      \dimen@ = \TXN@rule@Height \TXN@safe
      \advance \dimen@ by -\TXN@rule@height \TXN@safe
      \vskip \dimen@ \TXN@safe
      \hrule width \TXN@rule@width 
             height \TXN@rule@height 
             depth \TXN@rule@depth
    }%
  \or % total
    \ifdim \TXN@rule@height = \z@
      \gdef \TXN@rule@height {.2pt}%
    \fi
    \ifdim \TXN@rule@Height = \z@
      \gdef \TXN@rule@Height {1.6pt}%
    \fi
    \setbox\z@ = \vbox {%
      \hrule width \TXN@rule@width 
             height \TXN@rule@height 
             depth \TXN@rule@depth
      \dimen@ = \TXN@rule@Height \TXN@safe
      \advance \dimen@ by -\TXN@rule@height \TXN@safe
      \vskip \dimen@ \TXN@safe
      \hrule width \TXN@rule@width 
             height \TXN@rule@Height
             depth \TXN@rule@depth
    }%
  \fi
  \dimen@ = \TXN@rule@level \TXN@safe
  \ifdim \dimen@ = \maxdimen 
    \setbox \tw@ = \hbox {$\vcenter{}$}%
    \dimen@ = \ht\tw@
  \fi
  \parindent \z@
  \everypar {}%
  \endgraf
  \leavevmode \raise \dimen@ \box\z@
  \endgraf
}
\def \Rule {\TXN@rule}
%    \end{macrocode}
% \subsection{Incipit} 
%    \begin{macrocode}
\newif \ifTXN@incipit@check
\def \noincipit {\incipit{}}
%    \end{macrocode}
% The |\incipit| command
%    \begin{macrocode}
\newcommand {\incipit} {%
  \ifx \empty \TXN@attribute@name 
    \expandafter \TXN@incipit
  \else
    \def  \TXN@subclass@name {incipit}%
    \def  \TXN@subclass@number {}%
    \def  \TXN@temp {TXN}%
    \expandafter \TXN@attribute@set
  \fi
}
%    \end{macrocode}
% Setting the |\Facies| attribute
%    \begin{macrocode}
\def \TXN@setFacies@incipit #1{%
  \ifx \empty #1\empty
    \def \TXN@FaciesIncipit {}%
  \else
    \def \TXN@FaciesIncipit ##1##2##3##4{#1}%
  \fi
}
%    \end{macrocode}
% The explicit command
%    \begin{macrocode}
\def \TXN@incipit #1{%
%<debug> \TXN@trace \TXN@incipit
  \let \next = \relax
  \def \TXN@temp {#1}%
  \def \TXN@temp@bis {*}%
  \global \TXN@incipit@checkfalse
  \ifx \empty \TXN@FaciesIncipit 
    \ifx \TXN@temp \TXN@temp@bis
    \else
      #1\relax
    \fi
  \else
    \ifx \empty \TXN@temp 
    \else
      \xdef \TXN@everypar@incipit@save {}%
      \def \TXN@temp@bis {*}%
      \ifx \TXN@temp \TXN@temp@bis
        \global \TXN@incipit@checktrue
        \ifTXN@withinVersus
        \else
          \xdef \TXN@everypar@incipit@save {\the\everypar}%
          \global \everypar {\TXN@check@incipit}%
        \fi
      \else
        \toks@ = {#1}%
        \let \next = \TXN@split@incipit
      \fi
    \fi
  \fi
  \next
}
%    \end{macrocode}
% Split the incipit into its components
%    \begin{macrocode}
\def \TXN@split@incipit{%
%<debug> \TXN@trace \TXN@split@incipit
  \expandafter \TXN@split@incipit@bis \the\toks@\TXN@nil
}
\def \TXN@split@incipit@bis #1#2\TXN@nil{%
%<debug> \TXN@trace \TXN@split@incipit@bis
  \ifcat a\noexpand #1\relax
    \def \TXN@parm@i {#1}%
    \def \TXN@parm@ii {#2}%
    \def \TXN@parm@iii {}%
    \expandafter \TXN@typeset@Incipit
  \else
    \ifx \relax #1\relax
    \else
%    \end{macrocode}
%    Check for |\leavevmode|.
%    \begin{macrocode}
      \ifx \unhbox #1\relax
        \TXN@split@incipit@quater #2\TXN@nil
      \else
        \def \TXN@parm@iii {#1}%
        \TXN@split@incipit@ter #2\TXN@nil
      \fi
    \fi
  \fi
}
\def \TXN@split@incipit@ter #1#2\TXN@nil{%
  \def \TXN@parm@i {#1}%
  \def \TXN@parm@ii {#2}%
  \TXN@typeset@Incipit
}
%    \end{macrocode}
% We just assume this was the |\unhbox| from |\leavevmode|.
%    \begin{macrocode}
\def \TXN@split@incipit@quater #1#2\TXN@nil{%
  \TXN@split@incipit@quinquies #2\TXN@nil
}
\def \TXN@split@incipit@quinquies #1#2\TXN@nil{%
  \ifcat a\noexpand #1\relax
    \def \TXN@parm@i {#1}%
    \def \TXN@parm@ii {#2}%
    \def \TXN@parm@iii {}%
    \expandafter \TXN@typeset@Incipit
  \else
    \def \TXN@parm@iii {#1}%
    \TXN@split@incipit@ter #2\TXN@nil
  \fi
}
%    \end{macrocode}
% Typeset the incipit
%    \begin{macrocode}
\def \TXN@typeset@Incipit {%
  \edef \TXN@parm@iv {\TXN@parm@i\TXN@parm@ii}%
  \leavevmode
  \begingroup
    \ifTXN@withinVersus
      \let \unindent = \relax
    \else
      \def \unindent {\hskip -\parindent}%
    \fi
    \TXN@FaciesIncipit {\TXN@parm@i} {\TXN@parm@ii}
                       {\TXN@parm@iii} {\TXN@parm@iv}%
  \endgroup
}
%    \end{macrocode}
% Check if there is an explicit command; if not, set the incipit 
% automatically.
%    \begin{macrocode}
\def \TXN@check@incipit {%
  \ifTXN@incipit@check
    \global \TXN@incipit@checkfalse
    \ifx \empty \TXN@FaciesIncipit 
    \else
      \TXN@exxxpandafter \TXN@check@incipit@bis
    \fi
  \fi
}
\def \TXN@check@incipit@bis {%
%<debug> \TXN@trace \TXN@check@incipit@bis
  \futurenonspacelet \TXN@temp \TXN@check@incipit@ter}
\def \TXN@check@incipit@ter {%
%<debug> \TXN@trace \TXN@check@incipit@ter
  \ifx \noexpand\incipit \TXN@temp
  \else
    \ifx \empty \TXN@everypar@incipit@save
    \else
      \everypar = \expandafter{\TXN@everypar@incipit@save}%
    \fi
    \toks@ = {}%
    \expandafter \TXN@incipit@auto
  \fi
}
%    \end{macrocode}
% Automatic incipit
%    \begin{macrocode}
\def \TXN@incipit@auto {%
%<debug> \TXN@trace \TXN@incipit@auto
  \futurelet \TXN@token \TXN@incipit@auto@bis
}
\def \TXN@incipit@auto@bis {%
%<debug> \TXN@trace \TXN@incipit@auto@bis
  \let \next = \TXN@split@incipit@auto
  \ifx \TXN@token \PTR@atendofline  % the current meaning of ^^M
  \else
    \ifx \@sptoken \TXN@token
     \let \next = \TXN@incipit@auto@ter
    \else
      \ifx \\\TXN@token
      \else
        \let \next = \TXN@incipit@auto@quater
      \fi
    \fi
  \fi
  \next
}
\def \TXN@incipit@auto@ter {%
  \afterassignment \TXN@split@incipit@auto \let \TXN@token= }
\def \TXN@incipit@auto@quater #1{%
%<debug> \TXN@trace \TXN@incipit@auto@ter
  \toks@ = \expandafter {\the\toks@#1}%
  \TXN@incipit@auto
}
\def \TXN@split@incipit@auto {%
%<debug> \TXN@trace \TXN@split@incipit@auto
  \expandafter \TXN@split@incipit@auto@bis \the\toks@\TXN@nil
}
\def \TXN@split@incipit@auto@bis #1#2\TXN@nil{%
%<debug> \TXN@trace \TXN@split@incipit@auto@bis
  \@ifmtarg {#2}
    {\TXN@split@incipit@auto@ter#1}
    {\TXN@split@incipit@bis #1#2\space\TXN@nil}%
}
\def \TXN@split@incipit@auto@ter #1{%
%<debug> \TXN@trace \TXN@split@incipit@auto@ter
  \ifcat \noexpand#1a
    \toks@ = {#1\space}%
    \expandafter \TXN@incipit@auto 
  \else
    #1\space%
  \fi
}
%    \end{macrocode}
%  The interface with the \texttt{txndrop} package
%    \begin{macrocode}
\gdef \TXN@DropCap@lines {\z@}
\let \DropCap = \TXNd@DropCap
%    \end{macrocode}
% \subsection{Setting the page height and width} 
% Adjust the |\textheight| so that a page can accomodate a whole
% number of lines
%    \begin{macrocode}
\newcommand {\TextHeight}{%
  \@ifstar {\TXN@sw@true \TXN@textheight}{\TXN@sw@false \TXN@textheight}
}
\def \TXN@textheight #1{%
  \ifTXN@sw
    \setlength {\textheight}{\baselineskip}%
    \multiply \textheight by #1\relax
    \advance \textheight by -\baselineskip
  \else
    \setlength {\textheight}{#1}%
    \divide \textheight by \baselineskip
    \multiply \textheight by \baselineskip
  \fi
  \advance \textheight by \topskip
}
%    \end{macrocode}
% This is provided mailnly for symmetry with the previous command
%    \begin{macrocode}
\newcommand {\TextWidth} [1]{%
  \setlength {\textwidth}{#1}%
  \linewidth = \textwidth
  \columnwidth = \textwidth
}
%    \end{macrocode}
% \subsection{Setting the house style} 
%    \begin{macrocode}
\newcommand {\HouseStyle} [1] {%
  \InputIfFileExists {#1.hs}
                     {\def \housestyle {#1}}
                     {\PackageError {TEXNIKA}
                      {House style `#1' not found}
                      {The file `#1.hs' does not exist}
                     }
}
%    \end{macrocode}
% \section{Paragraph formatting} 
%    \begin{macrocode}
\newif \ifTXN@nostyle
\newif \ifTXN@style@set
%    \end{macrocode}
% \subsection{\TXN@cmd{justified}} 
%    \begin{macrocode}
\newcommand {\justified}   {\ifTXN@nostyle \else \TXN@style@justified \fi}
\def \TXN@style@justified  {\TXN@reset@skips \TXN@style@settrue}
%    \end{macrocode}
% \subsection{\TXN@cmd{rangedleft}} 
%    \begin{macrocode}
\newcommand {\rangedleft}  {\ifTXN@nostyle \else \TXN@style@rangedleft \fi}
\def \TXN@style@rangedleft {%
  \TXN@reset@skips
  \advance \rightskip by \z@ plus 1filll\relax
  \TXN@style@settrue
}
%    \end{macrocode}
% \subsection{\TXN@cmd{rangedright}} 
%    \begin{macrocode}
\newcommand {\rangedright} {\ifTXN@nostyle \else \TXN@style@rangedright \fi}
\def \TXN@style@rangedright {%
  \TXN@reset@skips
  \advance \leftskip by \z@ plus 1filll\relax
  \parfillskip = \z@skip
  \TXN@style@settrue
}
%    \end{macrocode}
% \subsection{\TXN@cmd{centered}} 
%    \begin{macrocode}
\newcommand{\centered}{\ifTXN@nostyle \else \TXN@style@centered \fi}
\def \TXN@style@centered {%
  \TXN@reset@skips
  \advance \leftskip by \z@ plus 1filll\relax
  \advance \rightskip by \z@ plus 1filll\relax
  \parfillskip = \z@skip
  \TXN@style@settrue
}
%    \end{macrocode}
% \subsection{\TXN@cmd{centeredfinal}} 
%    \begin{macrocode}
\newif \ifTXN@centrefinal
\newcommand{\centeredfinal}{%
  \ifTXN@nostyle  \else \TXN@style@centeredfinal \fi}
\def \TXN@style@centeredfinal {%
  \global \TXN@centrefinaltrue
  \TXN@style@settrue
}
\let \centred = \centered
\let \centredfinal = \centeredfinal
%    \end{macrocode}
% Remove any stretchability and shrinkability from left and rightskips
%    \begin{macrocode}
\def \TXN@reset@skips {%
  \dimen@ = \leftskip
  \leftskip = \dimen@ \TXN@safe
  \dimen@ = \rightskip
  \rightskip = \dimen@ \TXN@safe
}
\let \leading = \baselineskip
%    \end{macrocode}
% \section{Creating a subclass} 
%
% A subclass is associated with a control sequence of the form\\
% |\csname TXN@|\meta{class name}|[|\meta{subclass number}|]\endcsname|\\
% The \meta{subclass number} is assigned automatically but may
% also be defined explicitly in the |\Novus| command (this is
% an undocumented feature and its use is deprecated).
%
% The default subclass of each class has \meta{subclass number} $=0$
% and $0$ is the default value of the \meta{optional parameter} of the
% command defining the \meta{class}.
%
%
%
% The list of |\textus| subclasses.
%    \begin{macrocode}
\TXN@SimpleList \TXN@textus@subclasses \@ne
\TXN@set \TXN@textus@subclasses.\z@ {textus} 
%    \end{macrocode}
% The list of |\numerus| subclasses.
%    \begin{macrocode}
\TXN@SimpleList \TXN@numerus@subclasses \@ne
\TXN@set \TXN@numerus@subclasses.\z@ {numerus} 
\TXN@def {TXN@numerus[0]name}{numerus}
\newcounter {numerus}%
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@c@numerus #1{%
  \csname c@\csname TXN@numerus[#1]name\endcsname\endcsname}
%    \end{macrocode}
% The list of |\titulus| subclasses.
%    \begin{macrocode}
\TXN@SimpleList \TXN@titulus@subclasses \@ne
\TXN@set \TXN@titulus@subclasses.\z@ {titulus} 
%    \end{macrocode}
% The list of |\spatium| subclasses.
%    \begin{macrocode}
\TXN@SimpleList \TXN@spatium@subclasses \@ne
\TXN@set \TXN@spatium@subclasses.\z@ {spatium} 
%    \end{macrocode}
% The list of special subclasses.
%    \begin{macrocode}
\def \TXN@special@subclasses {%
  \\{stropha}\\{incipit}\\{excessus}\\{persona}\\{commissura}\\{aparte}%
  \\{[}\\{(}%
}
%    \end{macrocode}
% The list of classes that take line numbers
%    \begin{macrocode}
\def \TXN@numbered@classes {}%
%    \end{macrocode}
% Return the subclass number in |\@tempcnta| or |-1| if so such
% subclass exists. The parameters are:
% |#1| the class name (|\textus| or |\numerus| or |\titulus|),
% |#2| the subclass name
%    \begin{macrocode}
\def \TXN@get@subclass@number #1#2{%
  \@tempcnta = \z@
  \gdef \TXN@gtemp {}%
  \begingroup
  \def \\##1{%
    \expandafter
    \ifx \csname ##1\endcsname #2\relax
      \xdef \TXN@gtemp {\the\@tempcnta}%
    \fi
    \advance \@tempcnta by \@ne
  }%
  \@nameuse {TXN@\expandafter\@gobble\string#1@subclasses}%
  \endgroup
  \ifx \empty \TXN@gtemp 
    \@tempcnta = \m@ne
  \else
    \@tempcnta = \TXN@gtemp \TXN@safe
  \fi
}
%    \end{macrocode}
% Sets |\TXN@gtemp| to the subclass name (without the backslash)
% or to |\empty| if no such subclass exists. The parameters are:
% |#1| the class name (|\textus| or |\numerus| or |\titulus|),
% |#2| the subclass number
%    \begin{macrocode}
\def \TXN@get@subclass@name #1#2{%
  \@tempcnta = \z@
  \gdef \TXN@gtemp {}%
  \begingroup
  \def \\##1{%
    \ifnum \@tempcnta = #2\relax
      \xdef \TXN@gtemp {##1}%
    \fi
    \advance \@tempcnta by \@ne
  }%
  \@nameuse {TXN@\expandafter\@gobble\string#1@subclasses}%
  \endgroup
}
%    \end{macrocode}
% Insert the \texttt{cs} (\textit{sans} the escape character) in the
% list of subclasses.
%    \begin{macrocode}
\def \TXN@insert@subclass@name #1#2#3{%
  \TXN@counter = #3\relax
  \advance \TXN@counter by \@ne 
  \expandafter \TXN@SimpleList@length
    \csname TXN@\expandafter\@gobble\string#1@subclasses\endcsname
  \ifnum \@tempcnta < \TXN@counter 
    \loop
      \expandafter \TXN@SimpleList@append 
        \csname TXN@\expandafter\@gobble\string#1@subclasses\endcsname
        \TXN@safe 
      \advance \@tempcnta by \@ne
    \ifnum \@tempcnta < \TXN@counter 
    \repeat
  \fi
  \count@ = \escapechar   \escapechar = \m@ne
  \TXN@toks@a = \expandafter {\string#2}%
  \escapechar = \count@ 
  \advance \TXN@counter by \m@ne 
  \expandafter \TXN@set 
    \csname TXN@\expandafter\@gobble\string#1@subclasses\endcsname.%
    \TXN@counter {\the\TXN@toks@a}% 
}
%    \end{macrocode}
% \subsection{The \TXN@cmd{Novus} command} 
%    \begin{macrocode}
\newif \ifTXN@Novus@star
\newcommand {\Novus}{%
  \@ifstar {\TXN@Novus@startrue \TXN@Novus}
           {\TXN@Novus@starfalse \TXN@Novus}%
}
\def \TXN@Novus {\futurenonspacelet \TXN@temp \TXN@Novus@bis}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@Novus@bis {%
  \ifx \TXN@temp \textus
    \let \next = \TXN@Novus@textus
  \else \ifx \TXN@temp \numerus
    \let \next = \TXN@Novus@numerus
  \else \ifx \TXN@temp \titulus
    \let \next = \TXN@Novus@titulus
  \else \ifx \TXN@temp \spatium
    \let \next = \TXN@Novum@spatium
  \else
     \PackageError{TEXNIKA}%
       {Misplaced \protect\Novus\space command}%
       {\protect\Novus\space must be followed by a class name}%
  \fi\fi\fi\fi
  \next
}
\def \TXN@Novus@textus  {\afterassignment \TXN@new@textus \let\next= }
\def \TXN@Novus@numerus {\afterassignment \TXN@new@numerus \let\next= }
\def \TXN@Novus@titulus {\afterassignment \TXN@new@titulus \let\next= }
\def \TXN@Novum@spatium {\afterassignment \TXN@new@spatium \let\next= }
%    \end{macrocode}
% The usual synonyms
%    \begin{macrocode}
\let \Nova = \Novus
\let \Novum = \Novus
%    \end{macrocode}
% \subsection{Creating a subclass  of the \TXN@cmd{textus} class} 
%    \begin{macrocode}
\def \TXN@new@textus {%
  \def \TXN@subclass@name {textus}%
  \ifTXN@Novus@star
    \expandafter \TXN@textus@reset
  \else
    \expandafter \TXN@new@textus@bis
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@textus@reset #1{%
  \TXN@get@subclass@number \textus #1\relax
  \ifnum \@tempcnta < \z@
    \toks@ = {#1}%
    \expandafter \TXN@new@textus@create
  \else
    \edef \TXN@subclass@number {[\the\@tempcnta]}%
    \TXN@initialize@textus {\the\@tempcnta}%
  \fi
}
\def \TXN@new@textus@create {%
   \expandafter \TXN@new@textus@bis \the\toks@
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@new@textus@bis {\futurelet \TXN@token \TXN@new@textus@ter}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@new@textus@ter{%
  \ifx [\TXN@token
    \expandafter \TXN@new@textus@quinquies
  \else
    \count@ = \TXN@textus@max
    \advance \count@ by \@ne
    \expandafter \TXN@new@textus@quater
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@new@textus@quater{%
  \expandafter \TXN@new@textus@quinquies \expandafter [\the\count@]}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@new@textus@quinquies [#1]#2{%
  \ifTXN@internal
  \else
    \ifnum #1 < \z@
      {\PackageError{TEXNIKA}%
        {You cannot use a negative number as the \MessageBreak
         identifier of \protect\textus\space subclass}
        {}%
      }%
    \fi
  \fi
  \ifx \textus #2\relax
    \PackageError{TEXNIKA}%
    {The control sequence \protect\textus\MessageBreak
     cannot be used for a new subclass}%
    {\protect\textus\space is the default subclass}%
  \fi
  \TXN@get@subclass@number \textus #2\relax
  \ifnum \@tempcnta > \z@
    \PackageError{TEXNIKA}%
    {The \protect#2 subclass already exists}
     {}%
  \fi
%    \end{macrocode}
% Define the \textbf{cs}.
%    \begin{macrocode}
  \def #2{\@ifstar{\textus*[#1]}{\textus[#1]}}%
  \TXN@check@start@of@number {#1}%
  \ifTXN@internal
  \else
    \ifnum #1 > \TXN@textus@max
      \def \TXN@textus@max{#1}%
    \fi
    \PackageInfo{TEXNIKA}%
      {\protect#2 defined as \protect\textus[#1]}%
    \def \TXN@subclass@number {[#1]}%
  \fi
%    \end{macrocode}
% Initialize the variables for the class.
%    \begin{macrocode}
  \TXN@initialize@textus{#1}%
%    \end{macrocode}
% Add the subclass name to the list (not for \TXN@cmd{excessus})
%    \begin{macrocode}
  \ifnum #1 < \z@
  \else
    \TXN@insert@subclass@name \textus #2{#1}% 
  \fi
}
%    \end{macrocode}
% Initialize a \TXN@cmd{textus} subclass
%
% Flags are stored in 3 \textbf{cs} (|\Modus| and |\Locus| may be redefined
% indipendently of each other):
%  \halign {\quad\tt#&\kern 1em#\hfill
%            &\quad\tt#&\kern 1em#\hfill
%            &\quad\tt#&\kern 1em#\hfill\cr
%  \noalign{\texttt{flags}\vskip .3ex}
%  |\TXN@o@NoArgument|&|\TXN@o@DelimiterAtStart|&|\TXN@o@DelimiterAtEnd|\cr
%  \noalign{\texttt{flagsModus}\vskip .3ex}
%  |\TXN@o@AlignedLeft|&|\TXN@o@AlignedRight|&|\TXN@o@AlignedCentre|\cr
%  |\TXN@o@AlignedTtop|&|\TXN@o@AlignedMiddle|&|\TXN@o@AlignedBottom|\cr
%  |\TXN@o@RangedLeft|&|\TXN@o@RangedRight|&|\TXN@o@Centred|\cr
%  |\TXN@o@Justified|&|\TXN@o@FieldAutoWidth|&|\TXN@o@Unhyphenated|\cr
%  |\TXN@o@Multiples|\cr
%  \noalign{\texttt{flagsLocus}\vskip .3ex}
%  |\TXN@o@AttachedToArea|&|\TXN@o@AreaMiddle|&|\TXN@o@AreaTop|\cr
%  |\TXN@o@AreaBottom|&|\TXN@o@AreaWrap|&|\TXN@o@AreaExtend|\cr
%  }
%
%    \begin{macrocode}
\def \TXN@get@textus@flags #1{%
  \edef \TXN@textus@flags {%
    \csname TXN@textus[#1]flags@\TXN@theFolio\endcsname
    \csname TXN@textus[#1]flagsLocus@\TXN@theFolio\endcsname
    \csname TXN@textus[#1]flagsModus@\TXN@theFolio\endcsname
  }%
}          
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@initialize@textus #1{%
  \ifnum #1 = \z@
    \TXN@edef  {TXN@textus[#1]side@recto}{\TXN@leftmargin}%
    \TXN@edef  {TXN@textus[#1]side@verso}{\TXN@leftmargin}%
  \else
    \TXN@def  {TXN@textus[#1]side@recto}{}%
    \TXN@def  {TXN@textus[#1]side@verso}{}%
  \fi
  \TXN@def  {TXN@textus[#1]offset@recto}{\z@}%
  \TXN@def  {TXN@textus[#1]flags@recto}{}%
  \TXN@def  {TXN@textus[#1]flagsLocus@recto}{}%
  \TXN@def  {TXN@textus[#1]flagsModus@recto}{}%
  \TXN@def  {TXN@textus[#1]field@recto}{}%
  \TXN@def  {TXN@textus[#1]area@recto}{}%
%    \end{macrocode}
%
%    \begin{macrocode}
  \TXN@def  {TXN@textus[#1]offset@verso}{\z@}%
  \TXN@def  {TXN@textus[#1]flags@verso}{}%
  \TXN@def  {TXN@textus[#1]flagsLocus@verso}{}%
  \TXN@def  {TXN@textus[#1]flagsModus@verso}{}%
  \TXN@def  {TXN@textus[#1]field@verso}{}%
  \TXN@def  {TXN@textus[#1]area@verso}{}%
%    \end{macrocode}
%
%    \begin{macrocode}
  \TXN@def  {TXN@textus[#1]Facies}{}%
  \TXN@def  {TXN@textus[#1]measure}{}%
  \TXN@def  {TXN@textus[#1]shift}{\z@}%
  \TXN@gdef {TXN@textus[#1]last@shift}{}%
  \TXN@def  {TXN@textus[#1]milestone}{0}%
  \TXN@gdef {TXN@textus[#1]text}{}%
  \TXN@def  {TXN@textus[#1]star}{}%
}
%    \end{macrocode}
% \subsection{Creating a subclass  of the \TXN@cmd{numerus} class} 
%    \begin{macrocode}
\def \TXN@new@numerus {%
  \def \TXN@subclass@name {numerus}%
  \ifTXN@Novus@star
    \expandafter \TXN@numerus@reset
  \else
    \expandafter \TXN@new@numerus@bis
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@numerus@reset #1{%
  \TXN@get@subclass@number \numerus #1\relax
  \ifnum \@tempcnta < \z@
    \toks@ = {#1}%
    \expandafter \TXN@new@numerus@create
  \else
    \edef \TXN@subclass@number {[\the\@tempcnta]}%
    \TXN@initialize@numerus {\the\@tempcnta}%
  \fi
}
\def \TXN@new@numerus@create {%
  \expandafter \TXN@new@numerus@bis \the\toks@
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@new@numerus@bis {%
  \TXN@incr \TXN@numerus@max
  \expandafter \TXN@new@numerus@ter \expandafter{\TXN@numerus@max}%
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@new@numerus@ter #1#2{%
  \ifx \numerus #2\relax
    \PackageError{TEXNIKA}%
    {The control sequence \protect\numerus\MessageBreak
     cannot be used for a new subclass}%
    {\protect\numerus\space is the default subclass}%
  \fi
  \TXN@get@subclass@number \numerus #2\relax
  \ifnum \@tempcnta > \z@
    \PackageError{TEXNIKA}%
    {The \protect#2 subclass already exists}
     {}%
  \fi
  \PackageInfo{TEXNIKA}%
    {\protect#2 defined as \protect\numerus[#1]}%
  \def \TXN@subclass@number {[#1]}%
%    \end{macrocode}
% Define the \textbf{cs}.
%    \begin{macrocode}
  \def #2{\@ifstar{\numerus*[#1]}{\numerus[#1]}}%
%    \end{macrocode}
% Initialize the variables for the class.
%    \begin{macrocode}
  \TXN@edef {TXN@numerus[#1]name}{\expandafter\@gobble\string#2}%
  \edef \TXN@temp {\expandafter\noexpand
    \csname c@\csname TXN@numerus[#1]name\endcsname\endcsname}%
  \expandafter
  \ifx \TXN@temp \relax
    \newcounter {\@nameuse {TXN@numerus[#1]name}}%
  \fi
  \TXN@initialize@numerus{#1}%
%    \end{macrocode}
% Add the subclass name to the list
%    \begin{macrocode}
  \TXN@insert@subclass@name \numerus #2{#1}% 
}
%    \end{macrocode}
% Initialize a \TXN@cmd{numerus} subclass
%
% Flags:
%  \halign {\quad\tt#&\kern 1em#\hfill
%            &\quad\tt#&\kern 1em#\hfill
%            &\quad\tt#&\kern 1em#\hfill\cr
%  |\TXN@o@AlignedFeft|&|\TXN@o@AlignedRight|&|\TXN@o@AlignedCentre|\cr
%  |\TXN@o@AlignedTail|\cr
%  |\TXN@o@RangedLeft|&|\TXN@o@RangedRight|&|\TXN@o@Centred|\cr
%  |\TXN@o@Pagewise|\cr
%  }
%
%    \begin{macrocode}
\def \TXN@initialize@numerus #1{%
  \TXN@gdef {TXN@numerus[#1]index}{0}%
%    \end{macrocode}
%
%    \begin{macrocode}
  \TXN@gdef {TXN@numerus[#1]first@value}{}%
  \TXN@gdef {TXN@numerus[#1]second@value}{}%
  \TXN@gdef {TXN@numerus[#1]separator}{}%
  \TXN@gdef {TXN@numerus[#1]head}{}%
  \TXN@gdef {TXN@numerus[#1]tail}{}%
%    \end{macrocode}
%
%    \begin{macrocode}
  \TXN@gdef {TXN@numerus[#1]previous}{}%
  \TXN@gdef {TXN@numerus[#1]previous@incr}{}%
%    \end{macrocode}
%
%    \begin{macrocode}
  \TXN@def {TXN@numerus[#1]side@recto}{}%
  \TXN@def {TXN@numerus[#1]offset@recto}{\z@}%
  \TXN@def {TXN@numerus[#1]flagsModus@recto}{}%
  \TXN@def {TXN@numerus[#1]field@recto}{}%
  \TXN@def {TXN@numerus[#1]fragment@recto}{lL}%
  \TXN@def {TXN@numerus[#1]classes@recto}{}%
%    \end{macrocode}
%
%    \begin{macrocode}
  \TXN@def {TXN@numerus[#1]side@verso}{}%
  \TXN@def {TXN@numerus[#1]offset@verso}{\z@}%
  \TXN@def {TXN@numerus[#1]flagsModus@verso}{}%
  \TXN@def {TXN@numerus[#1]field@verso}{}%
  \TXN@def {TXN@numerus[#1]fragment@verso}{lL}%
  \TXN@def {TXN@numerus[#1]classes@verso}{}%
%    \end{macrocode}
%
%    \begin{macrocode}
  \TXN@def {TXN@numerus[#1]progressio}{}%
  \TXN@def {TXN@numerus[#1]milestone}{0}%
  \TXN@def {TXN@numerus[#1]SpatiumAnte}{\hskip .5em\relax}%
  \TXN@def {TXN@numerus[#1]printing}{0}%
  \TXN@def {TXN@numerus[#1]frozen}{0}%
  \TXN@def {TXN@numerus[#1]Caput}{}%
  \TXN@def {TXN@numerus[#1]Facies}{}%
}
%    \end{macrocode}
% \subsection{Creating a subclass  of the \TXN@cmd{titulus} class} 
% Create a new class of \textit{titulus}.\par
%    \begin{macrocode}
\def \TXN@new@titulus {%
  \def \TXN@subclass@name   {titulus}%
  \ifTXN@Novus@star
    \expandafter \TXN@titulus@reset
  \else
    \expandafter \TXN@new@titulus@bis
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@titulus@reset #1{%
  \TXN@get@subclass@number \titulus #1\relax
  \ifnum \@tempcnta < \z@
    \toks@ = {#1}%
    \expandafter \TXN@new@titulus@create
  \else
    \edef \TXN@subclass@number {[\the\@tempcnta]}%
    \TXN@initialize@titulus {\the\@tempcnta}%
  \fi
}
\def \TXN@new@titulus@create {%
  \expandafter \TXN@new@titulus@bis \the\toks@
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@new@titulus@bis {%
  \TXN@incr \TXN@titulus@max
  \expandafter \TXN@new@titulus@ter \expandafter{\TXN@titulus@max}%
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@new@titulus@ter #1#2{%
  \ifx \titulus #2\relax
    \PackageError{TEXNIKA}%
    {The control sequence \protect\titulus\MessageBreak
     cannot be used for a new subclass}%
    {\protect\titulus\space is the default subclass}%
  \fi
  \TXN@get@subclass@number \titulus #2\relax
  \ifnum \@tempcnta > \z@
    \PackageError{TEXNIKA}%
    {The \protect#2 subclass already exists}
     {}%
  \fi
%    \end{macrocode}
% Define the \textbf{cs}.
%    \begin{macrocode}
  \def #2{\@ifstar{\titulus*[#1]}{\titulus[#1]}}%
  \PackageInfo {TEXNIKA} {\protect#2 defined as \protect\titulus[#1]}%
  \def \TXN@subclass@number {[#1]}%
  \TXN@initialize@titulus {#1}%
  \TXN@insert@subclass@name \titulus #2{#1}% 
}
%    \end{macrocode}
% Initialize a \TXN@cmd{titulus} subclass
%
% Flags are stored in 2 \textbf{cs} (|\Modus| may be redefined indipendently):
%  \halign {\quad\tt#&\kern 1em#\hfill
%            &\quad\tt#&\kern 1em#\hfill
%            &\quad\tt#&\kern 1em#\hfill\cr
%  \noalign{\texttt{flags}\vskip .3ex}
%  |\TXN@o@NoArgument|\cr
%  \noalign{\texttt{flagsModus}\vskip .3ex}
%  }
%
%    \begin{macrocode}
\def \TXN@initialize@titulus #1{%
  \TXN@def {TXN@titulus[#1]Forma}{}%
  \TXN@def {TXN@titulus[#1]Caput}{}%
  \TXN@def {TXN@titulus[#1]flags}{}%
  \TXN@def {TXN@titulus[#1]flagsModus}{}%
  \TXN@def {TXN@titulus[#1]SpatiumSupra}{}%
  \TXN@def {TXN@titulus[#1]SpatiumInfra}{}%
}
%    \end{macrocode}
% \subsection{Creating a subclass  of the \TXN@cmd{spatium}\ class} 
% Create a new subclass of \textit{spatium}.\par
%    \begin{macrocode}
\def \TXN@new@spatium {%
  \def \TXN@subclass@name {spatium}%
  \ifTXN@Novus@star
    \expandafter \TXN@new@spatium@reset
  \else
    \expandafter \TXN@new@spatium@bis
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@new@spatium@reset #1{%
  \TXN@get@subclass@number \spatium #1\relax
  \ifnum \@tempcnta < \z@
    \toks@ = {#1}%
    \expandafter \TXN@new@spatium@create
  \else
    \edef \TXN@subclass@number {[\the\@tempcnta]}%
    \TXN@initialize@spatium {\the\@tempcnta}%
  \fi
}
\def \TXN@new@spatium@create {%
  \expandafter \TXN@new@spatium@bis \the\toks@
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@new@spatium@bis {%
  \TXN@incr \TXN@spatium@max
  \expandafter \TXN@new@spatium@ter \expandafter{\TXN@spatium@max}%
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@new@spatium@ter #1#2{%
  \ifx \spatium #2\relax
    \PackageError{TEXNIKA}%
    {The control sequence \protect\spatium\MessageBreak
     cannot be used for a new subclass}%
    {\protect\spatium\space is the default subclass}%
  \fi
  \TXN@get@subclass@number \spatium #2\relax
  \ifnum \@tempcnta > \z@
    \PackageError{TEXNIKA}%
    {The \protect#2 subclass already exists}
     {}%
  \fi
%    \end{macrocode}
% Define the \textbf{cs}.
%    \begin{macrocode}
  \def #2{\@ifstar{\spatium*[#1]}{\spatium[#1]}}%
  \PackageInfo {TEXNIKA} {\protect#2 defined as \protect\spatium[#1]}%
  \def \TXN@subclass@number {[#1]}%
  \TXN@initialize@spatium {#1}%
  \TXN@insert@subclass@name \spatium #2{#1}% 
}
%    \end{macrocode}
% Initialize a \TXN@cmd{spatium} subclass
%
%    \begin{macrocode}
\def \TXN@initialize@spatium #1{%
  \TXN@def {TXN@spatium[#1]Facies}{}%
  \TXN@def {TXN@spatium[#1]hFacies}{}%
  \TXN@def {TXN@spatium[#1]flags}{}%
}
%    \end{macrocode}
% 
% \section {Setting the subclass attributes}
% \subsection {The switching mechanism}
%    \begin{macrocode}
\newif \ifTXN@attribute@starred
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@attribute@name  {}
\def \TXN@attribute@line  {}
\def \TXN@subclass@name   {}
\def \TXN@subclass@number {}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand {\Facies}       {\TXN@attribute{Facies}}
\newcommand {\Locus}        {\TXN@attribute{Locus}}
\newcommand {\Forma}        {\TXN@attribute{Forma}}
\newcommand {\Modus}        {\TXN@attribute{Modus}}
\newcommand {\Caput}        {\TXN@attribute{Caput}}
\newcommand {\Progressio}   {\TXN@attribute{Progressio}}
\newcommand {\SpatiumAnte}  {\TXN@attribute{SpatiumAnte}}
\newcommand {\SpatiumPost}  {\TXN@attribute{SpatiumPost}}
\newcommand {\SpatiumSupra} {\TXN@attribute{SpatiumSupra}}
\let \SpatiumSuper = \SpatiumSupra
\newcommand {\SpatiumInfra} {\TXN@attribute{SpatiumInfra}}
%    \end{macrocode}
% Check for the starred form and supply, if needed, the implicit subclass
% name and number.
%    \begin{macrocode}
\def \TXN@attribute #1{%
%<debug>  \TXN@trace \TXN@attribute
  \ifx \empty \TXN@attribute@name 
    \def \TXN@attribute@name {#1}%
    \edef \TXN@attribute@line {\the\inputlineno}%
    \expandafter \TXN@attribute@bis
  \else
    \PackageError{TEXNIKA}%
      {The command \@bachslashchar\TXN@attribute@name\space at line %
       \number\TXN@attribute@line\space\space was\MessageBreak
        not followed by a subclass name}
      {}%
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@attribute@bis {%
%<debug>  \TXN@trace \TXN@attribute@bis
  \@ifstar    {\TXN@attribute@starredtrue\TXN@attribute@ter}
              {\TXN@attribute@starredfalse\TXN@attribute@ter}%
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@attribute@ter {%
  \let \TXN@save@Delimiter = \Delimiter
  \def \Delimiter {\Delimiter}%
  \futurenonspacelet \TXN@token \TXN@attribute@quater
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@attribute@quater {%
%<debug>  \TXN@trace \TXN@attribute@quater
  \ifx \\\TXN@token
    \expandafter \TXN@attribute@esc@esc 
  \else
    \ifx \TXN@token \Delimiter
      \let \Delimiter = \TXN@save@Delimiter 
      \TXN@exxxpandafter \TXN@attribute@Delimiter 
    \else
      \let \Delimiter = \TXN@save@Delimiter 
      \TXN@exxxpandafter \TXN@attribute@quinquies 
    \fi
  \fi
}
%    \end{macrocode}
% The special case of |\\|
%    \begin{macrocode}
\def \TXN@attribute@esc@esc #1{%
%<debug>  \TXN@trace \TXN@attribute@esc@esc
  \def \TXN@subclass@name {esc@esc}%
  \def \TXN@subclass@number {}%
  \def \TXN@temp {TXN}%
  \TXN@attribute@set 
}
%    \end{macrocode}
% The special case of |\Delimiter|
%    \begin{macrocode}
\def \TXN@attribute@Delimiter #1{%
%<debug>  \TXN@trace \TXN@attribute@Delimiter
  \def \TXN@subclass@name {Delimiter}%
  \def \TXN@subclass@number {}%
  \def \TXN@temp {TXN}%
  \TXN@attribute@set 
}
%    \end{macrocode}
% If no subclass name precedes the opening brace, insert it.
%    \begin{macrocode}
\def \TXN@attribute@quinquies {%
%<debug>  \TXN@trace \TXN@attribute@quinquies
  \TXN@swfalse
  \ifx \TXN@token \bgroup 
    \TXN@sw@true
  \else
    \ifx +\TXN@token 
      \TXN@sw@true
    \else
      \ifx -\TXN@token 
        \TXN@sw@true
      \fi
    \fi
  \fi
  \ifTXN@sw
    \ifx \empty \TXN@subclass@name 
      \PackageError {TEXNIKA}
        {There is no implicit subclass name}
        {You must supply a subclass name after 
         \@backslashchar\TXN@attribute@name}%
    \else
      \TXN@exxxpandafter \TXN@attribute@sexies
    \fi
  \else
    \TXN@get@subclass@number \textus \TXN@token
    \ifnum \@tempcnta < \z@
      \TXN@get@subclass@number \titulus \TXN@token
      \ifnum \@tempcnta < \z@
        \TXN@get@subclass@number \numerus \TXN@token
        \ifnum \@tempcnta < \z@
          \TXN@get@subclass@number \spatium \TXN@token
          \ifnum \@tempcnta < \z@
            \TXN@get@subclass@number \special \TXN@token
          \fi
        \fi
      \fi
    \fi
    \ifnum \@tempcnta < \z@
      \TXN@exxxpandafter \TXN@attribute@quinquies@error 
    \fi
  \fi
}
\def \TXN@attribute@quinquies@error #1{%
      \PackageError {TEXNIKA}
        {There is no \protect #1 subclass}
        {You may have forgotten to define it or mispelled the name}%
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@attribute@sexies {%
%<debug>  \TXN@trace \TXN@attribute@sexies
  \edef \TXN@temp {\TXN@subclass@name}%
  \def \TXN@temp@bis {bracketSD}%
  \ifx \TXN@temp \TXN@temp@bis
     \def \TXN@temp {[}%
  \else
     \def \TXN@temp@bis {parenthesisSD}%
     \ifx \TXN@temp \TXN@temp@bis
       \def \TXN@temp {(}%
     \fi
  \fi
  \csname \TXN@temp \expandafter\endcsname \TXN@subclass@number
}
%    \end{macrocode}
% Build the control sequence for the name of the macro that sets
% the attribute and call it. 
%    \begin{macrocode}
\def \TXN@attribute@set {%
%<debug>  \TXN@trace \TXN@attribute@set
  \ifx \empty \TXN@subclass@number 
    \expandafter \TXN@attribute@set@ter
  \else
    \expandafter \TXN@attribute@set@bis
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand {\TXN@attribute@set@bis}[1][0]{%
%<debug>  \TXN@trace \TXN@attribute@set@bis
  \def \TXN@subclass@number {[#1]}%
  \TXN@attribute@set@ter
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@attribute@set@ter {%
%<debug>  \TXN@trace \TXN@attribute@set@ter
    \expandafter \def
    \expandafter \TXN@temp
    \expandafter {\csname \TXN@temp @set\TXN@attribute@name 
                  @\TXN@subclass@name\endcsname}%
    \TXN@sw@false
    \expandafter
    \ifx \TXN@temp \@undefined
      \TXN@sw@true
    \else
      \expandafter
      \ifx \TXN@temp \relax
        \TXN@sw@true
      \fi
    \fi
    \ifTXN@sw
      \PackageError {TEXNIKA}
        {\@backslashchar\TXN@attribute@name\space is not an 
         attribute\MessageBreak of the \@backslashchar
         \TXN@subclass@name\space class}
        {}%
    \fi
    \def \TXN@attribute@name {}%
    \expandafter \TXN@temp \TXN@subclass@number
}
%    \end{macrocode}
% \subsection {Setting the \TXN@cmd{Facies} attributes}
% \subsubsection{Setting \TXN@cmd{Facies} for \TXN@cmd{textus}}
%    \begin{macrocode}
\newcommand{\TXN@setFacies@textus}[2][0]{%
  \ifnum #1 = \z@
    \TXN@setFacies@textus@zero {#2}%
  \else
    \TXN@setFacies@textus@bis {#1}{#2}%
  \fi
}
%    \end{macrocode}
% |\Facies| for the default subclass is a parameterless macro.
%    \begin{macrocode}
\def \TXN@setFacies@textus@zero #1{%
%<debug>  \TXN@trace \TXN@setFacies@textus@zero
  \def \TXN@temp ##1{#1}%
  \TXN@check@parm 1\TXN@temp
  \ifTXN@sw
    \PackageError {TEXNIKA}
      {\protect\Facies\space\protect\textus\space contains \TXN@hash1}
      {The attribute cannot contain a reference to a parameter}%
  \fi
  \ifTXN@attribute@starred
    \TXN@let \TXN@temp = {TXN@textus[\TXN@theTextus]Facies}%
    \toks@ = \expandafter {\TXN@temp #1}%
    \TXN@edef {TXN@textus[\TXN@theTextus]Facies}{\the\toks@}%
  \else
    \TXN@def {TXN@textus[\TXN@theTextus]Facies}{#1}%
  \fi
  \ifTXN@withinProsa 
    \@nameuse{TXN@textus[\TXN@theTextus]Facies}\relax
  \fi
}
%    \end{macrocode}
% A subclass other than the default subclass.
%    \begin{macrocode}
\def \TXN@setFacies@textus@bis #1#2{%
  \TXN@sw@false
  \if \TXN@empty {TXN@textus[#1]Facies}%
  \else
    \ifTXN@attribute@starred
      \TXN@sw@true
    \fi
  \fi
  \ifTXN@sw
    \TXN@let \TXN@temp = {TXN@textus[#1]Facies}%
    \toks@ = \expandafter {\TXN@temp#2}%
    \TXN@edef {TXN@textus[#1]Facies}##1{\the\toks@}%
  \else
    \TXN@def {TXN@textus[#1]Facies}##1{#2\relax}%
  \fi
  \def \TXN@temp ##1{#2}%
  \TXN@check@parm 1\TXN@temp
  \ifTXN@sw
  \else
    \TXN@def {TXN@textus[#1]Facies}{#2\relax}%
    \TXN@setFacies@textus@flag {#1}{\TXN@o@NoArgument}%                         
    \def \TXN@temp {#2}%
    \ifx \empty \TXN@temp
      \TXN@setFacies@textus@flag {#1}{\TXN@o@NoFacies}%                         
    \fi
  \fi
  \TXN@setFacies@textus@delimiter {#1}{#2}%
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@setFacies@textus@flag #1#2{%
  \edef \TXN@flags {\@nameuse{TXN@textus[#1]flags@recto}}%
  \TXN@edef {TXN@textus[#1]flags@recto}{#2\TXN@flags}%
  \edef \TXN@flags {\@nameuse{TXN@textus[#1]flags@verso}}%
  \TXN@edef {TXN@textus[#1]flags@verso}{#2\TXN@flags}%
}
%    \end{macrocode}
% Scan the argument for delimiters. Set option 's' if there is a
% delimiter at the start of the argument, option 'e' if there is
% one at the end.
%    \begin{macrocode}
\def \TXN@setFacies@textus@delimiter #1#2{%
  \TXN@counter@a = \z@
  \TXN@counter@b = \z@
  \count@ = \z@
  \let \TXN@save@Delimiter = \Delimiter
  \def \Delimiter {\Delimiter}%
  \TXN@setFacies@textus@delimiter@bis #2\TXN@nil
  \TXN@sw@false
  \ifnum \TXN@counter@b = \z@
  \else
    \ifnum \TXN@counter@b = \count@
      \TXN@setFacies@textus@flag {#1}{\TXN@o@DelimiterAtEnd}%   
    \else
      \TXN@sw@true
    \fi
  \fi
  \ifnum \TXN@counter@a = \z@
  \else
    \ifnum \TXN@counter@a = \@ne
      \TXN@setFacies@textus@flag {#1}{\TXN@o@DelimiterAtStart}%         
    \else
      \ifnum \TXN@counter@a = \count@
        \TXN@setFacies@textus@flag {#1}{\TXN@o@DelimiterAtEnd}%           
      \else
        \TXN@sw@true
      \fi
    \fi
  \fi
  \ifTXN@sw
    \PackageError {TEXNIKA}
      {Misplaced \protect\Delimiter\space in \protect\Facies}
      {\protect\Delimiter\space can only occur at either end}%
  \fi
  \let \Delimiter = \TXN@save@Delimiter
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@setFacies@textus@delimiter@bis #1{%
  \let \next = \TXN@setFacies@textus@delimiter@bis
  \ifx \TXN@nil #1\relax
    \let \next = \relax
  \else
    \advance \count@ by \@ne 
    \ifx \Delimiter #1\relax
      \ifnum \TXN@counter@a = \z@
        \TXN@counter@a = \count@
      \else
        \ifnum \TXN@counter@b = \z@
          \TXN@counter@b = \count@
        \else
          \TXN@counter@b = \m@ne 
        \fi
      \fi
      \let \next = \TXN@setFacies@textus@delimiter@ter
    \fi
  \fi
  \next
}
%    \end{macrocode}
% Gobble the star (if any) and the arguments of |\Delimiter|
% and continue scanning.
%    \begin{macrocode}
\def \TXN@setFacies@textus@delimiter@ter {%
  \@ifstar {\TXN@setFacies@textus@delimiter@quater}
           {\TXN@setFacies@textus@delimiter@quater}%
}
\newcommand {\TXN@setFacies@textus@delimiter@quater}[2][\relax]{%
  \TXN@setFacies@textus@delimiter@bis
}
%    \end{macrocode}
% \subsubsection{Setting \TXN@cmd{Facies} for \TXN@cmd{numerus}}
%    \begin{macrocode}
\newcommand{\TXN@setFacies@numerus}[2][0]{%
  \TXN@def {TXN@numerus[#1]Facies}##1##2##3##4##5{%
    \begingroup #2\endgroup}%
}
%    \end{macrocode}
% \subsubsection{Setting \TXN@cmd{Facies} for \TXN@cmd{titulus}}
%    \begin{macrocode}
\newcommand{\TXN@setFacies@titulus}[2][0]{%
  \TXN@def {TXN@titulus[#1]Facies}##1{#2}%
  \@ifmtarg {#2}
    {\TXN@def {TXN@titulus[#1]Facies}{}}
    {%
     \TXN@def {TXN@titulus[#1]Facies}##1{#2}%
     \def \TXN@temp ##1{#2}%
     \TXN@check@parm 1\TXN@temp
     \ifTXN@sw
     \else
       \edef \TXN@flags {\@nameuse{TXN@titulus[#1]flags}}%
       \TXN@edef {TXN@titulus[#1]flags}{\TXN@o@NoArgument\TXN@flags}%          
     \fi
    }%
}
%    \end{macrocode}
% \subsubsection{Setting \TXN@cmd{Facies} for \TXN@cmd{spatium}}
%    \begin{macrocode}
\newcommand{\TXN@setFacies@spatium}[2][0]{%
%<debug>  \TXN@trace  \TXN@setFacies@spatium
  \def \TXN@temp ##1{#2}%
  \TXN@check@parm 1\TXN@temp
  \ifTXN@sw
    \TXN@def {TXN@spatium[#1]Facies}##1{#2}%
  \else
    \edef \TXN@flags {\@nameuse{TXN@spatium[#1]flags}}%
    \def \TXN@temp {#2}%
    \ifx \empty \TXN@temp
      \TXN@edef {TXN@spatium[#1]flags}{\TXN@o@NoFacies\TXN@flags}%          
    \else
      \TXN@build@spatium@list {#2}%
      \TXN@edef {TXN@spatium[#1]Facies}{\TXN@L@spatium}%
      \TXN@build@spatium@horizontal {#2}% 
      \TXN@edef {TXN@spatium[#1]hFacies}{\TXN@temp}%
    \fi
    \TXN@edef {TXN@spatium[#1]flags}{\TXN@o@NoArgument\TXN@flags}%          
  \fi
}
%    \end{macrocode}
% Build the command for horizontal spacing
%    \begin{macrocode}
\def \TXN@build@spatium@horizontal #1{%
%<debug>  \TXN@trace  \TXN@build@spatium@horizontal
  \def \TXN@temp {}%
  \TXN@build@spatium@horizontal@check #1\TXN@nil
}
\def \TXN@build@spatium@horizontal@check #1#2\TXN@nil {%
  \@ifmtarg {#2}
    {\TXN@build@spatium@horizontal@check@subclass {#1}}
    {\TXN@build@spatium@horizontal@normal {#1#2}}%
}
\def \TXN@build@spatium@horizontal@check@subclass #1{%
  \TXN@get@subclass@number \spatium #1\relax
  \ifnum \@tempcnta = \m@ne
    \TXN@build@spatium@horizontal@normal {#1}%
  \else
    \edef \TXN@flags {\@nameuse{TXN@spatium[\the\@tempcnta]flags}}%
    \if \TXN@option \TXN@o@NoArgument \TXN@flags
      \expandafter \def \expandafter \TXN@temp \expandafter 
        {\csname TXN@spatium[\the\@tempcnta]hFacies\endcsname}%
    \else
      \PackageError {TEXNIKA}
        {The \protect\spatium\space subclass \protect#1 
         cannot be used\MessageBreak
         as the argument for an attribute}
        {The \protect\Facies\space attribute for the \protect#1 subclass
         \MessageBreak contains a reference to a parameter}%
    \fi
  \fi
}
\def \TXN@build@spatium@horizontal@normal #1{%
  \TXN@build@spatium@list {#1}%
  \TXN@get \TXN@L@spatium.\TXN@s@glue    \TXN@glue
  \TXN@get \TXN@L@spatium.\TXN@s@penalty \TXN@penalty
  \ifx \TXN@glue \TXN@safe
  \else
    \edef \TXN@temp {\hskip \TXN@glue\relax}%
  \fi
  \ifx \TXN@penalty \TXN@safe
  \else
    \edef \TXN@temp {\penalty \TXN@penalty\relax\TXN@temp}%
  \fi
}
%    \end{macrocode}
% \subsection{Setting the \TXN@cmd{Locus} attribute}
% \subsubsection{Setting \TXN@cmd{Locus} for \TXN@cmd{textus}}
%    \begin{macrocode}
\newcommand{\TXN@setLocus@textus}[2][0]{%
  \TXN@counter = #1\relax
  \def \TXN@entity@code {t}%
  \TXN@setLocus{#2}%
}
%    \end{macrocode}
% \subsubsection{Setting \TXN@cmd{Locus} for \TXN@cmd{numerus}}
%    \begin{macrocode}
\newcommand{\TXN@setLocus@numerus}[2][0]{%
  \TXN@counter = #1\relax
  \def \TXN@entity@code {n}%
  \TXN@setLocus{#2}%
}
%    \end{macrocode}
%
% \subsubsection{The common code for \TXN@cmd{Locus}}
%
% |\TXN@counter| holds the subclass number.
%
% The codes for the text position (right = even)
%    \begin{macrocode}
\def \TXN@auto           {-3}
\def \TXN@left           {-2}
\def \TXN@centre         {-1}
\def \TXN@rightmargin     {0}
\def \TXN@leftmargin      {1}
\def \TXN@textrightmargin {2}
\def \TXN@textleftmargin  {3}
\def \TXN@textrightedge   {4}
\def \TXN@textleftedge    {5}
\newif \ifTXN@textus@shift
\newif \ifTXN@textus@shift@minus
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@setLocus #1{%
  \global \TXN@textus@shiftfalse
  \global \TXN@textus@shift@minusfalse
  \if n\TXN@entity@code
    \def \TXN@entity {TXN@numerus}%
  \else \if t\TXN@entity@code
    \def \TXN@entity {TXN@textus}%
  \fi\fi
%    \end{macrocode}
% Check for empty attribute (not allowed for the default |\textus|
% subclass and |\persona|).
%    \begin{macrocode}
  \def \TXN@parameter {#1}%
  \TXN@sw@false
  \ifx \empty \TXN@parameter
    \if t\TXN@entity@code
      \ifnum \TXN@counter = \z@
        \TXN@sw@true
      \fi
    \else
      \if p\TXN@entity@code
        \TXN@sw@true
      \fi
    \fi
    \ifTXN@sw
      \PackageError {TEXNIKA}
        {The attribute cannot be null}
        {}%
    \else
      \TXN@edef {\TXN@entity[\TXN@c]side@recto}{}%
      \TXN@edef {\TXN@entity[\TXN@c]side@verso}{}%
      \TXN@edef {\TXN@entity[\TXN@c]offset@recto}{\z@}%
      \TXN@edef {\TXN@entity[\TXN@c]offset@verso}{\z@}%
      \TXN@edef {\TXN@entity[\TXN@c]flagsLocus@recto}{}%
      \TXN@edef {\TXN@entity[\TXN@c]flagsLocus@verso}{}%
    \fi
  \else
    \TXN@toks@a = {}%  flags
    \let \TXN@save@esc@esc = \\%
    \def \\{\relax}%
    \TXN@setLocus@bis#1\\\\%
    \let \\ = \TXN@save@esc@esc 
  \fi
}
%    \end{macrocode}
% Split the argument into the \textit{recto} and \textit{verso} parts,
% both trimmed of leading and trailing spaces.
%    \begin{macrocode}
\def \TXN@setLocus@bis #1\\#2\\{%
  \def \TXN@folio {recto}%
  \TXN@trim {\noexpand#1}%
  \expandafter \TXN@setLocus@ter \the\TXN@trimmed \TXN@nil
  \def \TXN@folio {verso}%
  \@ifmtarg {#2} {\TXN@sw@false} {\TXN@sw@true}%
  \ifTXN@sw
    \ifTXN@textus@shift
      \PackageError {TEXNIKA}
        {You cannot specify different shift values \MessageBreak 
         for `recto' and `verso'}
        {}%
    \fi
    \global \TXN@lineatingtrue
    \TXN@run@LaTeX@again@reason \TXN@run@LaTeX@again@rectoverso
    \TXN@trim {\noexpand#2}%
  \else
    \TXN@trim {\noexpand#1}%
  \fi
  \expandafter \TXN@setLocus@ter \the\TXN@trimmed \TXN@nil
}
%    \end{macrocode}
% Process one of the parts (\textit{recto} or \textit{verso}).
%    \begin{macrocode}
\def \TXN@setLocus@ter #1#2\TXN@nil{%
%    \end{macrocode}
% We start a group, to keep all \textbf{cs} definitions locals and
% to protect the \textit{calc} innards.
%    \begin{macrocode}
  \begingroup
  \let \leftmargin = \relax
  \let \rightmargin = \relax
  \if n\TXN@entity@code
    \def \rightmargin     {\rightmargin}%
    \def \leftmargin      {\leftmargin}%
    \def \textrightmargin {\textrightmargin}%
    \def \textleftmargin  {\textleftmargin}%
    \def \textrightedge   {\textrightedge}%
    \def \textleftedge    {\textleftedge}%
  \else \if t\TXN@entity@code
    \def \rightmargin     {\rightmargin}%
    \def \leftmargin      {\leftmargin}%
    \ifnum \TXN@counter = \z@
    \else
      \def \textrightmargin {\textrightmargin}%
      \def \textleftmargin  {\textleftmargin}%
      \def \textrightedge   {\textrightedge}%
      \def \textleftedge    {\textleftedge}%
    \fi
    \def \area     {\area}%
    \def \auto     {\auto}%
    \def \Auto     {\Auto}%
    \def \noauto   {\noauto}%
    \def \previous {\previous}%
  \else \if p\TXN@entity@code
    \def \center   {\center}%
    \def \centre   {\centre}%
    \def \left     {\left}%
  \fi\fi\fi
%    \end{macrocode}
%
%    \begin{macrocode}
  \TXN@sw@false
  \ifx +#1\relax
  \else
    \ifx -#1\relax
    \else
      \ifx \@undefined #1\relax
        \PackageError {TEXNIKA}
          {The parameter \string#1 is not valid \MessageBreak
           for this instance of \protect\Locus}
          {}%
      \fi
    \fi
  \fi
  \TXN@sw@false
  \if t\TXN@entity@code
    \ifnum \TXN@counter > \z@
      \TXN@sw@true
    \fi
  \fi
  \toks@ = {#1\TXN@nil#2\TXN@nil}%
  \ifTXN@sw
    \expandafter \TXN@setLocus@check@area
  \else
    \expandafter \TXN@setLocus@quater
  \fi
}
%    \end{macrocode}
%  For a |\textus| subclass (other than the default subclass) we
%  must check for the optional |\area| command.
%
%    \begin{macrocode}
\def \TXN@setLocus@check@area {%
  \expandafter \TXN@setLocus@check@area@bis \the\toks@
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@setLocus@check@area@bis #1\TXN@nil#2\TXN@nil{%
  \ifx \area #1\relax
    \toks@ = {#2\TXN@nil}%
    \edef \TXN@area@options {\TXN@o@AttachedToArea}%        
    \expandafter 
    \TXN@SimpleList \csname TXN@textus[\TXN@c]text\endcsname 
                    \TXN@max@area@ind
    \expandafter \TXN@setLocus@check@area@ter
  \else
%    \end{macrocode}
% Re-join the main path.
%    \begin{macrocode}
    \expandafter \TXN@setLocus@quater 
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@setLocus@check@area@ter {%
  \expandafter \TXN@setLocus@check@area@quater \the\toks@
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@setLocus@check@area@quater #1#2\TXN@nil{%
  \ifx [#1\relax
    \expandafter \TXN@setLocus@check@area@quinqies 
  \else
    \edef \TXN@area@options {\TXN@area@options\TXN@o@AreaMiddle}%   
    \toks@ = {#1#2}%
    \expandafter \TXN@setLocus@check@area@septies 
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@setLocus@check@area@quinqies {%
  \expandafter \TXN@setLocus@check@area@sexies \the\toks@
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@set@area@flag #1{%
  \edef \TXN@area@options {\TXN@area@options#1}%   
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@setLocus@check@area@sexies [#1]#2\TXN@nil{%
  \define@key {area}{top}   [\TXN@o@AreaTop]{\TXN@set@area@flag##1}%   
  \define@key {area}{bottom}[\TXN@o@AreaBottom]{\TXN@set@area@flag##1}%  
  \define@key {area}{middle}[\TXN@o@AreaMiddle]{\TXN@set@area@flag##1}%  
  \define@key {area}{wrap}  [\TXN@o@AreaWrap]{\TXN@set@area@flag##1}%   
  \define@key {area}{extend}[\TXN@o@AreaExtend]{\TXN@set@area@flag##1}%   
  \let \KV@errx = \TXN@keyval@error
  \setkeys {area}{#1}%
  \toks@ = {#2}%
  \TXN@sw@true
  \if \TXN@option \TXN@o@AreaTop \TXN@area@options
    \TXN@sw@false
  \fi
  \if \TXN@option \TXN@o@AreaBottom \TXN@area@options
    \TXN@sw@false
  \fi
  \if \TXN@option \TXN@o@AreaMiddle \TXN@area@options
    \TXN@sw@false
  \fi
  \ifTXN@sw
    \edef \TXN@area@options {\TXN@area@options\TXN@o@AreaMiddle}%  
  \fi
  \TXN@setLocus@check@area@septies 
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@setLocus@check@area@septies {%
%    \end{macrocode}
% The area options apply to both recto and verso
%    \begin{macrocode}
  \edef \TXN@temp {\@nameuse{TXN@textus[\TXN@c]flagsLocus@recto}}%
  \TXN@xdef {TXN@textus[\TXN@c]flagsLocus@recto}%
            {\TXN@temp\TXN@area@options}%
  \edef \TXN@temp {\@nameuse{TXN@textus[\TXN@c]flagsLocus@verso}}%
  \TXN@xdef {TXN@textus[\TXN@c]flagsLocus@verso}%
            {\TXN@temp\TXN@area@options}%
  \expandafter \TXN@setLocus@check@area@octies \the\toks@\TXN@nil
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@setLocus@check@area@octies #1#2\TXN@nil{%
  \toks@ = {#1\TXN@nil#2\TXN@nil}%
  \TXN@setLocus@quater
}
%    \end{macrocode}
% Process the attribute.
%    \begin{macrocode}
\def \TXN@setLocus@quater {%
  \expandafter \TXN@setLocus@quinquies \the\toks@
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@setLocus@quinquies #1#2\TXN@nil#3\TXN@nil{%
  \TXN@skip@a = \z@
  \def \TXN@calc@exp{0pt#2#3}%
  \ifx \rightmargin #1\relax
    \xdef \TXN@sideLocus {\TXN@rightmargin}%
  \else  \ifx \leftmargin #1\relax
    \xdef \TXN@sideLocus {\TXN@leftmargin}%
  \else \ifx \textrightmargin #1\relax
    \xdef \TXN@sideLocus {\TXN@textrightmargin}%
  \else \ifx \textleftmargin #1\relax
    \xdef \TXN@sideLocus {\TXN@textleftmargin}%
  \else \ifx \textrightedge #1\relax
    \xdef \TXN@sideLocus {\TXN@textrightedge}%
  \else \ifx \textleftedge #1\relax
    \xdef \TXN@sideLocus {\TXN@textleftedge}%
  \else \ifx \centre #1\relax
    \xdef \TXN@sideLocus {\TXN@centre}%
  \else \ifx \left #1\relax
    \xdef \TXN@sideLocus {\TXN@left}%
  \fi\fi\fi\fi\fi\fi\fi\fi
%    \end{macrocode}
% Check for special cases.
%    \begin{macrocode}
  \let \next = \TXN@setLocus@calc@offset
  \ifx +#1\relax
    \TXN@toks@a = {#1}%
    \TXN@toks@b = {#2#3}%
    \let \next = \TXN@setLocus@relative
  \else \ifx -#1\relax
    \TXN@toks@a = {#1}%
    \TXN@toks@b = {#2#3}%
    \let \next = \TXN@setLocus@relative
  \else \ifx \TXN@sideLocus \TXN@left 
    \endgroup
    \global \dimen@i = \z@
    \let \next = \TXN@setLocus@finish
  \else \if t\TXN@entity@code
    \ifx \auto #1\relax
      \endgroup
      \def \TXN@temp {a}%
      \TXN@toks@a = {#3}%
      \let \next = \TXN@setLocus@auto
    \else \ifx \Auto #1\relax
      \endgroup
      \def \TXN@temp {m}%
      \TXN@toks@a = {#3}%
      \let \next = \TXN@setLocus@auto
    \else \ifx \noauto #1\relax
      \endgroup
      \let \next = \TXN@setLocus@noauto
    \else \ifx \previous #1\relax
      \endgroup
      \let \next = \TXN@setLocus@previous
    \fi\fi\fi\fi
  \fi\fi\fi\fi
  \next
}
%    \end{macrocode}
% Compute the offset.
%    \begin{macrocode}
\def \TXN@setLocus@calc@offset{%
%    \end{macrocode}
% We are still within the group, so we can change |\TXN@entity|.
%    \begin{macrocode}
  \if n\TXN@entity@code
    \def \TXN@entity {numerus}%
  \else
    \def \TXN@entity {textus}%
  \fi
  \TXN@calc@offset
  \global \advance \dimen@i by \TXN@skip@a
  \endgroup
  \TXN@setLocus@finish
}
%    \end{macrocode}
% The actual call to \textbf{calc}.
%    \begin{macrocode}
\def \TXN@calc@offset {%
%    \end{macrocode}
% Set the appropriate hooks in the \textbf{calc} package and
% compute the expression.
%    \begin{macrocode}
  \expandafter
  \let \csname calc@textsize\expandafter\endcsname
    \csname TXN@\TXN@entity @calc@textsize\endcsname
  \let \offset = \widthof
  \let \WidthOf = \widthof
  \calc@assign@dimen{\global\dimen@i}{\TXN@calc@exp}%
}
%    \end{macrocode}
% Set the |\Locus| variables
%    \begin{macrocode}
\def \TXN@setLocus@finish{%
  \if p\TXN@entity@code
     \edef \DRM@persona@side {\TXN@sideLocus}%
     \edef \DRM@persona@offset {\the\dimen@i}%
  \else
    \ifTXN@textus@shift
      \TXN@edef {\TXN@entity[\TXN@c]shift}{\the\dimen@i}%
      \ifTXN@textus@shift@minus
      \else
        \TXN@xdef {\TXN@entity[\TXN@c]last@shift}{\the\dimen@i}%
      \fi
    \else
      \TXN@edef {\TXN@entity[\TXN@c]side@\TXN@folio}{\TXN@sideLocus}%
      \TXN@edef {\TXN@entity[\TXN@c]offset@\TXN@folio}{\the\dimen@i}%
    \fi
  \fi
}
%    \end{macrocode}
% Processing a relative shift.
% |\TXN@toks@a| holds the sign
% |\TXN@toks@b| holds the rest
%    \begin{macrocode}
\def \TXN@setLocus@relative {%
  \if p\TXN@entity@code
     \PackageError {TEXNIKA}
       {You cannot specify a shift for this \protect\Locus}
       {}%
  \fi
  \xdef \TXN@sideLocus {\@nameuse{\TXN@entity[\TXN@c]side@\TXN@folio}}%
  \ifx \empty \TXN@sideLocus 
    \PackageError {TEXNIKA}
      {The \protect\Locus\space has not been previously defined}
      {}%
  \fi
  \ifnum \TXN@sideLocus < \z@
    \PackageError {TEXNIKA}
      {You cannot specify a shift for this \protect\Locus}
      {}%
  \fi
  \if t\TXN@entity@code
    \ifnum \TXN@counter = \z@
      \global \TXN@textus@shifttrue
    \fi
  \fi
  \edef \TXN@temp {\the\TXN@toks@b}%
  \ifx \empty \TXN@temp 
    \ifTXN@textus@shift
      \TXN@setLocus@textus@shift
    \else
      \PackageError {TEXNIKA}
        {You cannot specify `+' or `-' for this \protect\Locus}
        {}%
    \fi
  \else
    \ifTXN@textus@shift
      \TXN@skip@a = \z@skip
    \else
      \TXN@assign \TXN@skip@a = {\TXN@entity[\TXN@c]offset@\TXN@folio}%
    \fi
  \fi
  \edef \TXN@calc@exp {0pt\the\TXN@toks@a\the\TXN@toks@b}%
  \TXN@setLocus@calc@offset
}
%    \end{macrocode}
% If there is just a sign, we either use the previous shift (+) or
% clear the shift (-).
%    \begin{macrocode}
\def \TXN@setLocus@textus@shift {%
  \edef \TXN@temp {\@nameuse{\TXN@entity[\TXN@c]last@shift}}%
  \ifx \empty \TXN@temp 
    \PackageError {TEXNIKA} 
      {There is no previous shift for this \protect\Locus}
      {}%
  \fi
  \edef \TXN@temp@bis {\the\TXN@toks@a}%
  \if +\TXN@temp@bis
    \expandafter \TXN@toks@b \expandafter{\TXN@temp}%
  \else
    \global \TXN@textus@shift@minustrue
    \TXN@toks@b = {0pt}%
  \fi
  \TXN@skip@a = \z@skip
}
%    \end{macrocode}
% The argument is |\auto|
%    \begin{macrocode}
\def \TXN@check@poetry {%
  \ifTXN@outside@preamble
  \else
    \@ifpackageloaded{poetry}{\TXN@poetrytrue}{}%
  \fi
  \ifTXN@poetry
  \else
    \PackageError {TEXNIKA}
     {\protect\Locus\protect\auto\space requires the `poetry' package}
     {}%
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def  \TXN@setLocus@auto {%
  \TXN@check@poetry 
  \edef \PTR@auto@mode {\TXN@temp}%
  \edef \TXN@temp {\the\TXN@toks@a}%
%    \end{macrocode}
% Check the optional argument
%    \begin{macrocode}
  \ifx \empty \TXN@temp
    \TXN@setLocus@auto@bis \relax \TXN@nil
  \else
    \expandafter \TXN@setLocus@auto@bis \the\TXN@toks@a \TXN@nil
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@setLocus@auto@bis #1#2\TXN@nil{%
  \if *\noexpand#1\relax
    \def \TXN@auto@delta {\z@}%
  \else
    \if [\noexpand#1\relax
      \TXN@setLocus@auto@ter #2\relax
    \else
      \def \TXN@auto@delta {3mm}%
    \fi
  \fi
  \PTR@auto@setup
}
\def  \TXN@setLocus@auto@ter #1]{\def \TXN@auto@delta {#1}}
%    \end{macrocode}
%
%    \begin{macrocode}
\def  \TXN@setLocus@noauto {\TXN@check@poetry\PTR@auto@notrue}
%    \end{macrocode}
%
%    \begin{macrocode}
\def  \TXN@setLocus@previous {%
  \ifTXN@withinVersus
  \else
    \PackageError {TEXNIKA}
      {\protect\Locus\protect\previous\space can be used only \MessageBreak
       within the Versus domain}%
      {}%
  \fi
  \TXN@edef {TXN@textus[\TXN@theTextus]shift}{\PTR@previous@shift}%
}
%    \end{macrocode}
%
% The code replacing |\calc@textsize| for |\Locus\Numerus|.
%
%    \begin{macrocode}
\def \TXN@numerus@calc@textsize #1#2{%
  \def \offset {\offset}%
  \def \WidthOf {\WidthOf}%
  \ifx \offset #1\relax
    \begingroup
      \let \numerus = \TXN@get@offset@numerus
      \let \textus = \TXN@get@offset@textus
      \expandafter{#2}%
      \global \calc@A = \dimen@iii
    \endgroup
  \else
    \ifx \WidthOf #1\relax
      \setbox \z@ =
        \hbox{\csname TXN@textus[\TXN@theTextus]Facies\endcsname#2}%
    \else
      \TXN@process@numerus@argument{#2}%
      \edef\TXN@temp{%
         \TXN@numerus@error
         \TXN@numerus@sign
         \TXN@numerus@set
       }%
      \ifx \empty \TXN@temp 
      \else
        \PackageError {TEXNIKA}
          {Bad prototype \protect\numerus}
          {}%
      \fi
      \setbox \z@ = \hbox{%  
        \@nameuse {TXN@numerus[\TXN@c]Facies}%
          \TXN@numerus@value
          \empty
          \TXN@numerus@separator
          \TXN@numerus@second@value
          \TXN@numerus@head
      }%
    \fi
    \begingroup
      \let\widthof = \wd
      \let\WidthOf = \wd
      \let\heightof = \ht
      \let\depthof = \dp
      \global\calc@A #10\relax
    \endgroup
  \fi
  \calc@post@scan
}
%    \end{macrocode}
%
% The code replacing |\calc@textsize| for |\Locus\Textus| \\
% (and for |\Locus\personae|)
%
%    \begin{macrocode}
\def \TXN@textus@calc@textsize #1#2{%
  \def \offset {\offset}%
  \def \WidthOf {\WidthOf}%
  \ifx \offset #1\relax
    \begingroup
    \let \numerus = \TXN@get@offset@numerus
    \let \textus = \TXN@get@offset@textus
    \expandafter{#2}%
    \global \calc@A = \dimen@iii
    \endgroup
  \else
    \ifx \WidthOf #1\relax
      \setbox \z@ = 
        \hbox {\csname TXN@textus[\TXN@theTextus]Facies\endcsname#2}%
    \else
      \setbox \z@ = \hbox {\csname TXN@textus[\TXN@c]Facies\endcsname {#2}}%
    \fi
    \begingroup
      \let\widthof  = \wd
      \let\WidthOf  = \wd
      \let\heightof = \ht
      \let\depthof  = \dp
      \global\calc@A #10\relax
    \endgroup
  \fi
  \calc@post@scan
}
\let \TXN@persona@calc@textsize = \TXN@textus@calc@textsize
%    \end{macrocode}
%
% The meaning of |\numerus| within \textbf{calc}.
%
%    \begin{macrocode}
\newcommand{\TXN@get@offset@numerus}[1][0]{%
  \TXN@let \TXN@test = {TXN@numerus[#1]side@\TXN@folio}%
  \ifx \empty \TXN@test 
    \PackageError {TEXNIKA}
      {\protect\Locus\protect\numerus[#1] not defined yet}
      {}%
  \fi
  \global \TXN@assign \dimen@iii = {TXN@numerus[#1]offset@\TXN@folio}%
  \ifnum \TXN@test = \TXN@leftmargin \TXN@safe
    \global \advance \dimen@iii by -\TXN@skip@a
  \fi
}
%    \end{macrocode}
%
% The meaning of |\textus| within \textbf{calc}.
%
%    \begin{macrocode}
\newcommand{\TXN@get@offset@textus}[1][0]{%
  \TXN@let \TXN@test = {TXN@textus[#1]side@\TXN@folio}%
  \ifx \TXN@test \relax
    \PackageError {TEXNIKA}
      {\protect\Locus\protect\textus[#1] not defined yet}
      {}%
  \fi
  \global \TXN@assign \dimen@iii = {TXN@textus[#1]offset@\TXN@folio}%
  \ifnum  \TXN@test = \TXN@leftmargin \relax
    \global \advance \dimen@iii by -\TXN@skip@a
  \fi
}
%    \end{macrocode}
% Set |\dimen@| equal to the displacement from the |\textleftmargin|
%    |#1|\  textus/numerus[n]
%    |#2|\  the object type ('t' = textus, anything else = numerus)
%    \begin{macrocode}
\def \TXN@get@Locus #1#2{%
  \if \TXN@empty {TXN@#1side@\TXN@theFolio}%
    \dimen@ = \maxdimen
  \else
    \TXN@sw@false
    \ifx t#2\relax
      \edef \TXN@temp {\@nameuse{TXN@#1flagsLocus@\TXN@theFolio}}%
      \if \TXN@option \TXN@o@AttachedToArea \TXN@temp
        \TXN@sw@true
      \fi
    \fi
    \TXN@assign \@tempcnta = {TXN@#1side@\TXN@theFolio}%
    \TXN@assign \dimen@    = {TXN@#1offset@\TXN@theFolio}%
    \TXN@assign \dimen@@   = {TXN@textus[\TXN@theTextus]offset@\TXN@theFolio}%
%    \end{macrocode}
%
%    \begin{macrocode}
    \ifcase \@tempcnta
      \advance \dimen@ by \linewidth         % right margin
    \or                                      % left margin
      \relax
    \or                                      % text right margin
      \advance \dimen@ by \TXN@measure       
      \advance \dimen@ by \dimen@@
    \or                                      % text left margin
      \advance \dimen@ by \dimen@@           
      \TXN@assign \dimen@@ = {TXN@textus[\TXN@theTextus]shift}%
      \advance \dimen@ by \dimen@@           
    \or                                      % text right edge
      \ifTXN@sw                              
        \advance \dimen@ by \dimen@@
        \TXN@assign \dimen@@ = {TXN@area[\TXN@area@ind]rightedge}%
        \advance \dimen@ by \dimen@@
      \else
        \TXN@assign \dimen@@ = {TXN@textus[\TXN@theTextus]shift}%
        \advance \dimen@ by \dimen@@ 
        \ifx \empty \TXN@line@length 
          \ifTXN@withinVersus                      
             \gdef \TXN@line@length {\the\wd\PTR@box@full@line}%
          \else
             \gdef \TXN@line@length {\the\TXN@measure}%
          \fi
        \fi
        \advance \dimen@ by \TXN@line@length \TXN@safe
      \fi
    \or                                      % text left edge
      \ifTXN@sw
        \TXN@assign \dimen@ = {TXN@area[\TXN@area@ind]leftedge}%
      \else
        \advance \dimen@ by \dimen@@ 
        \TXN@assign \dimen@@ = {TXN@textus[\TXN@theTextus]shift}%
        \advance \dimen@ by \dimen@@ 
        \advance \dimen@ by \TXN@leading@space \TXN@safe 
      \fi
    \fi
  \fi
}
%    \end{macrocode}
% \subsection{Setting the \TXN@cmd{Forma} attribute}
% \subsubsection{Setting \TXN@cmd{Forma} for \TXN@cmd{textus} 
% \textit{(currently unused)}}
%    \begin{macrocode}
\newcommand{\TXN@setForma@textus}[2][0]{%
  \TXN@counter = #1\relax
  \let \TXN@save@esc@esc = \\%
  \def \\{\relax}%
  \TXN@setForma@textus@bis#2\\\\%
  \let \\ = \TXN@save@esc@esc 
}
\def \TXN@setForma@textus@bis #1\\#2\\{%
  \def \TXN@folio {recto}%
  \TXN@trim{\noexpand#1}%
  \expandafter
  \TXN@setForma@textus@ter \expandafter {\the\TXN@trimmed}%
  \def \TXN@folio {verso}%
  \@ifmtarg {#2} {} {\TXN@trim{\noexpand#2}}%
  \expandafter
  \TXN@setForma@textus@ter \expandafter {\the\TXN@trimmed}%
}
\def \TXN@setForma@textus@ter #1{%
  \TXN@sw@false
  \if \TXN@empty {TXN@textus[\TXN@c]Forma@\TXN@folio}%
  \else
    \ifTXN@attribute@starred
      \TXN@sw@true
    \fi
  \fi
  \ifTXN@sw
    \TXN@let \TXN@temp = {TXN@textus[\TXN@c]Forma@\TXN@folio}%
    \toks@ = \expandafter {\TXN@temp #1}%
    \TXN@edef {TXN@textus[\TXN@c]Forma@\TXN@folio}{\the\toks@}%
  \else
    \TXN@def {TXN@textus[\TXN@c]Forma@\TXN@folio}{%
      \global \noexpand \TXN@centrefinalfalse #1\relax}%
  \fi
}
%    \end{macrocode}
% \subsubsection{Setting \TXN@cmd{Forma} for \TXN@cmd{titulus}}
%    \begin{macrocode}
\newcommand{\TXN@setForma@titulus}[2][0]{%
  \TXN@sw@false
  \if \TXN@empty {TXN@titulus[#1]Forma}%
  \else
    \ifTXN@attribute@starred
      \TXN@sw@true
    \fi
  \fi
  \ifTXN@sw
    \TXN@let \TXN@temp = {TXN@titulus[#1]Forma}%
    \toks@ = \expandafter {\TXN@temp #2}%
    \TXN@edef {TXN@titulus[#1]Forma}{\the\toks@}%
  \else
    \TXN@def {TXN@titulus[#1]Forma}{#2\relax}%
  \fi
}
%    \end{macrocode}
% \subsection{Setting the \TXN@cmd{Modus} attribute}
%
% \subsubsection{Setting \TXN@cmd{Modus} for \TXN@cmd{textus}}
%    \begin{macrocode}
\newcommand{\TXN@setModus@textus}[2][0]{%
  \TXN@counter = #1\relax
  \def \TXN@entity@code {t}%
  \TXN@setModus{#2}%
}
%    \end{macrocode}
% \subsubsection{Setting \TXN@cmd{Modus} for \TXN@cmd{numerus}}
%    \begin{macrocode}
\newcommand{\TXN@setModus@numerus}[2][0]{%
  \TXN@counter = #1\relax
  \def \TXN@entity@code {n}%
  \TXN@setModus{#2}%
}
%    \end{macrocode}
% \subsubsection{Setting \TXN@cmd{Modus} for \TXN@cmd{titulus}}
%    \begin{macrocode}
\newcommand{\TXN@setModus@titulus}[2][0]{%
  \TXN@counter = #1\relax
  \def \TXN@entity@code {T}%
  \TXN@setModus{#2}%
}
%    \end{macrocode}
% \subsubsection{Setting \TXN@cmd{Modus} for \TXN@cmd{Delimiter}}
%    \begin{macrocode}
\def \TXN@ModusDelimiter {}%
\def \TXN@setModus@Delimiter #1{%
  \def \TXN@ModusDelimiter {#1}%
}
%    \end{macrocode}
% \subsubsection{Processing the \TXN@cmd{Modus} options} 
%
%    \begin{macrocode}
\def \TXN@setModus #1{%
  \let \TXN@save@esc@esc = \\%
  \def \\{\relax}%
  \TXN@setModus@bis#1\\\\%
  \let \\ = \TXN@save@esc@esc 
}
%    \end{macrocode}
% Split the argument into the \textit{recto} and \textit{verso} parts,
% both trimmed of leading and trailing spaces.
%    \begin{macrocode}
\def \TXN@setModus@bis #1\\#2\\{%
  \def \TXN@folio {recto}%
  \TXN@trim{\noexpand#1}%
  \expandafter \TXN@setModus@ter \the\TXN@trimmed\TXN@nil
  \def \TXN@folio {verso}%
  \@ifmtarg {#2} {} {\TXN@trim{\noexpand#2}}%
  \expandafter \TXN@setModus@ter \the\TXN@trimmed\TXN@nil
}
%    \end{macrocode}
% Process one of the parts (\textit{recto} or \textit{verso}).
%    \begin{macrocode}
\def \TXN@setModus@ter #1\TXN@nil{%
%    \end{macrocode}
% Note that |\TXN@entity@code| may also have the value `p' (for \texttt{persona})
%    \begin{macrocode}
  \if n\TXN@entity@code
    \def \TXN@entity {TXN@numerus}%
  \else \if t\TXN@entity@code
    \def \TXN@entity {TXN@textus}%
  \else \if T\TXN@entity@code
    \def \TXN@entity {TXN@titulus}%
  \fi\fi\fi
%    \end{macrocode}
% We start a group, to keep all \textbf{cs} definitions locals 
%    \begin{macrocode}
  \begingroup
    \if T\TXN@entity@code
    \else
      \def \aligned       {\TXN@setModus@aligned}%
      \def \centred       {\edef \TXN@temp {%
                             \TXN@o@RangedLeft\TXN@o@RangedRight}%
                           \toks@ = \expandafter{\TXN@temp}\TXN@setModus@ranged}%
      \def \rangedleft    {\toks@ = \expandafter {\TXN@o@RangedLeft}%
                           \TXN@setModus@ranged}%
      \def \rangedright   {\toks@ = \expandafter {\TXN@o@RangedRight}%
                           \TXN@setModus@ranged}%
      \def \justified     {\toks@ = \expandafter {\TXN@o@Justified}%
                           \TXN@setModus@justified}%
      \def \milestone     {\TXN@setModus@milestone}%
      \let \centered = \centred
    \fi
    \if n\TXN@entity@code
       \let \pagewise = \TXN@setModus@pagewise
    \fi
    \if t\TXN@entity@code
      \let \hyphenless   = \TXN@setModus@nohyphens
      \let \unhyphenated = \TXN@setModus@nohyphens
      \let \multiple     = \TXN@setModus@multiples
      \let \multiples    = \TXN@setModus@multiples
      \let \measure      = \TXN@setModus@measure
      \ifTXN@withinIndexes
        \let \leaders      = \TXN@setModus@leaders
      \fi
    \fi
    \if T\TXN@entity@code
      \let \hyphenless   = \TXN@setModus@nohyphens
      \let \unhyphenated = \TXN@setModus@nohyphens
    \fi
%    \end{macrocode}
%
%    \begin{macrocode}
    \TXN@toks@a = {}%
    \TXN@toks@c = {}%
    \gdef \TXN@Modus@measure@set {}%
    \gdef \TXN@Modus@leaders@set {}%
    \gdef \TXN@Modus@classes@set {}%
    #1\relax
    \global \toks@i = \TXN@toks@a
    \global \toks@iii = \TXN@toks@c
  \endgroup
  \TXN@toks@a = \toks@i
  \TXN@toks@c = \toks@iii
  \if p\TXN@entity@code
     \edef \DRM@persona@flags {\the\TXN@toks@a}%
     \edef \DRM@persona@field {\the\TXN@toks@c}%
  \else
    \ifTXN@attribute@starred
      \edef \TXN@temp {\@nameuse{\TXN@entity[\TXN@c]flagsModus@\TXN@folio}}%
    \else
      \edef \TXN@temp {}%
    \fi
    \if T\TXN@entity@code
      \TXN@edef {\TXN@entity[\TXN@c]flagsModus}{\TXN@temp\the\TXN@toks@a}%
    \else
      \TXN@edef {\TXN@entity[\TXN@c]flagsModus@\TXN@folio}%
              {\TXN@temp\the\TXN@toks@a}%
      \TXN@edef {\TXN@entity[\TXN@c]field@\TXN@folio}{\the\TXN@toks@c}%
    \fi
  \fi
  \ifx  \empty \TXN@Modus@measure@set 
  \else
    \ifx \TXN@folio \TXN@recto
      \TXN@edef {\TXN@entity[\TXN@c]measure}{\TXN@Modus@measure@set}%
      \TXN@measure = \TXN@Modus@measure@set \TXN@safe
    \fi
  \fi
  \ifx  \empty \TXN@Modus@leaders@set 
  \else
    \TXN@edef {\TXN@entity[\TXN@c]leaders@\TXN@folio}%
      {\TXN@Modus@leaders@set}%
  \fi
  \ifx  \empty \TXN@Modus@classes@set 
  \else
    \TXN@edef {\TXN@entity[\TXN@c]classes@\TXN@folio}{\TXN@Modus@classes@set}%
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@setModus@flag #1{%
  \edef \TXN@temp {\the\TXN@toks@a#1}%
  \TXN@toks@a = \expandafter{\TXN@temp}%
}
%    \end{macrocode}
% \paragraph{\TXN@cmd{aligned}}
%    \begin{macrocode}
\def \TXN@setModus@aligned #1{%
  \define@key {aligned}{left}  [\TXN@o@AlignedLeft]{\TXN@setModus@flag##1}%  
  \define@key {aligned}{right} [\TXN@o@AlignedRight]{\TXN@setModus@flag##1}% 
  \define@key {aligned}{centre}[\TXN@o@AlignedCentre]{\TXN@setModus@flag{##1}}% 
  \if t\TXN@entity@code
    \define@key {aligned}{top}   [\TXN@o@AlignedTop]{\TXN@setModus@flag##1}% 
    \define@key {aligned}{bottom}[\TXN@o@AlignedBottom]{\TXN@setModus@flag##1}% 
    \define@key {aligned}{middle}[\TXN@o@AlignedMiddle]{\TXN@setModus@flag##1}% 
    \define@key {aligned}{axis}  [\TXN@o@AlignedAxis]{\TXN@setModus@flag##1}% 
  \fi
  \if n\TXN@entity@code
    \define@key {aligned}{tail}[\TXN@o@AlignedTail]{\TXN@setModus@flag##1}% 
  \fi
  \setkeys {aligned}{#1}%
}
%    \end{macrocode}
% \paragraph{\TXN@cmd{justified}}
%    \begin{macrocode}
\def \TXN@setModus@justified {%
  \if t\TXN@entity@code
    \ifnum \TXN@counter = \TXN@e \TXN@safe
      \TXN@exxxpandafter \TXN@setModus@justified@excessus
    \else
      \TXN@exxxpandafter \TXN@setModus@justified@bis
    \fi
  \else
    \expandafter \TXN@setModus@justified@bis
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@setModus@justified@bis #1{%
  \TXN@toks@c = {#1}%
  \TXN@setModus@auto@field@width #1\TXN@nil
  \edef \TXN@temp {\the\TXN@toks@a\the\toks@}%
  \TXN@toks@a = \expandafter {\TXN@temp}%
}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand {\TXN@setModus@justified@excessus}[1][200]{%
      \TXN@toks@c = {#1}%
      \edef \TXN@temp {\the\TXN@toks@a\the\toks@}%
      \TXN@toks@a = \expandafter {\TXN@temp}%
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@setModus@auto@field@width #1#2\TXN@nil{%
  \@tempswafalse
  \ifx +#1\relax
    \@tempswatrue
  \else
    \ifx -#1\relax
      \@tempswatrue
    \fi
  \fi
  \if@tempswa
    \edef \TXN@temp {\the\TXN@toks@a\TXN@o@FieldAutoWidth}% 
    \TXN@toks@a = \expandafter {\TXN@temp}% 
  \fi
}
%    \end{macrocode}
% \paragraph{\TXN@cmd{measure}}
%    \begin{macrocode}
\def \TXN@setModus@measure #1{%
  \begingroup
    \TXN@sw@false
    \TXN@setModus@measure@bis #1\TXN@nil
    \setlength {\TXN@dim@a} {\ifTXN@sw \TXN@measure\fi #1}%
    \xdef \TXN@Modus@measure@set {\the\TXN@dim@a}%
  \endgroup
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@setModus@measure@bis #1#2\TXN@nil{%
  \ifx +#1\relax
    \TXN@sw@true
  \else
    \ifx -#1\relax
      \TXN@sw@true
    \fi
  \fi
}
%    \end{macrocode}
% \paragraph{\TXN@cmd{milestone}}
%    \begin{macrocode}
\def \TXN@setModus@milestone {%
  \TXN@gdef {\TXN@entity[\TXN@c]milestone}{1}%
  \global \TXN@milestonestrue
}
%    \end{macrocode}
% \paragraph{\TXN@cmd{multiples}}
%    \begin{macrocode}
\def \TXN@setModus@multiples {%
  \edef \TXN@temp {\the\TXN@toks@a \TXN@o@Multiples}%  
  \TXN@toks@a = \expandafter {\TXN@temp}%  
}
%    \end{macrocode}
% \paragraph{\TXN@cmd{leaders}}
%    \begin{macrocode}
\newcommand {\TXN@setModus@leaders} [1][.05\linewidth]{%
  \gdef \TXN@Modus@leaders@set {#1}%
  \edef \TXN@temp {\the\TXN@toks@a \TXN@o@Leaders}%  
  \TXN@toks@a = \expandafter {\TXN@temp}%  
}
%    \end{macrocode}
% \paragraph{\TXN@cmd{nohyphens}}
%    \begin{macrocode}
\def \TXN@setModus@nohyphens {%
  \edef \TXN@temp {\the\TXN@toks@a\TXN@o@Unhyphenated}%   
  \TXN@toks@a = \expandafter {\TXN@temp}%   
}
%    \end{macrocode}
% \paragraph{\TXN@cmd{pagewise}}
%    \begin{macrocode}
\def \TXN@setModus@pagewise {%
  \edef \TXN@temp {\the\TXN@toks@a \TXN@o@Pagewise}%  
  \global \TXN@lineatingtrue
  \TXN@run@LaTeX@again@reason \TXN@run@LaTeX@again@pagewise
  \TXN@toks@a = \expandafter {\TXN@temp}%  
}
%    \end{macrocode}
% \paragraph{\TXN@cmd{ranged}}
%    \begin{macrocode}
\def \TXN@setModus@ranged #1{%
  \TXN@toks@c = {#1}%
  \TXN@setModus@auto@field@width #1\TXN@nil
  \edef \TXN@temp {\the\TXN@toks@a\the\toks@}%
  \TXN@toks@a = \expandafter {\TXN@temp}%
} 
%    \end{macrocode}
% \paragraph{\TXN@cmd{classes} \textit{(currently unused)}}
%    \begin{macrocode}
\def \TXN@setModus@classes #1{%
  \def \TXN@parameter {#1}%
  \begingroup
  \ifx \empty \TXN@parameter
    \toks@ = {Z}%
  \else
    \def \TXN@temp {all}%
    \ifx \TXN@temp \TXN@parameter
      \toks@ = {tTp([}%
    \else
      \toks@ = {}%
      \def \textus {\textus}%
      \def \titulus {\titulus}%
      \def \persona {\persona}%
      \def \({\(}%
      \def \[{\[}%
      \TXN@setModus@classes@bis #1\TXN@nil
    \fi
  \fi
  \xdef \TXN@Modus@classes@set {\the\toks@}%
  \endgroup
  \edef \TXN@numbered@classes {\TXN@numbered@classes\the\toks@}%
}
\def \TXN@setModus@classes@bis #1{%
  \ifx \TXN@nil #1\relax
  \else
    \ifx \textus #1\relax
      \toks@ = \expandafter {\the\toks@ t}%
    \else \ifx \titulus #1\relax
      \toks@ = \expandafter {\the\toks@ T}%
    \else \ifx \persona #1\relax
      \toks@ = \expandafter {\the\toks@ p}%
    \else \ifx \(#1\relax
      \toks@ = \expandafter {\the\toks@ (}%
    \else \ifx \[#1\relax
      \toks@ = \expandafter {\the\toks@ [}%
    \else
      \PackageError {TEXNIKA}
        {Invalid class name: \protect#1} 
        {}%
    \fi\fi\fi\fi\fi
    \expandafter \TXN@setModus@classes@bis
  \fi
}
%    \end{macrocode}
% \subsection{Setting \TXN@cmd{Spatium} attributes}
% \subsubsection{Setting \TXN@cmd{Spatium} attributes for \TXN@cmd{numerus}}
%    \begin{macrocode}
\newcommand{\TXN@setSpatiumAnte@numerus}[2][\z@]{%
  \TXN@build@spatium@horizontal {#2}%
  \toks@ = \expandafter {\TXN@temp}%
  \TXN@edef {TXN@numerus[#1]SpatiumAnte}{\the\toks@}%
}
%    \end{macrocode}
% \subsubsection{Setting \TXN@cmd{Spatium} attributes for \TXN@cmd{titulus}}
%    \begin{macrocode}
\newcommand{\TXN@setSpatiumSupra@titulus}[2][\z@]{%
  \ifTXN@withinVersus
    \TXN@normalCR  
  \fi
  \TXN@build@spatium@list {#2}%
  \ifTXN@withinVersus
    \TXN@activeCR  
  \fi
  \TXN@edef {TXN@titulus[#1]SpatiumSupra}{\TXN@L@spatium}%
}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand{\TXN@setSpatiumInfra@titulus}[2][\z@]{%
  \TXN@build@spatium@list {#2}%
  \TXN@edef {TXN@titulus[#1]SpatiumInfra}{\TXN@L@spatium}%
}
%    \end{macrocode}
% \subsubsection{Setting \TXN@cmd{Spatium} attributes for%
% \TXN@cmd{\protect\bslash}}
%
%    \begin{macrocode}
\def \TXN@setSpatiumInfra@esc@esc #1{%
  \def \TXN@SpatiumInfraEscEsc {#1}%
}
\newif \ifTXN@SpatiumEscEsc@noauto
\def \TXN@setSpatiumPost@esc@esc #1{%
  \def \TXN@parameter {#1}%
  \ifx \empty \TXN@parameter
    \TXN@SpatiumEscEsc@noautotrue
  \else
    \TXN@build@spatium@horizontal {#1}%
    \toks@ = \expandafter {\TXN@temp}%
    \edef \TXN@SpatiumPostEscEsc {\the\toks@}%
  \fi
}
%    \end{macrocode}
% \subsubsection{Setting \TXN@cmd{Spatium} attributes for \TXN@cmd{Delimiter}}
%
%    \begin{macrocode}
\def \TXN@SpatiumAnteDelimiter {\hskip \z@skip}%
\def \TXN@setSpatiumAnte@Delimiter #1{%
  \TXN@build@spatium@horizontal {#1}%
  \toks@ = \expandafter {\TXN@temp}%
  \edef \TXN@SpatiumAnteDelimiter {\the\toks@}%
}
\def \TXN@SpatiumPostDelimiter {\hskip \z@skip}%
\def \TXN@setSpatiumPost@Delimiter #1{%
  \TXN@build@spatium@horizontal {#1}%
  \toks@ = \expandafter {\TXN@temp}%
  \edef \TXN@SpatiumPostDelimiter {\the\toks@}%
}
%    \end{macrocode}
% \subsection{Setting the \TXN@cmd{Caput} attribute}
% \subsubsection{Setting \TXN@cmd{Caput} for \TXN@cmd{numerus}}
%    \begin{macrocode}
\newcommand{\TXN@setCaput@numerus}[2][0]{%
%<debug>  \TXN@trace \TXN@setCaput@numerus
  \def \TXN@parameter {#2}%
  \ifx \empty \TXN@parameter
    \TXN@edef {TXN@numerus[#1]Caput}{}%
  \else
    \TXN@counter = #1\relax
    \def \TXN@entity {numerus}%
    \TXN@setCaput #2\TXN@nil
  \fi
}
%    \end{macrocode}
% \subsubsection{Setting \TXN@cmd{Caput} for \TXN@cmd{textus}}
%    \begin{macrocode}
\newcommand{\TXN@setCaput@textus}[2][0]{%
%<debug>  \TXN@trace \TXN@setCaput@textus
  \def \TXN@parameter {#2}%
  \ifx \empty \TXN@parameter
    \TXN@edef {TXN@textus[#1]Caput}{}%
  \else
    \TXN@counter = #1\relax
    \def \TXN@entity {textus}%
    \TXN@setCaput #2\TXN@nil
  \fi
}
%    \end{macrocode}
% \subsubsection{Setting \TXN@cmd{Caput} for \TXN@cmd{titulus}}
%    \begin{macrocode}
\newcommand{\TXN@setCaput@titulus}[2][0]{%
%<debug>  \TXN@trace \TXN@setCaput@titulus
  \def \TXN@parameter {#2}%
  \ifx \empty \TXN@parameter
    \TXN@edef {TXN@titulus[#1]Caput}{}%
  \else
    \TXN@counter = #1\relax
    \def \TXN@entity {titulus}%
    \TXN@setCaput #2\TXN@nil
  \fi
}
%    \end{macrocode}
% \subsubsection{The common code for \TXN@cmd{Caput}}
%    \begin{macrocode}
\newif \ifTXN@caput@index@only
\long \def \TXN@setCaput #1#2\TXN@nil{%
%<debug>  \TXN@trace \TXN@setCaput
  \toks@ = {}%
  \TXN@caput@index@onlyfalse
  \def \indexes {\indexes}%
  \ifx \indexes #1\relax
    \toks@ = {\indexes}%
    \TXN@caput@index@onlytrue
  \else
    \if \TXN@x {c@\expandafter\@gobble\string#1}\relax
      \PackageError {TEXNIKA}
        {\protect#1\space is not a valid section name}
        {}%
    \fi
  \fi
  \expandafter
  \TXN@setCaput@contents@headline@index \expandafter {\the\toks@#2}%
  \ifTXN@caput@index@only
    \TXN@edef {TXN@\TXN@entity[\TXN@c]Caput}{indexonly}%
    \TXN@sw@false
    \edef \TXN@temp {\the\toks@i}%
    \ifx \empty \TXN@temp \else \TXN@sw@true \fi
    \edef \TXN@temp {\the\toks@iii}%
    \ifx \empty \TXN@temp  \else \TXN@sw@true \fi
    \ifTXN@sw
      \PackageError {TEXNIKA}
        {Extraneous information in \protect\Caput\space argument}
        {If the first token is \protect\indexes\space you cannot
         specify \protect\headline\space or \protect\contents}%
    \fi
    \global \toks@i = {}%
    \global \toks@iii = {}%
  \else
    \TXN@edef {TXN@\TXN@entity[\TXN@c]Caput}{\expandafter\@gobble\string#1}%
  \fi
  \TXN@edef {TXN@\TXN@entity[\TXN@c]Caput@contents}{\the\toks@i}%
  \TXN@edef {TXN@\TXN@entity[\TXN@c]Caput@headline}{\the\toks@iii}%
%    \end{macrocode}
%
%    \begin{macrocode}
  \edef \TXN@temp {\the\toks@v}%
  \ifx \empty \TXN@temp
    \global \toks@v = {\relax}%
    \gdef \TXN@index@type {}%
  \fi
  \TXN@edef {TXN@\TXN@entity[\TXN@c]Caput@index}{\the\toks@v}%
  \TXN@edef {TXN@\TXN@entity[\TXN@c]Caput@index@type}{\TXN@index@type}%
}
%    \end{macrocode}
% \paragraph{\TXN@cmd{contents} \TXN@cmd{headline} \TXN@cmd{index}}
%    \begin{macrocode}
\def \TXN@setCaput@contents@headline@index #1{%
%<debug>  \TXN@trace \TXN@setCaput@contents@headline@index
  \global \toks@i = {}%
  \global \toks@iii = {}%
  \global \toks@v = {}%
  \setbox \z@ = \hbox {%
    \let \contents = \TXN@setCaput@contents
    \let \headline = \TXN@setCaput@headline
    \let \indexes =  \TXN@setCaput@index
    #1}%
  \ifdim \wd\z@ = \z@
  \else
    \ifTXN@caput@index@only
    \else
      \PackageError {TEXNIKA}
        {Bad \protect\Caput\space attribute}
        {You may have forgotten the escape 
         character in the section name}%
    \fi
  \fi
  \ifTXN@caput@index@only
  \else
    \edef \TXN@temp {\the\toks@i}%
    \ifx \empty \TXN@temp
      \edef \TXN@temp {\the\toks@iii}%
      \ifx \empty \TXN@temp
        \global \toks@i = {\relax}%
        \global \toks@iii = {\relax}%
      \fi
    \fi
  \fi
}
%    \end{macrocode}
% \paragraph{\TXN@cmd{contents}}
%    \begin{macrocode}
\def \TXN@setCaput@contents {%
%<debug>  \TXN@trace \TXN@setCaput@contents
  \global \toks@i = {\relax}%
  \futurenonspacelet \TXN@token \TXN@setCaput@contents@bis 
}
\def \TXN@setCaput@contents@bis {%
  \ifx \TXN@token \bgroup 
    \expandafter \TXN@setCaput@contents@ter
  \fi
}
\def \TXN@setCaput@contents@ter #1{%
  \global \toks@i = {#1}%
  \ignorespaces
}
%    \end{macrocode}
% \paragraph{\TXN@cmd{headline}}
%    \begin{macrocode}
\def \TXN@setCaput@headline {%
%<debug>  \TXN@trace \TXN@setCaput@headline
  \global \toks@iii = {\relax}%
  \futurenonspacelet \TXN@token \TXN@setCaput@headline@bis 
}
\def \TXN@setCaput@headline@bis {%
  \ifx \TXN@token \bgroup 
    \expandafter \TXN@setCaput@headline@ter
  \fi
}
\def \TXN@setCaput@headline@ter #1{%
  \global \toks@iii = {#1}%
  \ignorespaces
}
%    \end{macrocode}
% \paragraph{\TXN@cmd{index}}
%    \begin{macrocode}
\def \TXN@setCaput@index {%
%<debug>  \TXN@trace \TXN@setCaput@index
  \gdef \TXN@index@type {t}%
  \global \toks@v = {\relax}%
  \futurenonspacelet \TXN@token \TXN@setCaput@index@bis 
}
\def \TXN@setCaput@index@bis {%
  \ifx [\TXN@token  
    \expandafter \TXN@setCaput@index@quater
  \else
    \ifx \TXN@token \bgroup 
      \TXN@exxxpandafter \TXN@setCaput@index@ter
    \fi
  \fi
}
\def \TXN@setCaput@index@ter #1{%
  \global \toks@v = {#1}%
  \ignorespaces
}
\def \TXN@setCaput@index@quater [#1]{%
  \ifcat a#1\relax
  \else
    \PackageError {TEXNIKA}
      {The optional parameter of \protect\indexes\space must be a letter}
      {}%
  \fi
  \gdef \TXN@index@type {#1}%
  \futurenonspacelet \TXN@token \TXN@setCaput@index@quinquies 
}
\def \TXN@setCaput@index@quinquies{%
  \ifx \TXN@token \bgroup 
    \expandafter \TXN@setCaput@index@ter
  \fi
}
%    \end{macrocode}
%  \section{The \TXN@cmd{textus} class}
%  \subsection{Processing the command}
%    \begin{macrocode}
\def \TXN@e {-1}
\newif \ifTXN@textus@star
\newcommand {\textus} {%
  \ifx \empty \TXN@attribute@name 
    \expandafter \TXN@Textus
  \else
    \def \TXN@subclass@name {textus}%
    \def \TXN@subclass@number {x}%
    \def \TXN@temp {TXN}%
    \expandafter \TXN@attribute@set
  \fi
}
\def \TXN@Textus {%
  \@ifstar {\TXN@textus@startrue\TXN@getTextus}
           {\TXN@textus@starfalse\TXN@getTextus}%
}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand{\TXN@getTextus}[1][0] {%
%<debug>  \TXN@trace \TXN@getTextus
  \TXN@get@textus@flags {#1}%
  \TXN@counter = #1\relax
  \ifTXN@textus@star
    \ifTXN@withinProsa 
      \ifnum #1 = \z@
      \else
        \TXN@milestonestrue
      \fi
    \fi
  \fi
  \TXN@get \TXN@textus@subclasses.\TXN@counter \TXN@temp 
%    \end{macrocode}
% The class name (having been obtained by |\string|, consists of
% characters of category `other', so we must do the comparison in
% this roundabout way.
%    \begin{macrocode}
  \count@ = \escapechar   \escapechar = \m@ne
  \edef \TXN@temp@bis {\expandafter\string\csname\@currenvir\endcsname}%
  \escapechar = \count@ 
  \ifx \TXN@temp \TXN@temp@bis
  \else
    \expandafter \TXN@getTextus@normal
  \fi
}
%    \end{macrocode}
%  \subsection{Processing normal \TXN@cmd{textus}}
%    \begin{macrocode}
\def \TXN@getTextus@normal {%
  \futurelet \TXN@token \TXN@getTextus@bis
}
\def \TXN@getTextus@bis {%
  \ifx *\TXN@token
    \expandafter \TXN@getTextus@double@star
  \else
    \expandafter \TXN@getTextus@ter
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@getTextus@double@star #1{%
%<debug>  \TXN@trace \TXN@getTextus@double@star
  \TXN@sw@true
  \ifTXN@withinProsa
    \if \TXN@num {TXN@textus[\TXN@c]milestone} = \@ne  
      \ifnum \TXN@pass = \@ne
        \TXN@sw@false
        \TXN@toks@a = {\textus*[}%
        \TXN@toks@b = \expandafter{\the\TXN@counter]*}%
        \edef \TXN@temp {\toks@={\the\TXN@toks@a\the\TXN@toks@b}}\TXN@temp
        \TXN@save@command
      \fi
    \fi
  \fi
  \ifTXN@sw
    \TXN@gdef {TXN@textus[\TXN@c]star}{}%
    \TXN@set@textus@text {\TXN@c}{}%
  \fi
  \ignorespaces
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@getTextus@ter {%
%<debug>  \TXN@trace \TXN@getTextus@ter
  \ifTXN@textus@star
    \TXN@sw@true
    \if \TXN@num {TXN@textus[\TXN@c]milestone} = \@ne  
      \ifTXN@withinProsa
        \TXN@sw@false
        \ifnum \TXN@pass = \tw@
          \ifTXN@replay
            \TXN@sw@true
          \fi
        \fi
      \fi
    \fi
    \ifTXN@sw
      \TXN@gdef {TXN@textus[\TXN@c]star}{*}%
    \fi
  \fi
  \if \TXN@option \TXN@o@Multiples \TXN@textus@flags
    \expandafter \TXN@getTextus@multiples
  \else
    \if \TXN@option \TXN@o@NoArgument \TXN@textus@flags
      \TXN@exxxpandafter \TXN@getTextus@quater
    \else
      \ifTXN@withinVersus
        \everypar = {}\TXN@normalCR
      \fi
      \TXN@exxxpandafter \TXN@getTextus@quinquies
    \fi
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@getTextus@quater {%
%<debug> \TXN@trace \TXN@getTextus@quater
  \if \TXN@option \TXN@o@NoFacies \TXN@textus@flags
     \expandafter \TXN@getTextus@nofacies
  \else
     \expandafter \TXN@getTextus@noargument
  \fi
}
\def \TXN@getTextus@nofacies #1{}
\def \TXN@getTextus@noargument {%
  \TXN@getTextus@quinquies \relax
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@getTextus@quinquies #1{%
%<debug> \TXN@trace \TXN@getTextus@quinquies
  \let \next = \TXN@getTextus@sexies
  \ifTXN@withinProsa
    \if \TXN@num {TXN@textus[\TXN@c]milestone} = \@ne 
    \else
      \if \TXN@option \TXN@o@AttachedToArea \TXN@textus@flags
        \TXN@gdef {TXN@textus[\TXN@c]milestone}{1}%
        \TXN@milestonestrue
        \TXN@initialize@milestones 
      \fi
    \fi
    \if \TXN@num {TXN@textus[\TXN@c]milestone} = \@ne 
      \ifnum \TXN@pass = \@ne
        \let \next = \TXN@getTextus@septies
      \fi
      \ifnum \TXN@pass = \tw@
        \ifTXN@replay
        \else
          \let \next = \TXN@getTextus@septies
        \fi
      \fi
    \fi
  \fi
  \next {#1}%
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@getTextus@sexies #1{%
%<debug> \TXN@trace \TXN@getTextus@sexies
  \TXN@set@textus@text {\TXN@c}{#1}%
  \if \TXN@empty {TXN@textus[\TXN@c]side@\TXN@theFolio}%
    \leavevmode
    \def \TXN@textus@text {}%
    \TXN@make@object@textus {\TXN@c}%
    \ifTXN@textus@zero@width
       \setbox \TXN@object@textus = \hbox to \z@ {% 
         \if \TXN@option \TXN@o@RangedRight \TXN@textus@flags
           \hss
         \fi
         \box \TXN@object@textus
         \if \TXN@option \TXN@o@RangedLeft \TXN@textus@flags
           \hss
         \else
           \if \TXN@option \TXN@o@RangedRight \TXN@textus@flags
           \else
             \hss
           \fi
         \fi
       }%
    \else
      \dimen@ = \maxdimen
      \if \TXN@option \TXN@o@AlignedRight \TXN@textus@flags
        \dimen@ = \wd\TXN@object@textus
      \fi
      \if \TXN@option \TXN@o@AlignedCentre \TXN@textus@flags
        \dimen@ = .5\wd\TXN@object@textus
      \fi
      \ifdim \dimen@ = \maxdimen
      \else
         \setbox \TXN@object@textus = 
           \hbox {\kern -\dimen@ \box \TXN@object@textus}%
      \fi
    \fi
    \box \TXN@object@textus
    \ifTXN@textus@star   
    \else
      \if \TXN@option \TXN@o@AttachedToArea \TXN@textus@flags
      \else
        \TXN@gdef {TXN@textus[\TXN@c]text}{}% 
      \fi
    \fi
  \else
    \ifnum \TXN@counter = \z@
      \leavevmode
      \begingroup \@nameuse{TXN@textus[\TXN@theTextus]Facies}#1\endgroup
    \fi
  \fi
  \ifTXN@withinVersus
    \everypar = {\PTR@start@box}%
    \expandafter \PTR@obeylines
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@set@textus@text #1#2{%
%<debug> \TXN@trace \TXN@set@textus@text
  \if \TXN@option \TXN@o@AttachedToArea \TXN@textus@flags
    \@tempcnta = \TXN@area@count \TXN@safe
    \ifnum \@tempcnta > \TXN@max@area@ind
        \PackageError {TEXNIKA}
         {Too many areas}
         {There can be no more than \TXN@max@area@ind\space areas}%
    \fi
    \TXN@global@listtrue
    \expandafter
    \TXN@SimpleList@set \csname TXN@textus[#1]text\endcsname.\@tempcnta
                        {\strut#2\strut}%
  \else
    \TXN@gdef {TXN@textus[#1]text}{#2}% 
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@getTextus@septies #1{%
%<debug> \TXN@trace \TXN@getTextus@septies
  \ifnum \TXN@pass = \@ne
    \ifTXN@textus@star
      \TXN@toks@a = {\textus*[}%
    \else
      \TXN@toks@a = {\textus[}%
    \fi
    \TXN@toks@b = \expandafter{\the\TXN@counter}%
    \TXN@toks@c = {]{#1}}%
    \edef \TXN@temp {\the\TXN@toks@a\the\TXN@toks@b\the\TXN@toks@c}%
    \toks@ = \expandafter {\TXN@temp}%
    \TXN@save@command
  \else
    \ifTXN@replay
    \else
      \if \TXN@option \TXN@o@AttachedToArea \TXN@textus@flags
      \else
        \TXN@gdef {TXN@textus[\TXN@c]text}{}% 
      \fi
    \fi
  \fi
  \expandafter \ignorespaces
}
%    \end{macrocode}
%  \subsection{Processing multiples}
%    \begin{macrocode}
\def \TXN@getTextus@multiples #1{%
%<debug> \TXN@trace \TXN@getTextus@multiples
  \toks@ = \expandafter {%
    \csname TXN@textus[\TXN@c]Facies\endcsname\relax\relax}%
  \setbox \z@ = \hbox {#1}%
  \setbox \@ne = \hbox {\@nameuse{TXN@textus[\TXN@c]Facies}\relax}%
  \dimen@ = \wd\@ne
  \loop
  \ifdim \dimen@ < \wd\z@
    \advance \dimen@ by \wd\@ne
  \repeat
%    \end{macrocode}
% One copy is inserted by |\Facies| as the box is generated
%    \begin{macrocode}
  \advance \dimen@ by -\wd\@ne
%    \end{macrocode}
%
%    \begin{macrocode}
  \toks@ = \expandafter {%
    \csname TXN@textus[\TXN@c]Facies\endcsname\relax}%
  \toks@ = \expandafter {\the\toks@}%
  \edef \TXN@temp {\leavevmode
    \hbox to\the\dimen@{\xleaders\hbox{\the\toks@}\hfill}}  
  \expandafter \TXN@getTextus@sexies \expandafter{\TXN@temp}%
}
%    \end{macrocode}
%  \subsection{Attaching a \TXN@cmd{textus} object to the line}
%
%    \begin{macrocode}
\def \TXN@attach@textus #1{%
%<debug>  \TXN@trace [#1] \TXN@attach@textus
  \ifnum #1 = \TXN@e \TXN@safe
    \TXN@typeset@textus {\TXN@e}%
  \else
    \TXN@attach@textus@bis
  \fi
}
\def \TXN@attach@textus@bis {%
%<debug>  \TXN@trace \TXN@attach@textus@bis
  \setbox \TXN@object@textus = \null
  \count@ = \@ne
  \loop
    \xdef \TXN@textus@loop {\the\count@}%
    \advance \count@ by \m@ne
  \ifnum \count@ < \TXN@textus@max \TXN@safe
    \TXN@get@textus@flags {\TXN@textus@loop}%
    \if \TXN@option \TXN@o@AttachedToArea \TXN@textus@flags
    \else
      \if \TXN@empty {TXN@textus[\TXN@textus@loop]text}%
      \else 
        \expandafter
        \TXN@typeset@textus \expandafter{\TXN@textus@loop}%
      \fi
    \fi
    \count@ = \TXN@textus@loop \TXN@safe
    \advance \count@ by \@ne 
  \repeat
}
%    \end{macrocode}
%
%
%    \begin{macrocode}
\def \TXN@typeset@textus #1{%
%<debug>  \TXN@trace \TXN@typeset@textus
    \def \TXN@textus@text {}%
    \TXN@make@object@textus {#1}%
    \TXN@move@to@marginalia {#1}{t}\TXN@object@textus
}
%    \end{macrocode}
%  \subsection{Building a \TXN@cmd{textus} object}
%    \begin{macrocode}
\def \TXN@make@object@textus #1{%
%<debug>  \TXN@trace \TXN@make@object@textus
  \def  \TXN@entity {textus}%
  \TXN@get@textus@flags {#1}%
  \edef \TXN@flags {\TXN@textus@flags}% 
  \ifx \empty \TXN@textus@text 
    \gdef \TXN@textus@text {\csname TXN@textus[#1]text\endcsname}%
  \fi
%    \end{macrocode}
% If |\excessus| no special formatting
%    \begin{macrocode}
  \ifnum #1 = \TXN@e \TXN@safe
    \let \TXN@box@type = \hbox 
    \def \TXN@box@parameters {}%
  \else
    \TXN@get@object@field@width {#1}%
    \ifx \empty \TXN@textus@field@width
      \let \TXN@box@type = \hbox 
      \def \TXN@box@parameters {}%
    \else
      \TXN@toks@a = {\hsize \TXN@textus@field@width}% 
      \ifdim \TXN@textus@field@width = \z@
        \TXN@toks@a = {\hsize \maxdimen}% 
      \fi
      \TXN@toks@b = {}% 
      \if \TXN@option \TXN@o@RangedLeft \TXN@textus@flags
        \TXN@toks@b = {\rangedleft}%
        \if \TXN@option \TXN@o@RangedRight \TXN@textus@flags
          \TXN@toks@b = {\centred}%
        \fi
      \else
        \if \TXN@option \TXN@o@RangedRight \TXN@textus@flags
          \TXN@toks@b = {\rangedright}%
        \fi
      \fi
      \edef \TXN@box@parameters {\the\TXN@toks@a \the\TXN@toks@b}%
%    \end{macrocode}
%
%    \begin{macrocode}
      \setbox \z@ = \hbox {%
        \leftskip = \z@  \rightskip = \z@  \parindent = \z@
        \def \\{\kern \TXN@textus@field@width\relax}%
        \let \Delimiter = \TXN@get@delimiter
        \@nameuse{TXN@textus[#1]Facies}\TXN@textus@text
      }%
      \ifdim \TXN@textus@field@width < \wd\z@
%    \end{macrocode}
% More than one line.
%    \begin{macrocode}
        \if \TXN@option \TXN@o@AlignedBottom \TXN@textus@flags
          \let \TXN@box@type = \vbox 
        \else
          \let \TXN@box@type = \vtop 
        \fi
      \else
        \let \TXN@box@type = \hbox 
      \fi
    \fi
  \fi
  \TXN@sw@false
  \if \TXN@option \TXN@o@AttachedToArea \TXN@textus@flags
    \if \TXN@option \TXN@o@AreaWrap \TXN@textus@flags
      \TXN@sw@true
    \fi
  \fi
  \ifTXN@sw
    \TXN@make@object@textus@wrap {#1}%
  \else
    \TXN@make@object@textus@setbox {#1}%
  \fi
  \ifx \TXN@box@type \hbox
    \ifnum #1 = \TXN@e \TXN@safe
    \else
      \TXN@place@object@in@field \TXN@object@textus
    \fi
  \else
    \ifTXN@textus@zero@width
      \wd\TXN@object@textus = \z@
    \fi
    \TXN@sw@false
    \if \TXN@option \TXN@o@AlignedMiddle \TXN@textus@flags
      \TXN@sw@true
    \else
      \if \TXN@option \TXN@o@AlignedAxis \TXN@textus@flags
        \TXN@sw@true
      \fi
    \fi
    \ifTXN@sw
      \setbox \TXN@object@textus = 
        \hbox {$\vcenter{\box \TXN@object@textus}$}%
      \dimen@ = \ht\TXN@object@textus
      \advance \dimen@ by -\dp\TXN@object@textus
      \if \TXN@option \TXN@o@AlignedAxis \TXN@textus@flags
        \setbox \z@ = \hbox {$\vcenter{}$}%
        \advance \dimen@ by -2\ht\z@
      \fi
      \setbox \TXN@object@textus = 
        \hbox {\lower .5\dimen@ \box \TXN@object@textus}%
    \else
      \setbox \TXN@object@textus = \hbox {\box \TXN@object@textus}%
    \fi
    \ht\TXN@object@textus = \z@
    \dp\TXN@object@textus = \z@
  \fi
  \ifnum #1 > \z@
    \if \TXN@empty {TXN@textus[#1]star}%
      \if \TXN@option \TXN@o@AttachedToArea \TXN@textus@flags
      \else
        \TXN@gdef {TXN@textus[#1]text}{}% 
      \fi
    \fi
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}        
\def \TXN@make@object@textus@setbox #1{%
%<debug>  \TXN@trace \TXN@make@object@textus@setbox
  \gdef \TXN@textus@delimiter@left {}%
  \gdef \TXN@textus@delimiter@right {}%
  \setbox \TXN@object@textus = \TXN@box@type {%
      \parindent = \z@
      \parskip = \z@skip
      \leftskip = \z@skip
      \rightskip = \z@skip
      \TXN@box@parameters 
      \everypar {\TXN@box@parameters \parindent = \z@}%
      \let \\=\TXN@esc@esc@break
      \let \Delimiter = \TXN@get@delimiter
      \@nameuse{TXN@textus[#1]Facies}\TXN@textus@text
      \endgraf
      \xdef \TXN@prevgraf {\the\prevgraf}%
  }%
  \ifx \empty \TXN@textus@delimiter@left
  \else
    \expandafter \TXN@insert@delimiter \TXN@textus@delimiter@left{l}%
  \fi
  \ifx \empty \TXN@textus@delimiter@right
  \else
    \expandafter \TXN@insert@delimiter \TXN@textus@delimiter@right{r}%
  \fi
}
%    \end{macrocode}
%  \subsubsection{Processing \TXN@cmd{Delimiter}s}
% Get the delimiter(s) into control sequences, as a list of three 
% values: the first is either 0 (normal form) or 1 (starred form),
% the other two are the arguments of the |\Delimiter| command.
%    \begin{macrocode}
\def \TXN@get@delimiter {%
%<debug>  \TXN@trace \TXN@get@delimiter
  \@ifstar {\count@=\@ne\TXN@get@delimiter@bis}
           {\count@=\z@\TXN@get@delimiter@bis}}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand {\TXN@get@delimiter@bis} [2] [1] {%
  \setbox \z@ = \hbox {$\vcenter{}$}%
  \xdef \TXN@delimiter@axis {\the\ht\z@}%
  \if \TXN@option \TXN@o@DelimiterAtStart \TXN@textus@flags
    \ifx \empty \TXN@textus@delimiter@left 
      \expandafter \gdef
      \expandafter \TXN@textus@delimiter@left
      \expandafter {%
      \expandafter {\the\count@}{#1}{#2}}%
    \else
      \expandafter \gdef
      \expandafter \TXN@textus@delimiter@right
      \expandafter {%
      \expandafter {\the\count@}{#1}{#2}}%
    \fi
  \else
      \expandafter \gdef
      \expandafter \TXN@textus@delimiter@right
      \expandafter {%
      \expandafter {\the\count@}{#1}{#2}}%
  \fi
}
%    \end{macrocode}
% Insert a delimiter into the object.\\
% The first three parameters are those in the list held in
% |\TXN@textus@delimiter@left| and |\TXN@textus@delimiter@right|,
% the fourth is `l' or `r' for the side at which the delimiter
% must be inserted.
%    \begin{macrocode}
\newif \ifTXN@delimiter@ante
\newif \ifTXN@delimiter@post
\def \TXN@insert@delimiter #1#2#3#4{%
%<debug>  \TXN@trace \TXN@insert@delimiter
  \TXN@sw@false
  \if \TXN@option \TXN@o@AttachedToArea \TXN@textus@flags
    \ifvbox \TXN@object@textus
      \xdef \TXN@delimiter@axis {\z@}%
    \fi
    \ifnum #1 = \z@
      \TXN@sw@true
    \fi
  \fi
  \ifTXN@sw
    \TXN@assign \TXN@dim@a = {TXN@area[\TXN@area@ind]height}%
    \TXN@assign \TXN@dim@b = {TXN@area[\TXN@area@ind]depth}%
  \else
    \TXN@dim@a = \ht\TXN@object@textus
    \TXN@dim@b = \dp\TXN@object@textus
  \fi
  \dimen@ = \TXN@dim@a
  \advance \dimen@ by \TXN@dim@b
  \ifx \empty \TXN@ModusDelimiter
    \dimen@ = #2\dimen@
  \else
    \dimen@ = \TXN@ModusDelimiter\dimen@
  \fi
  \setbox \z@ = \hbox {%
    $\vcenter {\vrule height .5\dimen@ depth .5\dimen@ width \z@}$}%
  \setbox \z@ = \hbox {%
    $\left#3\vrule height \ht\z@ depth \dp\z@ width \z@\right.$}%
  \dimen@ = \ht\z@
  \advance \dimen@ by -\dp\z@
  \ifx \TXN@box@type \hbox
    \dimen@ = \z@
  \else
    \advance \dimen@ by \dp\TXN@object@textus
    \advance \dimen@ by -\ht\TXN@object@textus
    \divide \dimen@ by \tw@
  \fi
  \setbox \TXN@object@textus = \hbox {%
    \if r#4\relax
      \box \TXN@object@textus
    \fi
    \TXN@SpatiumAnteDelimiter 
    \lower \dimen@ \box \z@ 
    \TXN@SpatiumPostDelimiter 
    \if l#4\relax
      \box \TXN@object@textus 
    \fi
  }%
}
%    \end{macrocode}
%  \subsubsection{\TXN@cmd{wrap}ping the object around an area}
% The special case of an object \textit{wrapped} around an area
%    \begin{macrocode}
\def \TXN@make@object@textus@wrap #1{%
%<debug>  \TXN@trace \TXN@make@object@textus@wrap
%    \end{macrocode}
% Set the text within the field width, to get the baselineskip
%    \begin{macrocode}
   \setbox \z@ = \vbox {%
     \TXN@box@parameters \parindent = \z@ 
     \hsize \TXN@textus@field@width 
     \let \\=\TXN@esc@esc@break
     \@nameuse{TXN@textus[#1]Facies}\TXN@textus@text
     \global \TXN@baselineskip = \baselineskip
     \endgraf
     \xdef \TXN@prevgraf {\the\prevgraf}%
   }%
%    \end{macrocode}
% Get the total size of the area
%    \begin{macrocode}
   \TXN@assign \TXN@dim@a = {TXN@area[\TXN@area@ind]height}%
   \TXN@assign \TXN@dim@b = {TXN@area[\TXN@area@ind]depth}%
   \advance \TXN@dim@a by \TXN@dim@b
   \TXN@dim@c = \TXN@dim@a
%    \end{macrocode}
% Get the empty space at the end of the area
%    \begin{macrocode}
   \xdef \TXN@area@wrap@skip {\z@}%
   \dimen@ = \z@
   \if \TXN@empty {TXN@area[\TXN@area@ind]spatium}%
   \else
      \TXN@assign \dimen@@ = {TXN@area[\TXN@area@ind]spatium}%
      \advance \dimen@ by \dimen@@
   \fi
   \xdef \TXN@area@wrap@skip {\the\dimen@}%
   \xdef \TXN@area@empty {\the\dimen@}%
%    \end{macrocode}
% Set up the |\parshape| list
%    \begin{macrocode}
   \skip@ = \TXN@baselineskip \TXN@safe
   \dimen@ = \skip@ 
   \toks@ = {\parshape \the\count@ }%
   \count@ = \@ne
   \loop
   \ifdim \TXN@dim@a > \dimen@
     \advance \TXN@dim@a by -\dimen@
     \toks@ = \expandafter{\the\toks@ \z@ \TXN@textus@field@width}%
     \advance \count@ by \@ne
   \repeat
%    \end{macrocode}
% Add one line, if necessary
%    \begin{macrocode}
   \TXN@sw@false
   \ifdim \TXN@dim@a = \z@
     \ifdim \TXN@area@empty = z@
       \TXN@sw@true
     \fi
   \else
      \ifdim \TXN@dim@a > \TXN@area@empty \TXN@safe
         \TXN@sw@true
      \fi
   \fi
   \ifTXN@sw
     \toks@ = \expandafter{\the\toks@ \z@ \TXN@textus@field@width}%
     \advance \count@ by \@ne
   \fi
%    \end{macrocode}
% The text below the area is set in a single line of infinite width.
% (for the rationale behind this, see page 66 of the EDMAC documentation)
%    \begin{macrocode}
   \toks@ = \expandafter{\the\toks@ \z@ \maxdimen}%
%    \end{macrocode}
% Set the entire paragraph
%    \begin{macrocode}
   \setbox \z@ = \vbox {%
      \TXN@box@parameters \parindent = \z@  \parskip = \z@
      \the\toks@
      \let \\=\TXN@esc@esc@break
      \@nameuse{TXN@textus[#1]Facies}\TXN@textus@text
      \endgraf
   }%
   \skip@ = \TXN@baselineskip \TXN@safe
   \dimen@ = -\skip@ 
   \advance \dimen@ by \ht\z@
   \splittopskip = \z@
%    \end{macrocode}
% Get the column corresponding to the area, inserting a |\strut|
% at the end, to ensure proper stacking of the |\vbox|es
%    \begin{macrocode}
   \setbox \tw@ = \vsplit \z@ to \dimen@
   \setbox \tw@ = \vbox {\@nameuse{TXN@textus[#1]Facies}\relax
                         \unvbox \tw@
                         \setbox \tw@ = \lastbox
                         \strut \unhbox \tw@ \strut \endgraf}%
%    \end{macrocode}
% Reset the rest of the text at the natural text width
%    \begin{macrocode}
   \TXN@get@Locus {textus[#1]}{t}%
   \TXN@dim@a = \dimen@
   \TXN@get@Locus {textus[\TXN@theTextus]}{t}%
   \TXN@dim@b = \dimen@
   \dimen@ = \linewidth
   \setbox \z@ = \vbox {%
      \parindent = \z@ 
      \hsize \dimen@
      \let \\=\TXN@esc@esc@break
      \unvbox \z@
      \setbox \z@ = \lastbox
      \@nameuse{TXN@textus[#1]Facies}{\strut \unhbox \z@ \strut}%
      \endgraf
      \xdef \TXN@prevgraf {\the\prevgraf}%
      \unskip
      \unskip
      \unpenalty
   }%
%    \end{macrocode}
% Join the two pieces
%    \begin{macrocode}
   \ifdim \TXN@dim@a > \TXN@dim@b
     \dimen@ = \TXN@dim@a
     \advance \dimen@ by -\TXN@dim@b
   \else
     \dimen@ = \z@
   \fi
   \setbox \TXN@object@textus = \TXN@box@type {%
     \@nameuse{TXN@textus[#1]Facies}\relax
     \topskip = \z@
     \unvcopy \tw@
     \TXN@counter@a = \TXN@prevgraf \TXN@safe
     \global \setbox \thr@@ = \copy \z@
     \loop
     \ifnum \TXN@counter@a > \z@
       \setbox \z@ = \vbox{%
         \vbadness = \@M
         \splittopskip = \z@
         \global \setbox \@ne = \vsplit \thr@@ to \TXN@baselineskip
         \global \setbox \thr@@ = \box \thr@@
         \unvbox \@ne \global \setbox \@ne = \lastbox
       }%
       \moveleft \dimen@ \box \@ne
       \advance \TXN@counter@a by \m@ne
     \repeat
   }%
   \wd\TXN@object@textus = \TXN@textus@field@width \TXN@safe
   \dimen@ = \ht\TXN@object@textus
   \advance \dimen@ by \dp\TXN@object@textus
   \advance \dimen@ by -\TXN@dim@c
   \advance \dimen@ by \TXN@area@wrap@skip \TXN@safe
   \xdef \TXN@area@wrap@skip {\the\dimen@}%
}
%    \end{macrocode}
% \section{Areas} 
%
% \subsection{Data structures} 
%
%
% The list of areas. Each list element has the form:\\
% \qquad|{<line number>,<identifier>}|\\
% The |<line number>| is used in error messages; the |<identifier>|
% is the area name or |\relax| for anonymous areas. After |\endarea|
% the list element is set to |{0,\relax}|.\\
% We allocate the \textbf{cs} directly, inserting a dummy element
% in the first position, so that there is a direct correspondence
% between area numbers and indices.
%    \begin{macrocode}
\gdef \TXN@areas {\\{0,\relax}}
%    \end{macrocode}
% The maximum number of areas that can exist at any time.
%    \begin{macrocode}
\chardef \TXN@max@area@ind = 16
%    \end{macrocode}
% The number of elements in the list.
%    \begin{macrocode}
\gdef \TXN@area@count {0}
%    \end{macrocode}
% The number of active areas in the list
%    \begin{macrocode}
\gdef \TXN@active@areas {0}
%    \end{macrocode}
% The index of the area being processed
%    \begin{macrocode}
\gdef \TXN@area@ind {0}%
%    \end{macrocode}
% Adding a new area to the list.
%    \begin{macrocode}
\def \TXN@add@area #1{%
  \TXN@trim {#1}%
  \edef \TXN@temp {%
    \ifTXN@withinProsa \the\TXNl@linenumber\else \the\inputlineno\fi
    ,\the\TXN@trimmed}%
  \TXN@gincr \TXN@area@count
  \TXN@gincr \TXN@active@areas
  \TXN@global@listtrue
  \TXN@SimpleList@set@extend \TXN@areas.\TXN@area@count \TXN@temp
  \xdef \TXN@area@ind {\TXN@area@count}%
}
%    \end{macrocode}
% Removing an area (index in |\TXN@area@ind|).
%    \begin{macrocode}
\def \TXN@remove@area {%
  \TXN@set \TXN@areas.\TXN@area@ind {0,\relax}%
%    \end{macrocode}
% The area list is global
%    \begin{macrocode}
  {\let \\= \relax \xdef \TXN@areas {\TXN@areas}}%
  \TXN@gdecr \TXN@active@areas
  \ifnum \TXN@active@areas = \z@
    \gdef \TXN@areas {\\{0,\relax}}%
    \gdef \TXN@area@count {0}%
  \fi
}
%    \end{macrocode}
% Finding an area.\\
% Sets |\TXN@area@ind| to the index for the area identified by the
% parameter; if the parameter is |\relax|, the index for the last
% `anonymous' area is returned.
%    \begin{macrocode}
\def \TXN@find@area #1{%
  \TXN@trim {#1}%
  \edef \TXN@parameter {\the\TXN@trimmed}%
  \xdef \TXN@area@identifier {}%
  \begingroup
    \TXN@counter = \z@
    \def \\##1{\TXN@check ##1\TXN@nil}%
    \def \TXN@check ##1,##2\TXN@nil{%
      \ifnum ##1 > \z@
        \def \TXN@temp {##2}%
        \ifx \TXN@parameter \TXN@temp
          \xdef \TXN@area@ind {\the\TXN@counter}%
          \xdef \TXN@area@identifier {##2}%
        \fi
      \fi
      \advance \TXN@counter by \@ne
    }%
    \TXN@areas
  \endgroup
  \ifx \TXN@area@identifier \TXN@parameter
  \else
    \ifx \TXN@parameter \TXN@safe
      \def \TXN@temp {}%
    \else
      \edef \TXN@temp {[\TXN@parameter]}%
    \fi
     \PackageError {TEXNIKA}
       {There is no previous \protect\area\TXN@temp\space command}
       {}%
  \fi
}
%    \end{macrocode}
% Building the list of currently active areas.\\
% The list is not a \textit{SimpleList}: it is just the concatenation
% of the area indices.
%    \begin{macrocode}
\def \TXN@build@active@areas@list {%
  \gdef \TXN@active@areas@list {}%
  \begingroup
    \TXN@counter = \z@
    \def \\##1{\TXN@check ##1\TXN@nil}%
    \def \TXN@check ##1,##2\TXN@nil{%
      \ifnum ##1 > \z@
        \xdef \TXN@active@areas@list {%
          \TXN@active@areas@list{\the\TXN@counter}}%
      \fi
      \advance \TXN@counter by \@ne
    }%
    \TXN@areas
  \endgroup
}
%    \end{macrocode}
% Getting the next index.\\
% Removes the first index from the list above, placing it in |\TXN@counter|.
%    \begin{macrocode}
\def \TXN@get@next@area {%
  \ifx \empty \TXN@active@areas@list 
    \TXN@counter = \z@
  \else
    \expandafter \TXN@get@next@area@bis \TXN@active@areas@list \TXN@nil
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@get@next@area@bis #1#2\TXN@nil{%
  \TXN@counter = #1\relax
  \xdef \TXN@active@areas@list {#2}%
}
%    \end{macrocode}
% \subsection{Entering an area}
%    \begin{macrocode}
\def \area {\@bsphack\@ifnextchar [{\TXN@area}{\TXN@area[\relax]}}
\let \Area = \area
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@area [#1]{%
%<debug> \TXN@trace \area
  \@esphack
  \def \TXN@parameter {#1}%
  \TXN@sw@true
  \ifTXN@withinVersus \TXN@sw@false \fi
  \ifTXN@withinProsa  \TXN@sw@false \fi
  \ifTXN@sw
    \PackageError {TEXNIKA}
      {\protect\area\space may be used only within Versus or Prosa}
      {}%
  \fi
  \let \next = \relax
  \ifTXN@withinProsa
    \ifnum \TXN@pass = \@ne
      \toks@ = {\area[#1]}%
      \TXN@save@command
      \let \next = \TXN@area@bis
    \else
      \ifTXN@replay
        \let \next = \TXN@area@bis
      \fi
    \fi
  \else
    \let \next = \TXN@area@bis
  \fi
  \next
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@area@bis {%
%<debug> \TXN@trace \TXN@area@bis
  \TXN@add@area \TXN@parameter
  \ifnum \TXN@area@count = \@ne
    \xdef \TXN@area@parskip {\the\parskip}%
    \ifTXN@withinVersus
      \parskip = \z@
    \fi
  \fi
  \TXN@xdef {TXN@area[\TXN@area@count]height}{\z@}%
  \TXN@xdef {TXN@area[\TXN@area@count]first@line@height}{\z@}%
  \TXN@xdef {TXN@area[\TXN@area@count]rightedge}{\z@}%
  \TXN@xdef {TXN@area[\TXN@area@count]depth}{\z@}%
  \TXN@xdef {TXN@area[\TXN@area@count]leftedge}{\maxdimen}%
  \TXN@xdef {TXN@area[\TXN@area@count]stropha}{}%
  \TXN@xdef {TXN@area[\TXN@area@count]spatium}{}%
  \TXN@xdef {TXN@area[\TXN@area@count]folio}{\TXN@theFolio}%
}
%    \end{macrocode}
% \subsection{Leaving an area}
%    \begin{macrocode}
\newif \ifTXN@area@withinVersus
\def \endarea {\@bsphack\@ifnextchar [{\TXN@endarea}{\TXN@endarea[\relax]}}
\let \endArea = \endarea
%    \end{macrocode}
% Within \textit{Prosa} the text can be attached to the area only after
% the line containing |\endarea| has been processed; so the indices for
% area{s} being closed are saved in |\TXN@endarea@list|. with the same
% format as the active area list.
%    \begin{macrocode}
\def \TXN@endarea [#1]{%
%<debug> \TXN@trace \TXN@endarea
  \@esphack
  \TXN@sw@true
  \ifTXN@withinVersus \TXN@sw@false \fi
  \ifTXN@withinProsa  \TXN@sw@false \fi
  \ifTXN@sw
    \PackageError {TEXNIKA}
      {\protect\endarea\space may be used only within Versus or Prosa}
      {}%
  \fi
  \ifTXN@withinVersus
    \TXN@area@withinVersustrue
    \TXN@find@area {#1}%
    \expandafter \TXN@endarea@Versus 
  \else
    \ifnum \TXN@pass = \@ne
      \toks@ = {\endarea [#1]}%
      \TXN@save@command
      \TXN@find@area {#1}%
      \TXN@remove@area
    \else
      \ifTXN@replay
        \TXN@find@area {#1}%
        \xdef \TXN@endarea@list {\TXN@endarea@list{\TXN@area@ind}}%
      \fi
    \fi
  \fi
  \ifTXN@area@withinVersus
    \TXN@remove@area
    \TXN@area@withinVersusfalse
    \PTR@suspendtrue
    \expandafter \Versus
  \fi
}
%    \end{macrocode}
% \subsubsection{Within \textit{Versus}}
%    \begin{macrocode}
\def \TXN@endarea@Versus {%
%<debug> \TXN@trace \TXN@endarea@Versus
  \PTR@suspendtrue
  \endVersus    
  \ifnum \TXN@area@ind = \@ne
    \parskip = \TXN@area@parskip \TXN@safe
  \fi
  \TXN@insert@area@textus
  \if \TXN@empty {TXN@area[\TXN@area@ind]stropha}%
  \else
    \expandafter \TXN@spatium@vertical \expandafter {%
      \csname TXN@area[\TXN@area@ind]stropha\endcsname}%
  \fi
}
%    \end{macrocode}
% \subsubsection{Within \textit{Prosa}}
%
% The macro is called from |\TXN@process@line@prosa| when |\TXN@endarea@list|
% is not empty 
%    \begin{macrocode}
\def \TXN@endarea@Prosa {%
%<debug> \TXN@trace \TXN@endarea@Prosa
  \TXN@get@next@endarea
  \@whilenum \TXN@area@ind > \z@ \do {%
    \TXN@insert@area@textus
    \TXN@remove@area
    \TXN@get@next@endarea
  }%
  \ifnum \TXN@area@ind = \@ne
    \parskip = \TXN@area@parskip \TXN@safe
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@get@next@endarea {%
  \ifx \empty \TXN@endarea@list 
    \gdef \TXN@area@ind {0}%
  \else
    \expandafter \TXN@get@next@endarea@bis \TXN@endarea@list \TXN@nil
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@get@next@endarea@bis #1#2\TXN@nil{%
  \xdef \TXN@area@ind {#1}%
  \xdef \TXN@endarea@list {#2}%
}
%    \end{macrocode}
% \subsection{Processing all text attached to the area}
%    \begin{macrocode}
\def \TXN@insert@area@textus {%
%<debug> \TXN@trace \TXN@insert@area@textus
%<debug> \TXN@trace@area
  \xdef \TXN@area@wrap@skip {\z@}%
  \edef \TXN@save@Folio {\TXN@theFolio}%
  \expandafter \global
    \expandafter \let 
      \expandafter \TXN@theFolio 
        \csname TXN@area[\TXN@area@ind]folio\endcsname
  \count@ = \@ne
  \loop
    \xdef \TXN@area@loop {\the\count@}%
    \advance \count@ by \m@ne
  \ifnum \count@ < \TXN@textus@max \TXN@safe
    \TXN@get@textus@flags {\TXN@area@loop}%
    \if \TXN@option \TXN@o@AttachedToArea \TXN@textus@flags
      \@tempcnta = \TXN@area@ind \TXN@safe
      \advance \@tempcnta by \m@ne
      \expandafter
      \TXN@SimpleList@get \csname TXN@textus[\TXN@area@loop]text\endcsname.%
                            \@tempcnta \TXN@textus@text
      \ifx \empty \TXN@textus@text
      \else
        \setbox \TXN@marginalia = \copy\voidb@x
        \xdef \TXN@delimiter@axis {\z@}%
        \TXN@process@area@textus {\TXN@area@loop}%
        \ifvoid \TXN@marginalia 
        \else
          \TXN@attach@area@textus 
        \fi
        \@tempcnta = \TXN@area@ind \TXN@safe
        \advance \@tempcnta by \m@ne
        \TXN@global@listtrue
        \expandafter
        \TXN@SimpleList@set \csname TXN@textus[\TXN@area@loop]text\endcsname.%
                            \@tempcnta \empty
        \if \TXN@option \TXN@o@AreaExtend \TXN@textus@flags
          \TXN@area@textus@extend 
        \fi
      \fi
    \fi
    \count@ = \TXN@area@loop \TXN@safe
    \advance \count@ by \@ne 
  \repeat
  \xdef \TXN@theFolio {\TXN@save@Folio}%
}
%    \end{macrocode}
% \subsubsection{Updating the left and right edges}
%    \begin{macrocode}
\def \TXN@area@textus@extend {%
  \TXN@build@active@areas@list 
  \loop
    \TXN@get@next@area
  \ifnum \TXN@area@ind > \TXN@counter
    \TXN@assign \dimen@ = {TXN@area[\TXN@c]leftedge}%
    \ifdim \dimen@ > \TXN@area@textus@leftedge \TXN@safe
      \TXN@xdef {TXN@area[\TXN@c]leftedge}{\TXN@area@textus@leftedge}%
    \fi
    \TXN@assign \dimen@ = {TXN@area[\TXN@c]rightedge}%
    \ifdim \dimen@ < \TXN@area@textus@rightedge \TXN@safe
      \TXN@xdef {TXN@area[\TXN@c]rightedge}{\TXN@area@textus@rightedge}%
    \fi
  \repeat
}
%    \end{macrocode}
% \subsubsection{Attaching the object to the area}
%    \begin{macrocode}
\def \TXN@attach@area@textus {%
%<debug> \TXN@trace \TXN@attach@area@textus
  \TXN@assign \TXN@dim@a = {TXN@area[\TXN@area@ind]height}%
  \TXN@assign \TXN@dim@b = {TXN@area[\TXN@area@ind]depth}%
  \advance \TXN@dim@a by \TXN@dim@b
  \if \TXN@option \TXN@o@AreaMiddle \TXN@textus@flags
    \divide \TXN@dim@a by \tw@
    \advance \TXN@dim@a by -\TXN@delimiter@axis \TXN@safe
  \else
    \if \TXN@option \TXN@o@AreaTop \TXN@textus@flags
      \TXN@assign \dimen@ = {TXN@area[\TXN@area@ind]first@line@height}%
      \advance \TXN@dim@a by -\dimen@
    \else
      \if \TXN@option \TXN@o@AreaBottom \TXN@textus@flags
        \TXN@dim@a = \TXN@dim@b 
      \fi
    \fi
  \fi
  \TXN@dim@b = \prevdepth
  \kern -\TXN@dim@a     
  \ht\TXN@marginalia = \z@
  \dp\TXN@marginalia = \z@
  \nointerlineskip
  \box \TXN@marginalia
  \nointerlineskip
  \kern \TXN@dim@a
  \kern \TXN@area@wrap@skip \TXN@safe
  \prevdepth = \TXN@dim@b  
}
%    \end{macrocode}
% \subsubsection{Building the object}
%    \begin{macrocode}
\def \TXN@process@area@textus #1{%
%<debug> \TXN@trace \TXN@process@area@textus
    \TXN@make@object@textus {#1}%
    \TXN@assign \dimen@ = {TXN@textus[\TXN@theTextus]offset@\TXN@theFolio}%
    \TXN@assign \TXN@dim@a = {TXN@area[\TXN@area@ind]leftedge}%
    \advance \TXN@dim@a  by \dimen@
    \TXN@assign \TXN@dim@b = {TXN@area[\TXN@area@ind]rightedge}%
    \advance \TXN@dim@b  by \dimen@
    \TXN@SimpleList \TXN@line@fields \z@
    \edef \TXN@temp {\the\TXN@dim@a,\the\TXN@dim@b}%
    \TXN@SimpleList@append \TXN@line@fields \TXN@temp
    \if \TXN@option \TXN@o@AreaExtend \TXN@textus@flags
      \TXN@get@Locus {textus[#1]}{t}%
      \TXN@assign \dimen@@ = {TXN@textus[\TXN@theTextus]offset@\TXN@theFolio}%
      \advance \dimen@ by -\dimen@@
      \TXN@assign \count@ = {TXN@textus[#1]side@\TXN@theFolio}%
      \ifnum \count@ = \TXN@textleftedge \TXN@safe
        \if \TXN@option \TXN@o@AlignedRight \TXN@textus@flags
          \advance \dimen@ by -\wd\TXN@object@textus
        \fi
      \fi
      \edef \TXN@area@textus@leftedge {\the\dimen@}%
      \ifnum \count@ = \TXN@textrightedge \TXN@safe
        \if \TXN@option \TXN@o@AlignedRight \TXN@textus@flags
        \else
          \advance \dimen@ by \wd\TXN@object@textus
        \fi
      \fi
      \edef \TXN@area@textus@rightedge {\the\dimen@}%
    \fi
    \TXN@move@to@marginalia {#1}{t}\TXN@object@textus
}
%    \end{macrocode}
% \subsection{Collecting information about the area contents}
%
% \subsubsection {A line within \textit{Prosa}}
%    \begin{macrocode}
\def \TXN@process@area@line@Prosa #1{%
%<debug> \TXN@trace \TXN@process@area@line@Prosa
  \TXN@build@active@areas@list 
  \loop
    \TXN@get@next@area
  \ifnum \TXN@counter > \z@
    \TXN@assign \dimen@ = {TXN@area[\TXN@c]height}%
    \ifdim \dimen@ = \z@
      \advance \dimen@ by \ht#1\relax
      \TXN@xdef {TXN@area[\TXN@c]first@line@height}{\the\ht#1}%
    \fi
    \advance \dimen@ by \baselineskip
    \TXN@xdef {TXN@area[\TXN@c]height}{\the\dimen@}%
    \TXN@xdef {TXN@area[\TXN@c]depth}{\the\dp#1}%
    \TXN@assign \dimen@ = {TXN@area[\TXN@c]rightedge}%
    \ifdim \dimen@ < \TXN@measure
      \TXN@xdef {TXN@area[\TXN@c]rightedge}{\the\TXN@measure}%
    \fi
    \TXN@assign \dimen@ = {TXN@area[\TXN@c]leftedge}%
    \ifdim \dimen@ < \z@
    \else
      \TXN@xdef {TXN@area[\TXN@c]leftedge}{\z@}%
    \fi
  \repeat
}
%    \end{macrocode}
% \subsubsection {A line within \textit{Versus}}
%    \begin{macrocode}
\def \TXN@process@area@line@Versus #1{%
%<debug> \TXN@trace \TXN@process@area@line@Versus
  \TXN@build@active@areas@list 
  \TXN@get@next@area
  \@whilenum \TXN@counter > \z@ \do {%
    \TXN@xdef {TXN@area[\TXN@c]spatium}{}%
    \if \TXN@empty {TXN@area[\TXN@c]stropha}%
    \else
      \begingroup
        \expandafter \TXN@spatium@vertical \expandafter {%
          \csname TXN@area[\TXN@c]stropha\endcsname}%
      \endgroup
      \TXN@xdef {TXN@area[\TXN@c]stropha}{}%
    \fi
    \TXN@assign \dimen@ = {TXN@area[\TXN@c]height}%
    \dimen@@ = \ht#1\relax
    \ifdim \dimen@ = \z@
      \advance \dimen@ by \dimen@@
      \TXN@xdef {TXN@area[\TXN@c]first@line@height}{\the\dimen@@}%
    \else
      \advance \dimen@@ by \dp#1\relax
      \ifdim \dimen@@ < \baselineskip
        \dimen@@ = \baselineskip
      \fi
      \advance \dimen@ by \dimen@@
    \fi
    \TXN@xdef {TXN@area[\TXN@c]height}{\the\dimen@}%
    \TXN@assign \dimen@ = {TXN@area[\TXN@c]rightedge}%
    \ifdim \wd#1 > \dimen@
      \TXN@xdef {TXN@area[\TXN@c]rightedge}{\the\wd#1}%
    \fi
    \TXN@xdef {TXN@area[\TXN@c]depth}{\the\dp#1}%
    \TXN@assign \dimen@ = {TXN@area[\TXN@c]leftedge}%
    \TXN@assign \dimen@@ = {TXN@textus[\TXN@theTextus]shift}%
    \ifdim \dimen@@ < \dimen@
      \TXN@xdef {TXN@area[\TXN@c]leftedge}{\the\dimen@@}%
    \fi
    \TXN@get@next@area
  }%
}
%    \end{macrocode}
% \subsubsection {Vertical spacing}
%    \begin{macrocode}
\def \TXN@process@area@spatium #1{%
%<debug> \TXN@trace \TXN@process@area@spatium
  \TXN@build@active@areas@list 
  \TXN@get@next@area
  \@whilenum \TXN@counter > \z@ \do {%
    \ifx \TXN@safe #1\relax
      \dimen@ = \z@
    \else
      \dimen@ = #1\relax
      \if \TXN@empty {TXN@area[\TXN@c]spatium}%
        \TXN@xdef {TXN@area[\TXN@c]spatium}{\the\dimen@}%
      \else
        \TXN@assign \dimen@@ = {TXN@area[\TXN@c]spatium}%
        \ifdim \dimen@ > \dimen@@
          \TXN@xdef {TXN@area[\TXN@c]spatium}{\the\dimen@}%
          \advance \dimen@ by -\dimen@@
        \else
          \dimen@ = \z@
        \fi
      \fi
    \fi
    \TXN@assign \dimen@@ = {TXN@area[\TXN@c]height}%
    \ifdim \dimen@@ > \z@
      \advance \dimen@@ by \dimen@
    \fi
    \TXN@xdef {TXN@area[\TXN@c]height}{\the\dimen@@}%
    \TXN@get@next@area
  }%
}
%    \end{macrocode}
%  \section{The \TXN@cmd{numerus} class}
%  \subsection {Setting the \TXN@cmd{progressio} attribute}
%
% The internal representation of the attribute is a \textit{SimpleList},
% termined by |\\{\@M}|.\\
% The default, used if the attribute is not defined, is numbering 
% every fifth line.
%    \begin{macrocode}
\def \TXN@default@progressio {\\{5}\\{\@M}}
\def \TXN@zero@progressio    {\\{0}\\{\@M}}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand{\TXN@setProgressio@numerus}[2][0]{%
  \TXN@counter = #1\relax 
  \TXN@counter@a = \z@ 
  \TXN@SimpleList \TXN@SimpleList@work \z@
  \let \\ = \relax
  \TXN@setProgressio@numerus@bis #2\TXN@nil
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@setProgressio@numerus@bis #1{%
  \let \next = \TXN@setProgressio@numerus@bis
  \ifx \TXN@nil #1\relax
     \let \next = \TXN@setProgressio@numerus@ter
  \else
    \ifx <#1\relax 
      \TXN@SimpleList@append  \TXN@SimpleList@work {<}%
    \else
      \ifx \\#1\relax
        \let \next = \TXN@setProgressio@numerus@quater
      \else
          \ifnum #1 = \z@
            \ifnum \TXN@counter@a > \z@
              \PackageError {TEXNIKA}
                {Progressio: non-positive not first}
                {}%
            \fi
        \fi
        \count@ = #1\relax
        \ifnum \count@ < \z@ 
          \count@ = -\count@ 
        \fi
        \TXN@SimpleList@append
          \TXN@SimpleList@work {\the\count@}%
        \advance \TXN@counter@a by \@ne 
      \fi
    \fi
  \fi
  \next
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@setProgressio@numerus@ter {%
  \TXN@gdef {TXN@numerus[\TXN@c]index}{0}%
  \ifnum \TXN@counter@a > \z@
    \ifx \empty \TXN@SimpleList@work 
    \else
      \TXN@SimpleList@append  \TXN@SimpleList@work {\@M}%
      \let \\ = \relax
      \TXN@edef {TXN@numerus[\TXN@c]progressio}{\TXN@SimpleList@work}%
    \fi
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\newif \ifTXN@fragment@set
\newif \ifTXN@folded@set
\def \TXN@setProgressio@numerus@quater #1\TXN@nil{%
  \define@key {progressio}{f}[ff]{\TXN@setProgressio@numerus@quinquies##1}%   
  \define@key {progressio}{l}[ll]{\TXN@setProgressio@numerus@quinquies##1}
  \define@key {progressio}{fl}[fl]{\TXN@setProgressio@numerus@quinquies##1}
  \define@key {progressio}{lf}[lf]{\TXN@setProgressio@numerus@quinquies##1}
  \define@key {progressio}{a}[aa]{\TXN@setProgressio@numerus@quinquies##1}
  \define@key {progressio}{F}[FF]{\TXN@setProgressio@numerus@sexies##1}%   
  \define@key {progressio}{L}[LL]{\TXN@setProgressio@numerus@sexies##1}%   
  \define@key {progressio}{A}[AA]{\TXN@setProgressio@numerus@sexies##1}%   
  \let \KV@errx = \TXN@keyval@error
  \TXN@fragment@setfalse
  \TXN@folded@setfalse
  \def \TXN@temp {}%
  \def \TXN@temp@bis {}%
  \setkeys {progressio}{#1}%
  \ifTXN@fragment@set
  \else
    \edef \TXN@temp {l\TXN@temp}%
    \edef \TXN@temp@bis {l\TXN@temp@bis}%
  \fi
  \ifTXN@folded@set
  \else
    \edef \TXN@temp {L\TXN@temp}%
    \edef \TXN@temp@bis {L\TXN@temp@bis}%
  \fi
  \TXN@edef {TXN@numerus[\TXN@c]fragment@recto}{\TXN@temp}%
  \TXN@edef {TXN@numerus[\TXN@c]fragment@verso}{\TXN@temp@bis}%
  \TXN@setProgressio@numerus@ter
}
\def \TXN@setProgressio@numerus@quinquies #1#2{%   
  \edef \TXN@temp {\TXN@temp #1}%
  \edef \TXN@temp@bis {\TXN@temp@bis #2}%
  \TXN@fragment@settrue
}
\def \TXN@setProgressio@numerus@sexies #1#2{%   
  \edef \TXN@temp {\TXN@temp #1}%
  \edef \TXN@temp@bis {\TXN@temp@bis #2}%
  \TXN@folded@settrue
}
%    \end{macrocode}
%  \subsection{Processing the command}
%
%    \begin{macrocode}
\newcommand {\numerus} {%
  \ifx \empty \TXN@attribute@name 
    \expandafter \TXN@numerus
  \else
    \def \TXN@subclass@name {numerus}%
    \def \TXN@subclass@number {x}%
    \def \TXN@temp {TXN}%
    \expandafter \TXN@attribute@set
  \fi
}
%\let \numeri = \numerus
\let \numerum = \numerus
%    \end{macrocode}
%
% Normal case
%
%    \begin{macrocode}
\def \TXN@numerus {%
%<debug>  \TXN@trace \TXN@numerus
  \@ifstar {\TXN@counter=\@ne \TXN@numerus@bis}%
           {\TXN@counter=\z@ \TXN@numerus@bis}%
}
\newcommand {\TXN@numerus@bis}[2][0]{%
%    \end{macrocode}
% Split the argument into components
%    \begin{macrocode}
  \TXN@process@numerus@argument {#2}%
  \ifx \empty \TXN@numerus@error 
  \else
    \PackageError {TEXNIKA}
      {Error in argument of a \protect\numerus\space subclass}
      {}%
  \fi
%    \end{macrocode}
% Check whether starred or unstarred
%    \begin{macrocode}
  \ifTXN@withinAd
    \ifnum \TXN@counter = \@ne
      \PackageError {TEXNIKA}
        {You cannot use the *-form of \protect\numerus within an %
         \protect\ad\space command}%
        {}%
    \fi
    \let \TXN@process@numerus@next = \TXN@process@numerus@ad
  \else
    \let \TXN@process@numerus@next = \TXN@process@numerus@nostar
    \ifnum \TXN@counter = \@ne
      \def \TXN@parameter {#2}%
      \ifx \empty \TXN@parameter
        \TXN@def {TXN@numerus[#1]printing}{2}%
        \let \TXN@process@numerus@next = \@gobble
      \else
        \let \TXN@process@numerus@next = \TXN@process@numerus@star
      \fi
    \fi
  \fi
  \TXN@process@numerus@next {#1}%
}
%    \end{macrocode}
%  \subsubsection{Starred form}
%    \begin{macrocode}
\def \TXN@process@numerus@star #1{%
%<debug>  \TXN@trace [#1] \TXN@process@numerus@star
  \ifTXN@withinProsa
    \ifnum \TXN@pass = \tw@
      \if \TXN@num {TXN@numerus[#1]milestone} = \z@   
        \TXN@process@numerus@star@bis {#1}%
      \else
        \ifTXN@replay
          \TXN@process@numerus@star@bis {#1}%
        \fi
      \fi
    \else
      \TXN@process@numerus@star@bis {#1}%
      \if \TXN@empty {TXN@numerus[#1]side@\TXN@theFolio}%
      \else
        \if \TXN@num {TXN@numerus[#1]milestone} = \@ne
          \TXN@toks@a = {\numerus*[#1]}%
          \ifx \empty \TXN@numerus@value 
            \TXN@toks@b = {{}}%
          \else
            \TXN@counter = \TXN@c@numerus{#1}%
            \ifx \empty \TXN@numerus@set 
              \TXN@toks@b = \expandafter {\expandafter{\TXN@numerus@value}}%
            \else
              \TXN@toks@b = \expandafter
                {\expandafter{\expandafter =\the\TXN@counter}}%
            \fi
          \fi
          \edef \TXN@temp {\toks@={\the\TXN@toks@a \the\TXN@toks@b}}%
          \TXN@temp
          \TXN@save@command
        \fi
      \fi
    \fi
  \else
   \TXN@process@numerus@star@bis {#1}%
  \fi
}
\def \TXN@process@numerus@star@bis #1{%
%<debug>  \TXN@trace [#1] \TXN@process@numerus@star@bis
  \TXN@xdef {TXN@numerus[#1]head}{\TXN@numerus@head}%
  \TXN@xdef {TXN@numerus[#1]tail}{\TXN@numerus@tail}%
  \TXN@xdef {TXN@numerus[#1]separator}{\TXN@numerus@separator}%
%    \end{macrocode}
% Compute the first value
%    \begin{macrocode}
  \ifx \empty \TXN@numerus@value 
    \TXN@gdef {TXN@numerus[#1]first@value}{}%
  \else
    \ifx \empty \TXN@numerus@sign 
      \TXN@counter = \TXN@numerus@value
      \TXN@xdef {TXN@numerus[#1]first@value}{\TXN@c}%
    \else
      \TXN@counter = \TXN@c@numerus{#1}%
      \TXN@counter@a = \TXN@numerus@value \relax
      \if -\TXN@numerus@sign\relax
        \TXN@counter@a = -\TXN@counter@a
      \fi
      \advance \TXN@counter by \TXN@counter@a
      \TXN@xdef {TXN@numerus[#1]first@value}{\TXN@c}%
    \fi
    \ifx \empty \TXN@numerus@set 
    \else
      \global \TXN@c@numerus{#1}= \TXN@counter
      \ifnum \TXN@counter > \z@
        \if \TXN@num {TXN@numerus[#1]milestone} = \z@  
          \TXN@caput@numerus {#1}%
        \else
          \ifTXN@withinProsa
            \ifTXN@replay
              \TXN@caput@numerus {#1}%
            \fi
          \fi
        \fi
      \fi
      \TXN@xdef {TXN@numerus[#1]previous}{}%
    \fi
  \fi
%    \end{macrocode}
% Compute the second value
%    \begin{macrocode}
  \ifx \empty \TXN@numerus@second@value 
    \TXN@gdef {TXN@numerus[#1]second@value}{}%
  \else
    \ifx \empty \TXN@numerus@secondsign 
      \TXN@counter = \TXN@numerus@second@value \TXN@safe
      \TXN@xdef {TXN@numerus[#1]second@value}{\TXN@c}%
    \else
      \TXN@counter = \TXN@c@numerus{#1}%
      \TXN@counter@a = \TXN@numerus@second@value \TXN@safe
      \if -\TXN@numerus@secondsign \relax
        \TXN@counter@a = -\TXN@counter@a
      \fi
      \advance \TXN@counter by \TXN@counter@a
      \TXN@xdef {TXN@numerus[#1]second@value}{\TXN@c}%
    \fi
    \ifx \empty \TXN@numerus@set 
    \else
      \global \TXN@c@numerus{#1}= \TXN@counter
      \ifnum \TXN@counter > \z@
        \if \TXN@num {TXN@numerus[#1]milestone} = \z@  
          \TXN@caput@numerus {#1}%
        \else
          \ifTXN@withinProsa
            \ifTXN@replay
              \TXN@caput@numerus {#1}%
            \fi
          \fi
        \fi
      \fi
      \TXN@xdef {TXN@numerus[#1]previous}{}%
    \fi
  \fi
%    \end{macrocode}
% If in-line, typeset the number.
%    \begin{macrocode}
  \if \TXN@empty {TXN@numerus[#1]side@\TXN@theFolio}%
    \TXN@make@object@numerus {#1}{*}%
    \leavevmode \box \TXN@object@numerus 
    \TXN@gdef {TXN@numerus[#1]first@value}{}%
  \fi
}
%    \end{macrocode}
%  \subsubsection{Normal form}
%    \begin{macrocode}
\def \TXN@process@numerus@nostar #1{%
%<debug>  \TXN@trace [#1]\TXN@process@numerus@nostar
  \edef \TXN@temp {%
    \TXN@numerus@second@value
    \TXN@numerus@secondsign
    \TXN@numerus@separator
    \TXN@numerus@head
    \TXN@numerus@tail
    \TXN@numerus@set
  }%
  \ifx \empty \TXN@temp 
  \else
    \PackageError {TEXNIKA}
     {The argument of the normal form of the command\MessageBreak
      contains data that is allowed only in the *-form}
     {The argument of the normal form consists of just a single value}%
  \fi
  \ifTXN@withinProsa
    \TXN@process@numerus@nostar@bis {#1}%
    \if \TXN@empty {TXN@numerus[#1]side@\TXN@theFolio}%
    \else
      \TXN@toks@a = {\numerus[#1]}%
      \ifx \empty \TXN@numerus@value 
        \TXN@toks@b = {{}}%
      \else
        \TXN@toks@b = \expandafter {\expandafter{\the\TXN@counter}}%
      \fi
      \edef \TXN@temp {\toks@ = {\the\TXN@toks@a \the\TXN@toks@b}}%
      \TXN@temp
      \if \TXN@num {TXN@numerus[#1]milestone} = \@ne  
         \TXN@save@command
      \fi
    \fi
  \else
    \TXN@process@numerus@nostar@bis {#1}%
  \fi
}
\def \TXN@process@numerus@nostar@bis #1{%
%<debug>  \TXN@trace [#1]\TXN@process@numerus@nostar@bis
  \count@ = \TXN@c@numerus{#1}%
  \edef \TXN@save@counter {\the\count@}%
  \ifx \empty \TXN@numerus@value 
    \TXN@def {TXN@numerus[#1]printing}{0}%
  \else
    \TXN@def {TXN@numerus[#1]printing}{1}%
    \ifx \empty \TXN@numerus@sign 
      \TXN@counter = \TXN@numerus@value \TXN@safe
      \TXN@def {TXN@numerus[#1]frozen}{0}%
    \else
      \TXN@counter = \TXN@c@numerus{#1}%
      \TXN@counter@a = \TXN@numerus@value \TXN@safe
      \TXN@sw@true
      \ifnum \TXN@counter@a = \z@
        \if -\TXN@numerus@sign
          \TXN@sw@false
        \fi
      \fi
      \ifTXN@sw
        \if -\TXN@numerus@sign
          \TXN@counter@a = -\TXN@counter@a
        \fi
        \advance \TXN@counter by \TXN@counter@a
        \TXN@def {TXN@numerus[#1]frozen}{0}%
      \else
        \TXN@def {TXN@numerus[#1]frozen}{1}%
      \fi
    \fi
    \TXN@sw@false
    \if \TXN@num {TXN@numerus[#1]milestone} = \z@  
      \TXN@sw@true
    \else
      \if \TXN@relax {TXN@numerus[#1]progressio}%
      \else
        \if \TXN@x {TXN@numerus[#1]progressio}\TXN@zero@progressio
          \TXN@sw@true
        \fi
      \fi
    \fi
    \ifTXN@sw
      \global \TXN@c@numerus{#1}= \TXN@counter
    \else
      \ifTXN@replay
        \global \TXN@c@numerus{#1}= \TXN@counter
      \fi
    \fi
    \ifnum \TXN@counter > \z@
      \if \TXN@num {TXN@numerus[#1]milestone} = \z@ 
        \TXN@caput@numerus {#1}%
      \else
        \ifTXN@replay
          \ifTXN@withinProsa
            \TXN@caput@numerus {#1}%
          \fi
        \fi
      \fi
    \fi
    \TXN@xdef {TXN@numerus[#1]previous}{}%
  \fi
}
%    \end{macrocode}
%  \subsubsection{Processing the argument of \TXN@cmd{numerus}}
%
%    \begin{macrocode}
\def \TXN@process@numerus@argument #1{%
  \gdef \TXN@numerus@value       {}%
  \gdef \TXN@numerus@second@value {}%
  \gdef \TXN@numerus@head        {}%
  \gdef \TXN@numerus@tail        {}%
  \gdef \TXN@numerus@separator   {}%
  \gdef \TXN@numerus@sign        {}%
  \gdef \TXN@numerus@secondsign  {}%
  \gdef \TXN@numerus@set         {}%
  \gdef \TXN@numerus@error       {}%
%    \end{macrocode}
%                 
% Check for special case
%
%    \begin{macrocode}
  \count@ = \z@
  \ifTXN@withinAd
    \TXN@process@numerus@argument@bis#1\TXN@nil
  \else
    \begingroup
      \def \value##1{\the\csname c@##1\endcsname}%
      \xdef \TXN@gtemp {#1}%
    \endgroup
    \expandafter
    \TXN@process@numerus@argument@bis\TXN@gtemp\TXN@nil
  \fi
}
%    \end{macrocode}
% Scan the argument. |\count@| is the token counter.
%    \begin{macrocode}
\def \TXN@process@numerus@argument@bis #1{%
  \advance \count@ by \@ne
  \let \next = \TXN@process@numerus@argument@bis
  \ifx \TXN@nil #1\relax
    \let \next = \TXN@process@numerus@argument@ter
  \else
    \def \TXN@temp {#1}%
    \ifx \empty \TXN@temp 
      \TXN@isdigitfalse
    \else
      \TXN@check@start@of@number{#1}%
    \fi
    \ifTXN@isdigit
      \ifx \empty \TXN@numerus@tail 
        \ifx \empty \TXN@numerus@separator 
          \xdef \TXN@numerus@value {\TXN@numerus@value#1}%
        \else
          \xdef \TXN@numerus@second@value {\TXN@numerus@second@value#1}%
        \fi
      \else
          \xdef \TXN@numerus@tail {\TXN@numerus@tail#1}%
      \fi
    \else
      \ifx \empty \TXN@numerus@value 
        \ifTXN@issign
          \ifx \empty \TXN@numerus@sign 
            \gdef \TXN@numerus@sign {#1}%
          \else
            \gdef \TXN@numerus@error {1}%
          \fi
        \else
          \ifx =#1\relax
            \ifnum \count@ = \@ne
              \ifTXN@withinAd
                \gdef \TXN@numerus@error {1}%
              \else
                \gdef \TXN@numerus@set {1}%
              \fi
            \else
              \xdef \TXN@numerus@head
                {\TXN@numerus@head\TXN@numerus@sign#1}%
            \fi
          \else
            \xdef \TXN@numerus@head
              {\TXN@numerus@head\TXN@numerus@sign#1}%
          \fi
          \ifx \empty \TXN@numerus@sign 
          \else
            \gdef \TXN@numerus@sign {}%
          \fi
        \fi
      \else
        \ifx \empty \TXN@numerus@tail 
          \ifx \empty \TXN@numerus@separator 
            \gdef \TXN@numerus@separator {#1}%
          \else
            \ifx \empty \TXN@numerus@second@value 
              \ifTXN@issign
                \ifx \empty \TXN@numerus@secondsign 
                  \gdef \TXN@numerus@secondsign {#1}%
                \else
                  \gdef \TXN@numerus@error {1}%
                \fi
              \else
                 \xdef \TXN@numerus@tail {\TXN@numerus@separator#1}%
                 \gdef \TXN@numerus@separator {}%
              \fi
            \else
              \xdef \TXN@numerus@tail {\TXN@numerus@tail#1}%
            \fi
          \fi
        \else
          \xdef \TXN@numerus@tail {\TXN@numerus@tail#1}%
        \fi
      \fi
    \fi
  \fi
  \next
}
%    \end{macrocode}
% Final checks
%    \begin{macrocode}
\def \TXN@process@numerus@argument@ter {%
  \ifx \empty \TXN@numerus@separator 
  \else
    \ifx \empty \TXN@numerus@second@value 
      \xdef \TXN@numerus@tail {%
        \TXN@numerus@separator \TXN@numerus@tail}%
      \gdef \TXN@numerus@separator {}%
    \fi
  \fi
  \ifx \empty \TXN@numerus@value 
    \ifx \empty \TXN@numerus@head 
    \else
%    \end{macrocode}
% If there is no value, a string is considered to be part of the tail.
%    \begin{macrocode}
      \xdef \TXN@numerus@tail {\TXN@numerus@head}%
      \xdef \TXN@numerus@head {}%
    \fi
  \else
    \ifnum  \TXN@numerus@value = \z@
%      \def \TXN@numerus@sign {+}%
    \fi
  \fi
  \ifx \empty \TXN@numerus@second@value 
  \else
    \ifnum \TXN@numerus@second@value = \z@
      \gdef \TXN@numerus@secondsign {+}%
    \fi
  \fi
}
%    \end{macrocode}
% \subsection{Attaching the line numbers}
%    \begin{macrocode}
\def \TXN@process@line@numbers {%
%<debug>  \TXN@trace \TXN@process@line@numbers
%    \end{macrocode}
% Loop through all the numbers
%    \begin{macrocode}
  \count@ = \m@ne 
  \loop
    \xdef \TXN@loop {\the\count@}%
  \ifnum \count@ < \TXN@numerus@max 
    \advance \count@ by \@ne
    \TXN@let \TXN@test = {TXN@numerus[\the\count@]side@\TXN@theFolio}%
    \ifx \empty \TXN@test 
    \else
      \ifnum \TXN@test < \z@
      \else
        \TXN@let \TXN@test = {TXN@numerus[\the\count@]first@value}%
        \ifx \empty \TXN@test 
          \expandafter
          \TXN@process@line@numbers@nostar \expandafter{\the\count@}%
        \else
          \expandafter
          \TXN@process@line@numbers@star \expandafter{\the\count@}%
        \fi
      \fi
    \fi
    \count@ = \TXN@loop
    \advance \count@ by \@ne 
  \repeat
}
%    \end{macrocode}
% \subsubsection{Normal form}
%    \begin{macrocode}
\def \TXN@numerus@pending {0}
\def \TXN@process@line@numbers@nostar #1{%
%<debug>  \TXN@trace [#1]\TXN@process@line@numbers@nostar
  \TXN@sw@false
  \if \TXN@empty {TXN@numerus[#1]classes@\TXN@theFolio}%
    \ifx \empty \TXN@line@class
      \ifTXN@withinVersus
        \TXN@process@line@numbers@check@versus {#1}%
      \else
        \TXN@sw@true
      \fi
    \fi
  \else
    \TXN@process@line@numbers@nostar@classes {#1}%
  \fi
  \ifTXN@sw
      \TXN@process@line@numbers@nostar@bis {#1}%
  \fi
}
%    \end{macrocode}
% Check if the line number should be printed for the line.
% If so, set |\TXN@sw|.
%    \begin{macrocode}
\def \TXN@process@line@numbers@check@versus #1{%
%<debug>  \TXN@trace [#1] \TXN@process@line@numbers@check@versus
  \TXN@sw@false
  \edef \TXN@temp {\@nameuse{TXN@numerus[#1]fragment@\TXN@theFolio}}%
  \@tempswatrue
  \ifdim \PTR@split@skip = \z@
    \ifdim \PTR@next@split@skip = \z@
      \@tempswafalse
    \fi
  \fi
  \if@tempswa
%    \end{macrocode}
% A fragment of a split line
%    \begin{macrocode}
    \if \TXN@option a\TXN@temp
      \TXN@sw@true
    \else
      \if \TXN@option f\TXN@temp
        \ifdim \PTR@split@skip = \z@
          \TXN@sw@true
        \fi
      \else
        \if \TXN@option l\TXN@temp
          \ifdim \PTR@next@split@skip = \z@
            \TXN@sw@true
          \fi
        \fi
      \fi
    \fi
  \else
    \ifx \empty \PTR@folded@line
      \TXN@sw@true
    \else
%    \end{macrocode}
% A folded line
%    \begin{macrocode}
      \if \TXN@option A\TXN@temp
        \TXN@sw@true
      \else
        \if \TXN@option F\TXN@temp
          \ifnum \PTR@folded@line = \@ne
            \TXN@sw@true
          \fi
        \else
          \if \TXN@option L\TXN@temp
            \ifnum \PTR@folded@line = \z@
              \TXN@sw@true
            \fi
          \fi
        \fi
      \fi
    \fi
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@process@line@numbers@nostar@classes #1{%
%<debug>  \TXN@trace [#1] \TXN@process@line@numbers@nostar@special
  \edef \TXN@temp {\@nameuse{TXN@numerus[#1]classes@\TXN@theFolio}}%
  \edef \TXN@temp@bis {\TXN@line@class}%
  \ifx \empty \TXN@temp@bis
    \def \TXN@temp@bis {t}%
  \fi
  \expandafter 
  \if \expandafter \TXN@option \TXN@temp@bis\TXN@temp
    \ifx \empty \TXN@line@class
      \ifTXN@withinVersus
        \TXN@process@line@numbers@check@versus {#1}%
      \else
        \TXN@sw@true
      \fi
    \else
      \TXN@sw@true
    \fi
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@process@line@numbers@nostar@bis #1{%
%<debug>  \TXN@trace [#1]\TXN@process@line@numbers@nostar@bis
  \if \TXN@empty {TXN@numerus[#1]progressio}%
    \let \TXN@progressio = \TXN@default@progressio
    \TXN@gdef {TXN@numerus[#1]index}{0}%
  \else
    \def\\{\noexpand\\}%
    \edef \TXN@progressio {\@nameuse {TXN@numerus[#1]progressio}}% 
    \def\\{}%
  \fi
  \TXN@get@progressio {#1}%
  \ifx \empty \TXN@line@increment 
    \PackageError {TEXNIKA}
      {Sanity check failed (\protect\TXN@line@increment #1)}
      {Please report the error to the author}%
  \fi  
  \ifnum \TXN@line@increment = \z@
  \else
    \TXN@process@line@numbers@nostar@ter #1\relax
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@process@line@numbers@nostar@ter #1{%
%<debug>  \TXN@trace [#1]\TXN@process@line@numbers@nostar@ter
  \@tempcnta = \TXN@c@numerus{#1}%
  \TXN@counter = \@tempcnta
  \if \TXN@empty {TXN@numerus[#1]previous@incr}%
  \else
    \TXN@assign \count@ = {TXN@numerus[#1]previous@incr}%
    \ifnum  \TXN@line@increment = \count@
    \else
      \count@ = \TXN@counter
      \advance \count@ by \m@ne
      \TXN@xdef {TXN@numerus[#1]previous}{\the\count@}%
    \fi
  \fi
  \TXN@xdef {TXN@numerus[#1]previous@incr}{\TXN@line@increment}%
  \if \TXN@empty {TXN@numerus[#1]previous}%
    \@tempcntb = \TXN@counter
    \divide \@tempcntb by \TXN@line@increment \TXN@safe
    \multiply \@tempcntb by \TXN@line@increment \TXN@safe
    \ifnum \@tempcntb = \TXN@counter 
      \advance \@tempcntb by -\TXN@line@increment
    \fi
  \else
    \TXN@assign \@tempcntb = {TXN@numerus[#1]previous}%
  \fi
  \ifnum \@tempcntb < \z@
    \TXN@make@object@numerus {#1}{n}%
    \TXN@move@to@marginalia {#1}{n}\TXN@object@numerus
    \TXN@assign \count@ = {TXN@numerus[#1]previous}%
    \ifdim \wd\TXN@object@numerus = \z@
      \advance \count@ by -1000000\relax
    \else
      \ifnum \count@ < \z@
        \@tempcnta = \z@
        \loop
        \ifnum \count@ < -1000000\relax
          \advance \count@ by 1000000\relax
          \advance \@tempcnta by \@ne
        \repeat
        \ifnum \@tempcnta > \z@
          \TXN@Warning* {The line number has been moved \MessageBreak
                        forward more than once}%
        \fi
        \count@ = -\count@
        \TXN@decr \TXN@numerus@pending
      \fi
    \fi
    \TXN@xdef {TXN@numerus[#1]previous}{\the\count@}%
  \else                                                        
    \TXN@process@line@numbers@nostar@quater #1\relax
  \fi
  \if \TXN@num {TXN@numerus[#1]frozen} = \z@
    \TXN@advance@line@counter {#1}%
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@process@line@numbers@nostar@quater #1{%
%<debug>  \TXN@trace [#1]\TXN@process@line@numbers@nostar@quater
  \advance \@tempcnta by -\@tempcntb
  \edef \TXN@line@displacement {\the\@tempcnta}%
  \@tempcnta = \TXN@line@displacement \TXN@safe
  \@tempcntb = \TXN@line@increment \TXN@safe
  \divide \@tempcnta by \@tempcntb 
  \multiply \@tempcnta by \@tempcntb
  \@tempcntb = \TXN@line@displacement \TXN@safe
  \ifnum \@tempcnta = \@tempcntb
    \TXN@xdef {TXN@numerus[#1]index}{\TXN@progressio@new@index}%
    \TXN@xdef {TXN@numerus[#1]previous}{\the\TXN@counter}%
    \if \TXN@num {TXN@numerus[#1]printing} = \z@
    \else
      \if \TXN@num {TXN@numerus[#1]printing} = \tw@
        \TXN@def {TXN@numerus[#1]printing}{1}%
      \else
        \TXN@make@object@numerus {#1}{n}%
        \TXN@move@to@marginalia {#1}{n}\TXN@object@numerus
        \ifdim \wd\TXN@object@numerus = \z@
          \if \TXN@num {TXN@numerus[#1]printing} = \@ne
            \TXN@xdef {TXN@numerus[#1]previous}{-\the\TXN@counter}%
            \TXN@incr \TXN@numerus@pending
          \fi
        \else
          \def \TXN@numerus@pending {0}%
        \fi
      \fi
    \fi
  \else
    \if \TXN@num {TXN@numerus[#1]printing} = \tw@
        \TXN@def {TXN@numerus[#1]printing}{1}%
    \fi
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@get@progressio #1{%
%<debug>  \TXN@trace [#1] \TXN@get@progressio
  \def \TXN@line@increment {}%
  \TXN@assign \@tempcnta = {TXN@numerus[#1]index}%
  \advance \@tempcnta by \@ne
  \@tempcntb = \z@
  \def\\##1{%
    \advance \@tempcntb by \@ne
    \ifnum \@tempcnta = \@tempcntb 
      \ifx <##1\relax 
        \@tempcnta = \@ne
      \else
        \ifnum ##1 = \@M 
          \advance \@tempcnta by \m@ne
        \fi
      \fi
    \fi
  }%
  \TXN@progressio
  \@tempcntb = \z@
  \def\\##1{%
    \advance \@tempcntb by \@ne
    \ifnum \@tempcnta = \@tempcntb 
      \edef \TXN@line@increment {##1}%
      \edef \TXN@progressio@new@index {\the\@tempcnta}%
    \fi
  }%
  \TXN@progressio
  \def\\{}%
}
%    \end{macrocode}
% \subsubsection{Starred form}
%    \begin{macrocode}
\def \TXN@process@line@numbers@star #1{%
%<debug>  \TXN@trace [#1]\TXN@process@line@numbers@star
  \TXN@sw@true
  \ifTXN@withinVersus
    \TXN@process@line@numbers@check@versus {#1}%
  \fi
  \ifTXN@sw
    \TXN@make@object@numerus {#1}{*}%
    \TXN@move@to@marginalia {#1}{*}\TXN@object@numerus
    \if \TXN@x {TXN@numerus[#1]progressio}\TXN@zero@progressio
    \else
      \TXN@advance@line@counter{#1}%
    \fi
    \TXN@gdef {TXN@numerus[#1]first@value}{}%  
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@advance@line@counter #1{%
   \TXN@caput@numerus {#1}%
   \global \advance \TXN@c@numerus{#1}by \@ne
}
%    \end{macrocode}
%  \subsection{Building a \TXN@cmd{numerus} object}
%    \begin{macrocode}
\def \TXN@make@object@numerus #1#2{%
%<debug>  \TXN@trace [#1]\TXN@make@object@numerus
  \def  \TXN@entity {numerus}%
  \TXN@get@object@field@width {#1}%
  \edef \TXN@flags {\@nameuse{TXN@numerus[#1]flagsModus@\TXN@theFolio}}%
  \ifx *#2\relax
    \edef \TXN@parm@i   {\csname TXN@numerus[#1]first@value\endcsname}%
    \edef \TXN@parm@ii  {\csname TXN@numerus[#1]tail\endcsname}%
    \edef \TXN@parm@iii {\csname TXN@numerus[#1]separator\endcsname}%
    \edef \TXN@parm@iv  {\csname TXN@numerus[#1]second@value\endcsname}%
    \edef \TXN@parm@v   {\csname TXN@numerus[#1]head\endcsname}%
  \else
    \edef \TXN@parm@i   {\the\TXN@counter}% 
    \edef \TXN@parm@ii  {}%
    \edef \TXN@parm@iii {}%
    \edef \TXN@parm@iv  {}%
    \edef \TXN@parm@v   {}%
  \fi
  \setbox \TXN@object@numerus = \hbox {%  
    \@nameuse {TXN@numerus[#1]Facies}%
      \TXN@parm@i
      \TXN@parm@ii
      \TXN@parm@iii
      \TXN@parm@iv
      \TXN@parm@v
  }%
%    \end{macrocode}
% Compute the width of the number's `tail' (for alignment).
%    \begin{macrocode}
  \ifx *#2\relax
    \setbox \z@ = \hbox {%  
      \@nameuse {TXN@numerus[#1]Facies}%
        {\TXN@parm@i}%
        \empty
        {\TXN@parm@iii}%
        {\TXN@parm@iv}%
        {\TXN@parm@v}%
    }%
    \dimen@ = \wd\TXN@object@numerus
    \advance \dimen@ by -\wd\z@
    \if \TXN@option \TXN@o@AlignedTail \TXN@flags
      \dimen@ = \z@
    \fi
  \else
    \dimen@ = \z@
  \fi
  \edef \TXN@numerus@tail@width {\the\dimen@}%
  \TXN@place@object@in@field \TXN@object@numerus
}
%    \end{macrocode}
% \section {The common code for \TXN@cmd{numerus} and \TXN@cmd{textus} objects} 
% \subsection {Setting the obiect within the field}
% Set |\TXN@numerus@field@width| or |\TXN@textus@field@width| to
% the field width or |\empty| if there is no field specification
% for this entity.
%    \begin{macrocode}
\newif \ifTXN@textus@zero@width
\def \TXN@get@object@field@width #1{%
%<debug>  \TXN@trace \TXN@get@object@field@width
  \if \TXN@empty {TXN@\TXN@entity[#1]field@\TXN@theFolio}%
    \TXN@def {TXN@\TXN@entity @field@width}{}%
  \else
    \begingroup
      \TXN@let \TXN@calc@exp = {TXN@\TXN@entity[#1]field@\TXN@theFolio}%
      \TXN@calc@offset
      \def \TXN@temp {textus}%
      \ifx \TXN@entity \TXN@temp
        \global \TXN@textus@zero@widthfalse
        \TXN@sw@false
        \if \TXN@option \TXN@o@FieldAutoWidth \TXN@textus@flags
          \TXN@sw@true
        \else
          \ifdim \dimen@i = \z@
            \TXN@sw@true
            \global \TXN@textus@zero@widthtrue
          \fi
        \fi
        \ifTXN@sw
          \TXN@get@object@field@width@bis {#1}%
          \global \advance \dimen@i by \dimen@iii 
        \fi
      \fi
    \endgroup
    \TXN@edef {TXN@\TXN@entity @field@width}{\the\dimen@i}%
  \fi
}
%    \end{macrocode}
% Returns the length of the longest line in |\dimen@i|
% We do all processing inside a box to avoid any side effects.
%    \begin{macrocode}
\newcommand {\TXN@skip@delimiter} [2] [1] {}
\newcommand {\TXN@skip@escesc} [1] [] {}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@get@object@field@width@bis #1{%
  \setbox \z@ = \vbox {%
    \let \Delimiter = \TXN@skip@delimiter
    \let \\= \TXN@skip@escesc
    \TXN@counter = #1\relax
    \global \dimen@iii = -\maxdimen 
    \TXN@exxxpandafter 
    \TXN@get@object@field@width@ter \TXN@textus@text\TXN@nil 
    \expandafter 
    \TXN@get@object@field@width@quater \the\toks@\\\TXN@nil\\%
  }%
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@get@object@field@width@ter #1\TXN@nil{%
  \toks@ = \expandafter{#1}%
%    \end{macrocode}
% In case the first line starts with [
%    \begin{macrocode}
  \toks@ = \expandafter{\expandafter\relax\the\toks@}%
} 
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@get@object@field@width@quater #1\\{%
  \ifx \TXN@nil #1\relax
  \else
    \TXN@get@object@field@width@quinquies #1\TXN@nil
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@get@object@field@width@quinquies #1#2\TXN@nil{%
  \ifx [#1\relax
    \toks@ = {}%
  \else
    \toks@ = {[]}%
  \fi
  \expandafter 
  \TXN@get@object@field@width@sexies \the\toks@#1#2\TXN@nil
}
%    \end{macrocode}
% Ignore anything between [ and ] (the |\\| optional parameter).
%    \begin{macrocode}
\def \TXN@get@object@field@width@sexies [#1]#2\TXN@nil{%
  \setbox \z@ = \hbox {\@nameuse{TXN@textus[\TXN@c]Facies}{#2}}%
  \ifdim \wd\z@ > \dimen@iii 
    \global \dimen@iii = \wd\z@
  \fi
  \expandafter \TXN@get@object@field@width@quater
}
%    \end{macrocode}
% Places the object |#1| (of class |\TXN@entity|) at the appropriate
% position inside the corresponding field, if any.
%    \begin{macrocode}
\def \TXN@place@object@in@field #1{%
%<debug>  \TXN@trace \TXN@place@object@in@field
  \if \TXN@empty {TXN@\TXN@entity @field@width}%
  \else
    \TXN@let \TXN@object = {TXN@object@\TXN@entity}%
    \TXN@assign \dimen@ = {TXN@\TXN@entity @field@width}%
    \ifdim \dimen@ > \z@
      \advance \dimen@ by -\wd#1\relax
      \ifdim \dimen@ > \z@
        \dimen@@ = \dimen@ 
        \divide \dimen@@ by \tw@
        \def \TXN@temp {}%
        \def \TXN@temp@bis {}%
        \if \TXN@option \TXN@o@RangedLeft \TXN@flags
          \def \TXN@temp@bis {\kern \dimen@@}%
          \if \TXN@option \TXN@o@RangedRight \TXN@flags         
            \def \TXN@temp {\kern \dimen@@}% LR = centred
          \else
            \def \TXN@temp@bis {\kern \dimen@}%
          \fi
        \else
          \if \TXN@option \TXN@o@RangedRight \TXN@flags         
            \def \TXN@temp {\kern \dimen@}%
          \fi
        \fi
        \setbox \TXN@object = 
          \hbox {\TXN@temp\unhbox \TXN@object\TXN@temp@bis}%
      \fi
    \fi
  \fi
}
%    \end{macrocode}
% \subsection {Moving the object to the \TXN@cmd{marginalia} box}
%    |#1|\  the subclass identifier
%    |#2|\  the object type ('t' = textus, 'n' = numerus, '*' = numerus*)
%    |#3|\  the box containing the object
%    \begin{macrocode}
\def \TXN@move@to@marginalia #1#2#3{%
%<debug>  \TXN@trace \TXN@move@to@marginalia
%    \end{macrocode}
% Set the entity name and get the relevant flags
%    \begin{macrocode}
  \ifx t#2\relax
    \def  \TXN@entity {textus}%
    \TXN@get@textus@flags {#1}%
    \edef \TXN@flags {\TXN@textus@flags}%
  \else
    \def  \TXN@entity {numerus}%
    \edef \TXN@flags {\@nameuse {TXN@numerus[#1]flagsModus@\TXN@theFolio}}%
  \fi
%    \end{macrocode}
% If alignment is unspecified, set the default for the entity.
%    \begin{macrocode}
  \if \TXN@option \TXN@o@AlignedRight \TXN@flags
  \else
    \if \TXN@option \TXN@o@AlignedLeft \TXN@flags
    \else
      \if \TXN@option \TXN@o@AlignedCentre \TXN@flags
      \else
        \ifx t#2\relax
          \edef \TXN@flags {\TXN@o@AlignedLeft\TXN@flags}%
        \else
          \edef \TXN@flags {\TXN@o@AlignedRight\TXN@flags}%
        \fi
      \fi
    \fi
  \fi
%    \end{macrocode}
% Set |\TXN@dim@a| equal to the displacement from the left margin,
% |\dimen@@| and |\dimen@ii| to the box left and right boundaries.
%    \begin{macrocode}
  \TXN@get@Locus {\TXN@entity[#1]}{#2}%
  \TXN@dim@a = \dimen@
  \dimen@@ = \TXN@dim@a
  \ifx t#2\relax
  \else
    \ifdim \TXN@dim@a > .5\TXN@measure
      \setbox\z@ = \hbox {\@nameuse{TXN@numerus[#1]SpatiumAnte}}%
      \advance \dimen@@ by -\wd\z@
    \fi
  \fi
  \dimen@ii = \TXN@dim@a
  \advance \dimen@ii by \wd#3\relax
%    \end{macrocode}
% Align the object
%    \begin{macrocode}
  \if \TXN@option \TXN@o@AlignedCentre \TXN@flags
    \advance \TXN@dim@a by -.5\wd#3\relax      
    \advance \dimen@@   by -.5\wd#3\relax      
    \advance \dimen@ii  by -.5\wd#3\relax      
  \else
    \if \TXN@option \TXN@o@AlignedRight \TXN@flags
      \dimen@ii = \dimen@@
      \advance \dimen@@ by -\wd#3\relax
      \ifx t#2\relax
      \else
        \advance \TXN@dim@a by \TXN@numerus@tail@width
      \fi
    \fi
  \fi
%    \end{macrocode}
% For the special case of |\excessus| followed by leaders, we
% must record the position of the right boundary.
%    \begin{macrocode}
  \ifnum #1 = \TXN@e \TXN@safe
    \ifTXN@leaders
      \gdef \TXN@excessus@leaders {\the\dimen@ii}%
    \fi
  \fi
%    \end{macrocode}
% Check for overlapping text. |\TXN@line@fields|, a \textit{Simple List},
% holds the left/right boundaries for each field in the line and we
% just `execute' the list after redefining |\\| appropriately.
%    \begin{macrocode}
  \TXN@sw@false
  \@tempswatrue
  \ifx t#2\relax
    \ifnum #1 = \TXN@e \TXN@safe
      \@tempswafalse                % no check for excessus
    \fi
  \fi
  \if@tempswa
    \begingroup
    \def \\##1{\TXN@temp ##1\TXN@nil}%
    \def \TXN@temp ##1,##2\TXN@nil{%
      \ifdim \dimen@@ > ##1\relax
        \ifdim \dimen@@ < ##2\relax
          \TXN@sw@true
        \fi
      \fi
      \ifdim \dimen@ii > ##1\relax
        \ifdim \dimen@ii < ##2\relax
          \TXN@sw@true
        \fi
      \fi
      \ifdim \dimen@@ < ##1\relax
        \ifdim \dimen@ii > ##1\relax
          \TXN@sw@true
        \fi
      \fi
      \ifdim \dimen@@ < ##2\relax
        \ifdim \dimen@ii > ##2\relax
          \TXN@sw@true
        \fi
      \fi
    }%
    \TXN@line@fields
    \endgroup
  \fi
%    \end{macrocode}
% In case of overlapping:\\
% |\textus| and |\numerus*| are printed, with a warning \\
% |\numerus| is skipped, but within \textit{Versus} we first check
% for the special case of a stage direction with the `r' option and
% if there is enough space between the end of the text proper and
% the SD we re-assemble the line shifting the SD to the left to
% make room for the number.
% 
%    \begin{macrocode}
  \ifTXN@sw
    \ifTXN@withinVersus 
      \ifx t#2\relax
      \else
        \ifdim \PTR@hfill@right > \z@
          \setbox\z@ = \hbox {\@nameuse{TXN@numerus[#1]SpatiumAnte}}%
          \dimen@ = \wd\z@
          \advance \dimen@ by \dimen@ii
          \advance \dimen@ by - \dimen@@
          \ifdim \PTR@hfill@right > \dimen@
            \TXN@shift@SD 
          \fi
        \fi
      \fi
    \fi
  \fi
  \ifTXN@sw
    \@tempswatrue
    \ifTXN@withinVersus
      \ifx empty \PTR@auto@mode
      \else
        \ifnum \TXN@pass = \@ne
          \@tempswafalse
        \fi
      \fi
    \fi
    \ifx t#2\relax
      \if@tempswa
        \TXN@get@subclass@name \textus {#1}%
        \TXN@Warning* {An object of subclass \@backslashchar\TXN@gtemp\space
                       overlaps some text}%
      \fi
    \else
      \ifx n#2\relax
        \ifdim \TXN@dim@a < .5\TXN@measure
          \if@tempswa
            \TXN@get@subclass@name \numerus {#1}%
            \TXN@Warning* {An object of subclass \@backslashchar\TXN@gtemp\space
                           overlaps some text}%
          \fi
        \else
          \wd#3 = \z@
        \fi
      \else
        \if@tempswa
          \TXN@get@subclass@name \numerus {#1}%
          \TXN@Warning* {An object of subclass \@backslashchar\TXN@gtemp*
                         overlaps some text}%
        \fi
      \fi
    \fi
  \else
    \edef \TXN@temp {\the\dimen@@,\the\dimen@ii}%
    \TXN@SimpleList@append \TXN@line@fields \TXN@temp
    \ifnum #1 = \TXN@e \TXN@safe
      \global \TXN@leading@space = \dimen@@ \TXN@safe 
      \xdef \TXN@line@length {\the\dimen@ii}%
    \fi
  \fi
%    \end{macrocode}
% Put the object into the \textit{marginalia} box
%    \begin{macrocode}
  \ifdim \wd#3 = \z@
  \else
    \if \TXN@option \TXN@o@AlignedRight \TXN@flags
      \setbox \TXN@marginalia = \hbox to \z@ {\unhbox \TXN@marginalia  
        \hbox to \z@ {\hss \copy#3\kern -\TXN@dim@a}%
      }%
    \else
      \setbox \TXN@marginalia = \hbox to \z@ {\unhbox \TXN@marginalia  
        \hbox to \z@ {\kern \TXN@dim@a \copy#3\hss}%
      }%
    \fi
  \fi
}
%    \end{macrocode}
% This is the special case of a line ending with a |\[r]| stage direction.
% We unbox and re-assemble the line, shifting the SD to the left.
%    \begin{macrocode}
\def \TXN@shift@SD {%
  \TXN@sw@false
  \begingroup
    \leavevmode \kern \maxdimen      % `sentinel' to stop the backward search
    \unhcopy \PTR@box@full@line
    \setbox \z@ = \null
    \TXN@counter@a = 10              % to prevent looping
    \TXN@shift@SD@bis
    \global \setbox \@ne = \box \z@ 
  \endgroup
  \setbox \PTR@box@full@line = \box \@ne 
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@shift@SD@bis {%
  \ifnum \TXN@counter@a = \z@
      \PackageError {TEXNIKA}
        {This can't happen (2)}
        {Please report the error to the author}%
  \else
    \advance \TXN@counter@a by \m@ne
  \fi
  \let \next = \TXN@shift@SD@bis
  \setbox \tw@ = \lastbox
  \ifhbox \tw@
    \setbox \z@ = \hbox {\box \tw@ \unhbox \z@}%
  \else
    \TXN@skip@a = \the\lastskip \TXN@safe
    \unskip
    \ifdim \TXN@skip@a > \z@skip
      \setbox \z@ = \hbox {\hskip \the\lastskip \unhbox \z@}%
    \else
      \TXN@counter = \the\lastpenalty \TXN@safe
      \unpenalty
      \ifnum \TXN@counter < \z@
        \TXN@counter = -\TXN@counter
      \fi
      \ifnum \TXN@counter > \z@
        \setbox \z@ = \hbox {\penalty \the\lastpenalty \unhbox \z@}%
      \else
        \dimen@@ = \the\lastkern \TXN@safe
        \unkern
        \ifdim \dimen@@ = \maxdimen  % the `sentinel'
          \let \next = \relax
        \else
          \ifdim \dimen@@ < \z@
            \dimen@@ = -\dimen@@
          \fi
          \ifdim \dimen@@ > \z@ 
            \ifdim \dimen@@ = \PTR@hfill@right \TXN@safe
              \advance \dimen@@ by -\dimen@
              \gdef \PTR@hfill@right {\z@}%
            \fi
            \setbox \z@ = \hbox {\kern \dimen@@ \unhbox \z@}%
          \fi
        \fi
      \fi
    \fi
  \fi
  \next
}
%    \end{macrocode}
%  
%  \section{The \TXN@cmd{titulus} class}
%  \subsection{Processing the \TXN@cmd{titulus} command}
%
%    \begin{macrocode}
\newcommand {\titulus} {%
  \ifx \empty \TXN@attribute@name 
    \expandafter \TXN@titulus
  \else
    \def \TXN@subclass@name {titulus}%
    \def \TXN@subclass@number {x}%
    \def \TXN@temp {TXN}%
    \expandafter \TXN@attribute@set
  \fi
}
\let \titulum = \titulus
\let \tituli = \titulus
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand{\TXN@esc@esc@break}[1][\relax]{%
  \par
  \TXN@sw@false
  \ifx \relax #1\relax
    \ifx \@undefined \TXN@SpatiumInfraEscEsc
    \else
      \toks@ = \expandafter {\TXN@SpatiumInfraEscEsc}%
      \TXN@sw@true
    \fi
  \else
    \toks@ = {#1}%
    \TXN@sw@true
  \fi
  \ifTXN@sw
    \expandafter \spatium \expandafter {\the\toks@}%
  \fi
}
\newcommand{\TXN@esc@esc@break@noop}[1][]{\hbadness \@M\penalty -\@M}
%    \end{macrocode}
%
%    \begin{macrocode}
\newif \ifTXN@titulus@starred
\newif \ifTXN@was@withinVersus
\newif \ifTXN@was@lineating
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@titulus {%
  \@ifstar {\TXN@titulus@starredtrue\TXN@titulus@bis}
           {\TXN@titulus@starredfalse\TXN@titulus@bis}%
}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand{\TXN@titulus@bis}[1][0]{%
%<debug>  \TXN@trace \TXN@titulus@bis
  \TXN@counter = #1\relax
  \edef \TXN@titulus@flags {\@nameuse{TXN@titulus[#1]flags}%
                            \@nameuse{TXN@titulus[#1]flagsModus}}%
  \if \TXN@empty {TXN@titulus[\TXN@c]Facies}%
    \expandafter \TXN@titulus@sexies
  \else
    \expandafter \TXN@titulus@ter
  \fi
}
\def \TXN@titulus@ter {%
%    \end{macrocode}
% If the object occurs within \textit{Versus}, we close the domain; then,
% id numbering is active for this class is active, we switch to \textit{Prosa}.
% If the object occurs within \textit{Prosa}, we remain within the domain.
%    \begin{macrocode}
%  \ifTXN@withinFaciesStrophae
%  \else
    \TXN@was@withinVersusfalse
    \ifTXN@withinVersus
        \TXN@was@withinVersustrue
    \else
      \ifTXN@withinProsa
        \ifTXNl@lineating
          \ifhmode
            \par % for lineate 
          \fi
        \else
          \endgraf
        \fi
      \else
        \endgraf
      \fi
    \fi
%  \fi
%  \ifTXN@withinFaciesStrophae
%  \else
    \ifTXN@was@withinVersus
      \if \TXN@option T\TXN@numbered@classes
        \prosa
      \else
        \toks@ = \everypar
        \edef \TXN@titulus@everypar {\the\toks@}%
        \everypar = {}%
        \TXN@normalCR
      \fi
    \fi
%  \fi
  \TXN@was@lineatingfalse
  \ifTXNl@lineating
    \TXN@was@lineatingtrue
    \TXNl@lineate \relax
  \fi
%    \end{macrocode}
%
%    \begin{macrocode}
  \if \TXN@option \TXN@o@NoArgument \TXN@titulus@flags
    \expandafter \TXN@titulus@quinquies
  \else
      \expandafter \TXN@titulus@quater
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@titulus@quinquies {\TXN@titulus@quater \relax}% 
%    \end{macrocode}
% The special case of an empty Facies
%    \begin{macrocode}
\long\def \TXN@titulus@sexies #1{%
  \if \TXN@empty {TXN@titulus[\TXN@c]SpatiumSupra}%
  \else
    \expandafter
    \TXN@spatium@vertical \csname TXN@titulus[\TXN@c]SpatiumSupra\endcsname
  \fi
  \if \TXN@empty {TXN@titulus[\TXN@c]Caput}%
  \else
    \TXN@caput@titulus {#1}%
  \fi
  \if \TXN@empty {TXN@titulus[\TXN@c]SpatiumInfra}%
  \else
    \expandafter
    \TXN@spatium@vertical \csname TXN@titulus[\TXN@c]SpatiumInfra\endcsname
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\long\def \TXN@titulus@quater #1{% 
%<debug>  \TXN@trace \TXN@titulus@ter
  \def \TXN@entity {titulus}%
  \def \TXN@line@class {T}%
  \expandafter
  \TXN@spatium@vertical \csname TXN@titulus[\TXN@c]SpatiumSupra\endcsname
  \if \TXN@empty {TXN@titulus[\TXN@c]Caput}%
  \else
    \TXN@caput@cleanup
  \fi
  \begingroup
  \if \TXN@empty {TXN@titulus[\TXN@c]Forma}%
    \TXN@style@centered
  \else
    \TXN@style@setfalse
    \@nameuse {TXN@titulus[\TXN@c]Forma}%
    \ifTXN@style@set
    \else
      \TXN@style@centered
    \fi
  \fi
  \ifTXN@centrefinal
    \global \setbox \TXN@vbox = \vbox \bgroup 
  \fi
    \parindent = \z@
    \parskip = \z@
    \everypar = {}%
    \ifTXN@centrefinal
      \let \\= \TXN@esc@esc@break@noop
    \else
      \let \\= \TXN@esc@esc@break
    \fi
    \hsize = \linewidth
    \ifTXN@titulus@starred
      \hsize = \textwidth
    \else
      \TXN@assign \TXN@dim@a =
        {TXN@textus[\TXN@theTextus]offset@\TXN@theFolio}%
      \advance \leftskip by \TXN@dim@a
    \fi
    \TXN@withinSDtrue
    \if \TXN@option \TXN@o@Unhyphenated \TXN@titulus@flags
      \pretolerance \@M
    \else
      \pretolerance 100 %
    \fi
    \leavevmode
    \def \TXN@titulus@parm {#1}% 
    \@nameuse {TXN@titulus[\TXN@c]Facies}\TXN@titulus@parm
    \global \TXN@baselineskip = \baselineskip \strut
    \par
    \ifTXN@centrefinal
      \egroup
   \fi
  \endgroup
  \xdef \TXN@prevgraf {\the\prevgraf}%
  \ifTXN@centrefinal
    \global \TXN@centrefinalfalse
    \leavevmode
    \TXN@dim@a = \wd\TXN@vbox
    \loop
    \ifvbox \TXN@vbox 
       \setbox\tw@ = \vbox{%
         \vbadness = \@M
         \splittopskip = \z@
         \global \setbox \@ne = \vsplit \TXN@vbox to \TXN@baselineskip
         \global \setbox \TXN@vbox = \box \TXN@vbox
         \unvbox \@ne \global \setbox \@ne = \lastbox
       }%
       \setbox \TXN@hbox = \box \@ne
       \TXN@sw@false
       \ifvbox \TXN@vbox
         \ifnum \TXN@prevgraf = \tw@
           \TXN@sw@true
         \fi
       \else
         \TXN@sw@true
       \fi
       \ifTXN@sw
         \setbox \z@ = \hbox {\unhbox \TXN@hbox \unskip \unskip \unpenalty}%
         \dimen@ = \TXN@dim@a
         \advance \dimen@ by -\leftskip
         \advance \dimen@ by -\rightskip
         \advance \dimen@ by -\wd\z@
         \divide \dimen@ by \tw@
         \dimen@@ = \dimen@
         \advance \dimen@@ by -\leftskip
         \advance \dimen@ by -\rightskip
         \setbox \TXN@hbox = \hbox {\kern \dimen@@ \box \z@ \kern \dimen@}%
       \fi
       \TXN@assign \dimen@ = {TXN@textus[\TXN@theTextus]offset@\TXN@theFolio}%
       \moveright \dimen@ \box \TXN@hbox \par 
       \ifvbox \TXN@vbox \leavevmode \fi
    \repeat
  \fi
  \ifTXN@was@lineating
    \TXNl@lineate \TXN@process@line
  \fi
  \def \TXN@line@class {}%
  \TXN@withinSDfalse
  \if \TXN@empty {TXN@titulus[\TXN@c]Caput}%
  \else
    \TXN@caput@titulus {#1}%
  \fi
  \expandafter
    \TXN@spatium@vertical \csname TXN@titulus[\TXN@c]SpatiumInfra\endcsname 
%    \end{macrocode}
%
%    \begin{macrocode}
  \ifTXN@bad@titulus
    \TXN@counter = \TXN@warnings@level \TXN@safe
    \def \TXN@warnings@level {\@ne}%
    \TXN@Warning {The \protect\titulus\space object cannot be positioned
                  properly}%
    \def \TXN@warnings@level {\the\TXN@counter}%
  \fi
%    \end{macrocode}
% We restore the initial state
%    \begin{macrocode}
  \ifTXN@was@withinVersus
    \PTR@par@startedfalse
    \if \TXN@option T\TXN@numbered@classes
      \endprosa
    \else
      \everypar = \expandafter {\TXN@titulus@everypar}%
      \TXN@activeCR  
      \TXN@exxxpandafter \ignorespaces
    \fi
  \fi
}
%    \end{macrocode}
%  
%  \section{The \TXN@cmd{spatium} class}
%  \subsection{Processing the \TXN@cmd{spatium} command}
%
%    \begin{macrocode}
\def \spatium {%
%<debug> \TXN@trace \spatium 
  \@ifstar {\xdef \TXN@spatium@flag{\TXN@o@SpatiumStar}\TXN@spatium@def}
           {\gdef \TXN@spatium@flag{}\TXN@spatium@def}%
}
\let \spatii = \spatium
\def \TXN@spatium@def {%
  \ifx \empty \TXN@attribute@name 
    \expandafter \TXN@spatium
  \else
    \def \TXN@subclass@name {spatium}%
    \def \TXN@subclass@number {x}%
    \def \TXN@temp {TXN}%
    \expandafter \TXN@attribute@set
  \fi
}
\newcommand \TXN@spatium [1][0]{%
%<debug> \TXN@trace \TXN@spatium 
  \edef \TXN@flags {\@nameuse {TXN@spatium[#1]flags}}%
  \if \TXN@option \TXN@o@NoFacies \TXN@flags
    \expandafter \TXN@spatium@nofacies
  \else
    \endgraf
    \if \TXN@option \TXN@o@NoArgument \TXN@flags
      \edef \TXN@temp {\@nameuse {TXN@spatium[#1]Facies}}%
      \TXN@spatium@vertical {\TXN@temp}%
    \else
      \TXN@counter = #1\relax
      \TXN@exxxpandafter \TXN@spatium@bis
    \fi
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@spatium@nofacies #1{}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@spatium@bis #1{%
  \def \TXN@parm@i {#1}%
  \edef \TXN@temp {\@nameuse {TXN@spatium[\TXN@c]Facies}\TXN@parm@i}%
  \expandafter \TXN@build@spatium@list \expandafter {\TXN@temp}%
  \TXN@spatium@vertical {\TXN@L@spatium}%
}
%    \end{macrocode}
% \subsection {Processing the argument of a spacing attribute} 
% The argument is converted to the \textit{NameList} expected by
% |\TXN@do@spatium|.
%
% The list prototype
%    \begin{macrocode}
\TXN@NameList \TXN@NameList@spatium 
              {\TXN@s@flags \TXN@s@glue \TXN@s@penalty \TXN@s@exclude}
%    \end{macrocode}
% and the actual list to hold the result of the conversion
%    \begin{macrocode}
\edef \TXN@L@spatium {\TXN@NameList@spatium}%
%    \end{macrocode}
%    \begin{macrocode}
\def \TXN@build@spatium@list #1{%
  \TXN@build@spatium@check #1\TXN@nil
}
%    \end{macrocode}
% Check if the argument is a subclass name
%    \begin{macrocode}
\def \TXN@build@spatium@check #1#2\TXN@nil {%
  \@ifmtarg {#2}
    {\TXN@build@spatium@check@subclass {#1}}
    {\TXN@build@spatium@list@normal {#1#2}}%
}
\def \TXN@build@spatium@check@subclass #1{%
  \TXN@get@subclass@number \spatium #1\relax
  \ifnum \@tempcnta = \m@ne
    \TXN@build@spatium@list@normal {#1}%
  \else
    \edef \TXN@flags {\@nameuse{TXN@spatium[\the\@tempcnta]flags}}%
    \if \TXN@option \TXN@o@NoArgument \TXN@flags
       \edef \TXN@L@spatium {%
         \csname TXN@spatium[\the\@tempcnta]Facies\endcsname}%
    \else
      \PackageError {TEXNIKA}
      {The \protect\spatium\space subclass \protect#1 
       cannot be used\MessageBreak
       as the argument for an attribute}
      {The \protect\Facies\space attribute for the \protect#1 subclass
       \MessageBreak contains a reference to a parameter}%
    \fi
  \fi
}
%    \end{macrocode}
% Normal argument
%    \begin{macrocode}
\def \TXN@build@spatium@list@normal #1{%
%<debug> \TXN@trace \TXN@build@spatium@list@normal 
  \edef \TXN@flags {\TXN@spatium@flag}%
  \def \TXN@glue {\relax}%
  \def \TXN@penalty {\relax}%
  \def \TXN@exclude {\relax}%
  \TXN@trim {#1}%
  \expandafter \TXN@build@spatium@list@bis \the\TXN@trimmed\TXN@nil
  \ifTXN@sw
      \TXN@set \TXN@L@spatium.\TXN@s@flags   \TXN@flags
      \TXN@set \TXN@L@spatium.\TXN@s@glue    \TXN@glue
      \TXN@set \TXN@L@spatium.\TXN@s@penalty \TXN@penalty
      \TXN@set \TXN@L@spatium.\TXN@s@exclude \TXN@exclude
  \else
    \PackageError{TEXNIKA}%
      {Invalid \protect\spatium argument}
      {}%
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@build@spatium@list@bis #1\TXN@nil{%
  \global\toks@i = {}%
  \begingroup
    \def \penalty ##1\TXN@nil{0pt\global\toks@i={##1}}%
    \setbox \z@ = \hbox {\hskip #1\TXN@nil}%
    \def \penalty ##1\TXN@nil{}%
    \xdef \TXN@gtemp {#1\TXN@nil}%
  \endgroup
  \edef \TXN@glue {\TXN@gtemp}%
  \def \TXN@temp { }%
  \ifx \empty \TXN@glue 
    \def \TXN@glue {\relax}%
  \else
    \ifx \TXN@glue \TXN@temp
      \def \TXN@glue {\relax}%
    \fi
  \fi
  \edef \TXN@temp {\the\toks@i}%
  \ifx \empty \TXN@temp
  \else
    \expandafter \TXN@build@spatium@list@penalty \the\toks@i \TXN@nil
  \fi
  \TXN@sw@true
  \ifx \TXN@glue \TXN@penalty
    \if \TXN@option \TXN@o@SpatiumExclude \TXN@flags
    \else
      \TXN@sw@false
    \fi
  \else
    \ifx \TXN@glue \TXN@safe
    \else
      \expandafter \TXN@check@if@glue \TXN@glue\TXN@nil
    \fi
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@build@spatium@list@penalty #1#2\TXN@nil{%
  \ifx (#1\relax
    \TXN@build@spatium@list@penalty@par #2\relax
  \else
    \ifx [#1\relax
      \TXN@build@spatium@list@penalty@bracket #2\relax
    \else
      \def \TXN@penalty {#1#2}%
    \fi
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@build@spatium@list@penalty@par #1){%
  \edef  \TXN@flags {\TXN@flags(x}%
  \toks@ = {#1}%
  \TXN@build@spatium@list@penalty@exclude
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@build@spatium@list@penalty@bracket #1]{%
  \edef  \TXN@flags {\TXN@flags \TXN@o@SpatiumExclude
                                \TXN@o@SpatiumExcludeEject}%
  \toks@ = {#1}%
  \TXN@build@spatium@list@penalty@exclude
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def  \TXN@build@spatium@list@penalty@exclude {%
  \expandafter \TXN@check@if@glue \the\toks@ \TXN@nil
  \ifTXN@sw
    \edef  \TXN@flags {\TXN@o@SpatiumExcludeDim\TXN@flags}%
  \fi
  \edef \TXN@exclude {\the\toks@}%
  \def \TXN@penalty {\relax}%
}
%    \end{macrocode}
%  \subsection{Instancing the \TXN@cmd{spatium} object}
%    \begin{macrocode}
\def \TXN@spatium@vertical #1{%
%<debug> \TXN@trace \TXN@spatium@vertical
%<debug> \TXN@trace@spatium {#1}%
  \def \TXN@glue {\z@}%
  \ifx \empty #1\relax
  \else
    \ifx \relax#1\relax
    \else
      \ifhmode
        \def \TXN@temp {#1}%
        \PackageError{TEXNIKA}%
           {This can't happen (1).}
           {Please report the error to the author}%
      \fi
      \ifTXN@withinVersus
        \global \TXN@after@Spatiumtrue
      \fi
      \TXN@spatium@vertical@bis #1\relax
    \fi
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@spatium@vertical@bis #1{%
  \TXN@get #1.\TXN@s@flags   \TXN@flags
  \TXN@get #1.\TXN@s@glue    \TXN@glue
  \TXN@get #1.\TXN@s@penalty \TXN@penalty
  \TXN@get #1.\TXN@s@exclude \TXN@exclude
  \ifnum \TXN@active@areas > \z@
    \ifx \TXN@glue \TXN@safe
    \else
      \skip@ = \TXN@glue \TXN@safe
      \dimen@ = \skip@
      \edef \TXN@glue {\the\dimen@}%
    \fi
  \fi
  \if \TXN@option \TXN@o@SpatiumExclude \TXN@flags
%    \end{macrocode}
% To force the recent contributions onto the main page
%    \begin{macrocode}
    \begingroup
      \parskip = \z@
      \endgraf
    \endgroup
    \ifdim \pagetotal > \pagegoal
    \else
      \if \TXN@option \TXN@o@SpatiumExcludeDim \TXN@flags
        \dimen@ = \TXN@exclude
      \else
        \dimen@ = \TXN@exclude \pagegoal 
      \fi
      \advance \dimen@ by \pagetotal
      \advance \dimen@ by -\pageshrink
      \ifdim \dimen@ > \pagegoal 
        \dimen@@ = \pagefilstretch
        \advance \dimen@@ by \pagefillstretch
        \advance \dimen@@ by \pagefilllstretch
        \ifdim \dimen@@ = \z@
          \if \TXN@option \TXN@o@SpatiumExcludeEject \TXN@flags
            \newpage
            \global \NewPagetrue
            \def \TXN@glue {\relax}%
          \else
            \dimen@@ = \pagegoal
            \advance \dimen@@ by -\pagestretch
            \advance \dimen@@ by -\pagetotal
            \ifdim \dimen@@ > \z@
              \vskip \dimen@@
            \fi
            \penalty -\@M
          \fi
        \fi
      \fi
    \fi
  \fi
%    \end{macrocode}
%
%    \begin{macrocode}
  \ifx \TXN@glue \TXN@safe
  \else
    \if \TXN@option \TXN@o@SpatiumStar \TXN@flags
      \vspace* {\TXN@glue}%
    \else
      \addvspace {\TXN@glue}%
    \fi
    \ifnum \TXN@active@areas > \z@
      \TXN@process@area@spatium {\TXN@glue}%
    \fi
  \fi
  \ifx \TXN@penalty \TXN@safe
  \else
    \ifnum \TXN@penalty = -\@M\relax 
      \vfill
    \fi
    \penalty  \TXN@penalty
  \fi
}
%    \end{macrocode}
% \section{Domain switching} 
%
% All switching is funnelled through these two macros (the
% parameter is 1 for \textit{versus}, 2 for \textit{prosa}).
% This allows easy nesting of domains and avoids the overhead
% of unnecessary switching in sequences like\\
%        |\versus \begin{versus} \end{versus} \endversus|\\
% At the end of the document, we check that domains are properly
% nested.
%
% To keep track of domains, we use a simple stack with the usual
% functions for pushing/popping an entry and inspecting the
% top entry.
%    \begin{macrocode}
\def \TXN@domain@stack {[0,0]}
\def \TXN@empty@domain@stack {[0,0]}
%    \end{macrocode}
%    \begin{macrocode}
\def \TXN@domain@push #1{%
  \edef \TXN@domain@stack {[#1,\the\inputlineno]\TXN@domain@stack}}
%    \end{macrocode}
%    \begin{macrocode}
\def \TXN@domain@pop {%
  \expandafter \TXN@domain@pop@bis \TXN@domain@stack\TXN@nil}
\def \TXN@domain@pop@bis [#1]#2\TXN@nil{%
  \edef \TXN@domain@stack {#2}}
%    \end{macrocode}
%    \begin{macrocode}
\def \TXN@domain@top {%
  \expandafter \TXN@domain@top@bis \TXN@domain@stack \TXN@nil}
\def \TXN@domain@top@bis [#1]#2\TXN@nil{%
   \TXN@domain@top@ter #1\TXN@nil}
\def \TXN@domain@top@ter #1,#2\TXN@nil{%
  \edef \TXN@domain@stack@top {#1}%
  \edef \TXN@domain@stack@top@line {#2}}
%    \end{macrocode}
%    \begin{macrocode}
\def \TXN@domain@error #1{%
      \PackageError {TEXNIKA}
        {#1}
        {Run LaTeX to completion and look at the final\MessageBreak
         error message about bad domain nesting: it may\MessageBreak
         give you a clue about the source of the trouble.} 
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@get@domain@stack {%
   \toks@ = {}%
   \loop
     \TXN@domain@top
   \ifnum \TXN@domain@stack@top > \z@
     \edef \TXN@temp {\ifnum \TXN@domain@stack@top = \@ne
                             \string\Versus%
                      \else
                             \string\Prosa%
                      \fi
                      -\TXN@domain@stack@top@line\space 
                      \the\toks@}%
     \toks@ = \expandafter {\TXN@temp}%
     \TXN@domain@pop
   \repeat
}
%    \end{macrocode}
% \subsection{Entering a domain } 
%    \begin{macrocode}
\def \TXN@domain@enter #1{%
%<debug>  \TXN@trace@domain {0}{#1}%
  \TXN@domain@top
  \ifcase #1\relax
    \relax
  \or %            Versus
    \ifcase \TXN@domain@stack@top \TXN@safe
      \expandafter \PTR@versus
    \or
      \TXN@withinVersustrue
    \or
      \TXN@endprosa
      \expandafter \PTR@versus
    \fi
    \TXN@domain@push {1}%
  \or %            Prosa
    \ifcase \TXN@domain@stack@top \TXN@safe
      \expandafter \TXN@prosa
    \or
      \PTR@endversus
      \TXN@prosa
    \or
      \par
    \fi
    \TXN@domain@push {2}%
  \fi
}
%    \end{macrocode}
% \subsection{Leaving a domain } 
%    \begin{macrocode}
\def \TXN@env@document {document}
\def \TXN@env@prosa    {prosa}
\def \TXN@env@Prosa    {Prosa}
\def \TXN@document {document}
\def \TXN@domain@leave #1{%
%<debug>  \TXN@trace@domain {1}{#1}%
  \TXN@domain@top
  \ifnum #1 = \@ne
%    \end{macrocode}
%   Versus
%    \begin{macrocode}
    \ifnum \TXN@domain@stack@top = \z@
      \TXN@domain@error 
    \else
      \ifnum \TXN@domain@stack@top = \@ne
        \PTR@endversus
        \TXN@domain@pop
        \TXN@domain@top
        \ifnum \TXN@domain@stack@top = \tw@
          \ifx \@currenvir \TXN@env@document
            \TXN@prosa
          \fi
        \fi
      \else
        \TXN@domain@error 
           {\protect\endVersus\space after \protect\Prosa}%
      \fi
    \fi
  \else
%    \end{macrocode}
%   Prosa
%    \begin{macrocode}
    \ifnum \TXN@domain@stack@top = \@ne
         \TXN@domain@error 
           {\protect\endProsa\space after \protect\Versus}%
    \else
      \ifnum \TXN@domain@stack@top = \z@
         \TXN@domain@error 
           {\protect\endProsa\space not preceded by \protect\Prosa}%
      \else
        \TXN@endprosa
        \TXN@domain@pop
        \TXN@domain@top
        \ifnum \TXN@domain@stack@top = \@ne
%          \ifx \@currenvir \TXN@env@document
            \PTR@versus
%          \fi
        \fi
      \fi
    \fi
  \fi
 \ifx \TXN@empty@domain@stack \TXN@domain@stack 
%    \TXN@stop@lineno
  \fi
}
%    \end{macrocode}
% \section{The \TXN@cmd{prosa} domain} 
%
% \subsection{Entering the domain.}
%    \begin{macrocode}
\def \prosa {\TXN@domain@enter 2}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@prosa {%
%<debug>  \TXN@trace \TXN@prosa
  \TXN@withinProsatrue
  \ifTXN@folio@set
  \else
    \xdef \TXN@theFolio {\ifodd \c@page recto\else verso\fi}%
    \gdef \TXN@previous@page {}%
    \global \TXN@folio@settrue
  \fi
  \xdef \TXN@endarea@list {}%
%    \end{macrocode}
%
%    \begin{macrocode}
  \TXNl@lineate \TXN@process@line
  \global \TXN@lineatingtrue
%    \end{macrocode}
% Set the text margins.
%    \begin{macrocode}
 \edef \TXN@save@leftskip   {\the\leftskip}%
 \edef \TXN@save@rightskip  {\the\rightskip}%
 \edef \TXN@save@parindent  {\the\parindent}%
 \edef \TXN@save@parskip    {\the\parskip}%
 \ifTXN@withinDrama
   \parindent = \z@
 \fi
 \let \TXN@@line = \@@line
 \def \@@line {\leavevmode\TXN@@line}%
 \TXN@assign \TXN@measure = {TXN@textus[\TXN@theTextus]measure}%
 \hsize \TXN@measure
 \@nameuse{TXN@textus[\TXN@theTextus]Facies}\relax
%    \end{macrocode}
%
%    \begin{macrocode}
 \ifTXN@milestones
   \TXN@initialize@milestones
 \fi
}
%    \end{macrocode}
% \subsection{Leaving the domain.}
%    \begin{macrocode}
\def \endprosa {\TXN@domain@leave 2}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@endprosa {%
%<debug> \TXN@trace \TXN@end@prosa
 \par
 \TXN@withinProsafalse
 \TXNl@lineate \relax
 \leftskip  = \TXN@save@leftskip  \TXN@safe
 \rightskip = \TXN@save@rightskip \TXN@safe
 \parindent = \TXN@save@parindent \TXN@safe
 \parskip   = \TXN@save@parskip   \TXN@safe
 \let \@@line = \TXN@@line
}
\let \Prosa = \prosa
\let \endProsa = \endprosa
%    \end{macrocode}
% \subsection{Processing a line.}
%
% Two logical variable that may be tested with |\boolean| in
% an |\ifthenelse| test.
%    \begin{macrocode}
\newif \ifParagraphFirstLine
\newif \ifParagraphLastLine
%    \end{macrocode}
% Within the domain, the `hook' into the |\output| routine via the 
% \textbf{lineate} package is active and this macro gets control
% for each line in the domain.  The processing is much the same as
% within \textbf{versus}.
%    \begin{macrocode}
\newif \ifTXN@normal@line
\newif \ifTXN@bad@titulus
\def \TXN@process@line@prosa #1{%
%<debug> \TXN@trace \TXN@process@line@prosa
  \TXN@normal@linetrue
  \global \TXN@bad@titulusfalse
  \setbox \tw@ = \copy \z@
  \setbox \tw@ = \vbox {%
    \unvbox \tw@
    \global \setbox \@ne = \lastbox
  }%
  \ifvoid \@ne
    \TXN@normal@linefalse
    \setbox \TXN@hbox = \box\z@
  \else
    \unvbox \z@
    \setbox \TXN@hbox = \lastbox
  \fi
  \dp\TXN@hbox = \TXN@skip@depth@cclv \TXN@safe
%    \end{macrocode}
% Set the variables recording information about the line
%    \begin{macrocode}
    \ParagraphFirstLinefalse
    \ParagraphLastLinefalse
    \edef \ParagraphLine {#1}%
    \ifnum #1 < \z@
      \ParagraphLastLinetrue
      \edef \ParagraphLine {-#1}%
    \fi
    \ifnum \ParagraphLine = \@ne
      \ParagraphFirstLinetrue
    \fi
    \xdef \TXN@line@length {\the\wd\TXN@hbox}%
    \global \TXN@leading@space = \z@
    \ifTXN@normal@line
      \dimen@ = \TXN@measure
      \advance \dimen@ by -\wd\TXN@hbox
      \global \TXN@leading@space = \dimen@ \TXN@safe
      \ifParagraphFirstLine
        \dimen@@ = \dimen@
        \advance \dimen@@ by \parindent
        \global \TXN@leading@space = \dimen@@ \TXN@safe
      \fi
      \edef \ParagraphLineFill {\z@}%
      \setbox \tw@ = \copy \TXN@hbox
      \setbox \tw@ = \hbox {%
        \unhbox \tw@
        \global \skip@i = \the\lastskip
        \unskip
      }%
      \TXN@check@if@normal@glue \skip@i
      \ifTXN@sw
        \dimen@@ = \wd\TXN@hbox
        \advance \dimen@@ by -\skip@i
      \else
        \dimen@@ = \wd\tw@
        \advance \dimen@@ by \dimen@
      \fi
      \xdef \TXN@line@length {\the\dimen@@}%
      \ifParagraphLastLine
        \xdef \TXN@line@length {\the\wd\tw@}%
        \dimen@@ = \wd\tw@
        \advance \dimen@@ by -\TXN@measure
        \edef \ParagraphLastLineFill {-\the\dimen@@}%
      \fi
%    \end{macrocode}
%     We restore the initial indentation from |\hangindent| as the box
%     shift is lost on unboxing (see the EDMAC manual, 7.2).
%    \begin{macrocode}
      \ifdim \dimen@ > \z@
        \setbox \TXN@hbox = \hbox {\kern \dimen@ \box \TXN@hbox}%
      \fi
    \fi
%    \end{macrocode}
% Prepare for attaching |\textus| and |\numerus| objects
%    \begin{macrocode}
  \ifNewPage
    \TXN@reset@pagewise@numbers
  \fi
  \TXN@clear@numbers
  \setbox \TXN@marginalia = \copy\voidb@x
%    \end{macrocode}
% Replay any commands for this line
%    \begin{macrocode}
  \ifTXN@milestones
    \ifnum \TXN@pass = \tw@
      \global\TXN@replaytrue
      \loop
      \ifnum \TXNl@linenumber > \TXN@auy@lineno \TXN@safe
        \TXN@read@auy
      \repeat
      \loop
      \ifnum \TXNl@linenumber = \TXN@auy@lineno \TXN@safe
%<debug> \TXN@trace@replay
        \TXN@auy@command
        \TXN@read@auy
      \repeat
    \fi
  \fi
%    \end{macrocode}
% Attach |\textus| and |\numerus| objects
%    \begin{macrocode}
  \setbox \TXN@marginalia = \copy\voidb@x
  \TXN@SimpleList \TXN@line@fields \z@
  \TXN@assign \dimen@ = 
    {TXN@textus[\TXN@theTextus]offset@\TXN@theFolio}%
  \advance \dimen@ by \TXN@leading@space \TXN@safe
  \dimen@@ = \TXN@measure
  \advance \dimen@@ by -\rightskip
  \edef \TXN@temp {\the\dimen@,\the\dimen@@}%
  \TXN@SimpleList@append \TXN@line@fields \TXN@temp
  \TXN@attach@textus {\z@}% 
  \TXN@process@line@numbers
  \ht \TXN@marginalia = \z@
  \if y\TXN@showlineno
     \TXN@show@lineno@info {#1}%
  \fi
%    \end{macrocode}
%
%    \begin{macrocode}
  \ifdim \TXN@measure = \linewidth
    \dimen@ = \z@
  \else
    \TXN@assign \dimen@ = {TXN@textus[\TXN@theTextus]offset@\TXN@theFolio}%
  \fi
  \ifTXN@normal@line
    \setbox \TXN@hbox = \hbox {\kern \dimen@ \box\TXN@hbox}%
    \dp\TXN@hbox = \TXN@skip@depth@cclv \TXN@safe
    \box \TXN@hbox 
  \else
    \unvbox\TXN@hbox 
  \fi
  \ifvoid \TXN@marginalia
  \else
     \nointerlineskip
     \kern -\TXN@skip@depth@cclv  \TXN@safe
     \dp \TXN@marginalia = \TXN@skip@depth@cclv \TXN@safe
     \box \TXN@marginalia 
  \fi
  \ifnum \TXN@active@areas > \z@
    \TXN@process@area@line@Prosa \TXN@hbox
  \fi
%    \end{macrocode}
%
%    \begin{macrocode}
  \ifx \empty \TXN@endarea@list
  \else
    \TXN@endarea@Prosa
  \fi
  \ifTXN@milestones
    \ifnum \TXN@pass = \tw@
      \global\TXN@replayfalse
    \fi
  \fi
  \edef \ParagraphLine {\z@}%
  \ParagraphFirstLinefalse
  \ParagraphLastLinefalse
  \ifnum #1 < \z@
    \gdef \TXN@float@counter {0}%
    \gdef \TXN@margin@counter {0}%
  \fi
}
%    \end{macrocode}
% Reset the value of all attached numbers.
%    \begin{macrocode}
\def \TXN@clear@numbers {%
  \count@ = \TXN@numerus@max
  \loop
  \ifnum \count@ > \m@ne 
    \TXN@let \TXN@test = {TXN@numerus[\the\count@]side@\TXN@theFolio}%
    \ifx \empty \TXN@test 
    \else
      \ifnum \TXN@test < \z@
      \else
        \TXN@gdef {TXN@numerus[\the\count@]first@value}{}%
      \fi
    \fi
    \advance \count@ by \m@ne 
  \repeat
}
%    \end{macrocode}
% Reset the counters of all \textit{pagewise} numbers.
%    \begin{macrocode}
\def \TXN@reset@pagewise@numbers {%
%<debug> \TXN@trace \TXN@reset@pagewise@numbers
  \count@ = \TXN@numerus@max \TXN@safe
  \loop
  \ifnum \count@ > \m@ne 
    \edef \TXN@flags {%
          \@nameuse {TXN@numerus[\the\count@]flagsModus@\TXN@theFolio}}%
    \if \TXN@option \TXN@o@Pagewise \TXN@flags
      \@tempcnta = \TXN@c@numerus{\the\count@}%
      \ifnum \@tempcnta > \tw@
        \global \TXN@c@numerus{\the\count@}= \@ne
        \TXN@xdef {TXN@numerus[\the\count@]previous}{}%
      \fi
    \fi
    \advance \count@ by \m@ne 
  \repeat
}
%    \end{macrocode}
% \section{The interface with \texttt{txnline}} 
% \subsection{Processing a line} 
% The \textbf{txnline} package transfers controls here for each line.
% The line (originally in |\box254|, now empty) is in |box0|.\\
% |#1|\  is the line number within the paragraph \\
%        (negative for the the last line of the paragraph)
%    \begin{macrocode}
\def \TXN@process@line #1{%
%<debug>  \TXN@trace \TXN@process@line
  \TXN@skip@depth@cclv = \dimen@ \TXN@safe
  \ifTXN@withinProsa
    \TXN@process@line@prosa {#1}%
  \else
    \ifTXN@withinVersus
      \unvbox \z@
      \if y\TXN@showlineno
        \TXN@show@lineno@info {#1}%
      \fi
    \else
      \PackageError{TEXNIKA}%
        {Something horrible has happened}
        {Input line: \number\inputlineno}%
    \fi
  \fi
  \ifTXN@lineating
    \TXN@process@line@page 
  \fi
}
%    \end{macrocode}
% Display some useful information for debugging.
%    \begin{macrocode}
\def \TXN@show@lineno@info #1{%
%<debug>  \TXN@trace \TXN@show@lineno@info
  \edef \TXN@temp {\TXN@line@class}%
  \ifx \empty \TXN@temp
    \edef \TXN@temp {t}%
  \fi
  \if@firstcolumn
    \setbox \@tempboxa = \llap {\TXNcmr 
      \footnotesize
      \ifTXN@withinProsa [#1]\fi
      \number\TXNl@linenumber
      \rlap{\ifNewPage\uppercase\fi
        \ifx \TXN@theFolio \TXN@recto{r}\else{v}\fi
        \TXN@temp}%
      \kern 1,5cm %
    }%
  \else
    \dimen@@ = \columnwidth
    \advance \dimen@@ by 1,5cm\relax
    \setbox \@tempboxa = \rlap {\TXNcmr 
      \footnotesize
      \kern \dimen@@
      \ifTXN@withinProsa [#1]\fi
      \number\TXNl@linenumber
      \rlap{\ifNewPage\uppercase\fi
        \ifx \TXN@theFolio \TXN@recto {r}\else {v}\fi
        \TXN@temp}%
    }%
  \fi
  \ifTXN@withinProsa
     \dp \@tempboxa = \z@
     \ht \@tempboxa= \z@
     \setbox \TXN@marginalia = \hbox {%
       \llap{\box\@tempboxa}\box\TXN@marginalia}%
  \fi
  \ifTXN@withinVersus
    \dp\@tempboxa = \TXN@skip@depth@cclv \TXN@safe
    \ht\@tempboxa = \z@
    \nointerlineskip \kern -\TXN@skip@depth@cclv \TXN@safe
    \box \@tempboxa
  \fi
}
%    \end{macrocode}
% \subsection{Processing the \texttt{aux} file} 
% \textit{recto}/\textit{verso} processing requires two passes. In the
% first pass, for each line processed in a domain, one line is written
% to the \textbf{aux} with the following data:\par
% |\TXN@lineate|{\textless line\textgreater}{\textless page\textgreater}{\textless column\textgreater}\par
% At the start of the second pass, as the \textbf{aux} file is read in,
% the macroa are executed and generate a set of |\cs| of the form
% |\TXN@line@page@column@|\textit{n}, each holding the initial line
% number for a page.  
%    \begin{macrocode}
\def \TXN@lineate@line {0}
\def \TXN@lineate@page {0}
\def \TXN@lineate@column {0}
\gdef \TXN@lineate@count {0}
%    \end{macrocode}
%
%    \begin{macrocode}
\AtBeginDocument {%
  \gdef \TXN@lineate@count {0}
  \gdef \TXN@line@number {-1000000}
  \gdef \TXN@page@number {-1000000}
  \gdef \TXN@column@number {-1000000}
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@lineate #1#2#3{%
  \ifnum #1 = \@ne
    \xdef \TXN@previous@page {#2}%
    \ifodd #2\relax
      \gdef \TXN@theFolio {recto}%
    \else
      \gdef \TXN@theFolio {verso}%
    \fi
    \global \NewPagetrue
  \fi
  \ifnum \TXN@lineate@column = \z@
    \def \TXN@lineate@line {#1}%
    \def \TXN@lineate@page {#2}%
    \def \TXN@lineate@column {#3}%
  \else
    \TXN@swfalse
    \ifnum \TXN@lineate@column = #3\relax
      \ifnum \TXN@lineate@page = #2\relax
      \else
        \TXN@swtrue
      \fi
    \else
      \TXN@swtrue
    \fi
    \ifTXN@sw
      \TXN@gincr \TXN@lineate@count
      \TXN@xdef {TXN@line@page@column@\TXN@lineate@count}%
                {{\TXN@lineate@line}{\TXN@lineate@page}%
                 {\TXN@lineate@column}}%
      \def \TXN@lineate@line {#1}%
      \def \TXN@lineate@line {#1}
      \def \TXN@lineate@page {#2}
    \else
      \def \TXN@lineate@line {#1}%
    \fi
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@get@page@column #1{%
  \begingroup
  \TXN@counter = #1\relax
  \loop
  \ifnum \TXN@counter > \TXN@line@number \TXN@safe
    \TXN@gincr \TXN@lineate@count
    \if \TXN@relax {TXN@line@page@column@\TXN@lineate@count}%
       \TXN@counter = \TXN@line@number \TXN@safe
    \else
      \edef \TXN@temp {%
        \csname TXN@line@page@column@\TXN@lineate@count\endcsname}%
      \expandafter \TXN@get@page@column@bis \TXN@temp
    \fi
  \repeat
  \endgroup
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@get@page@column@bis #1#2#3{%
  \gdef \TXN@line@number   {#1}%
  \gdef \TXN@page@number   {#2}%
  \gdef \TXN@column@number {#3}%
}
%    \end{macrocode}
% \subsection{Processing page information} 
%    \begin{macrocode}
\def \TXN@process@line@page {%
%<debug>  \TXN@trace \TXN@process@line@page
  \ifnum \TXN@pass = \tw@
    \TXN@counter = \TXNl@linenumber
    \advance  \TXN@counter by \@ne
    \TXN@get@page@column {\TXN@counter}%
    \if@twoside
      \gdef \TXN@theFolio {recto}%
      \ifodd \TXN@page@number \TXN@safe 
      \else 
        \gdef \TXN@theFolio {verso}%
      \fi
    \else
      \gdef \TXN@theFolio {recto}%
    \fi
  \else
    \protected@write \@auxout {} {%
      \string\TXN@lineate{\the\TXNl@linenumber}%
                         {\noexpand\the\c@page}%
      {\if@twocolumn \if@firstcolumn 1\else 2\fi \else 1\fi}%
    }%
  \fi
%    \end{macrocode}
%
%    \begin{macrocode}
  \global \NewPagefalse
  \ifx \TXN@page@number \TXN@previous@page
  \else
    \ifx \empty \TXN@previous@page 
    \else
      \global \NewPagetrue
    \fi
    \xdef \TXN@previous@page {\TXN@page@number}%
  \fi
}
%    \end{macrocode}
% \section{Supporting \textit{milestones}} 
%    \begin{macrocode}
\gdef \TXN@previous@page {-1000000000}%
\newif \ifTXN@milestones@init
%    \end{macrocode}
% \subsection{Initializing \textit{milestones}} 
%    \begin{macrocode}
\def \TXN@initialize@milestones {%
%<debug> \TXN@trace \TXN@initialize@milestones
 \ifTXN@milestones@init
 \else
   \TXN@milestones@inittrue
   \count@ = \count15\relax
   \advance \count@ by \@ne
   \xdef \TXN@insert@toks@first {\the\count@}%
   \advance \count@ by \TXN@max@floats
   \ifnum \count@ > 253\relax
     \count@ = 253\relax
   \fi
   \xdef \TXN@insert@toks@last {\the\count@}%
   \gdef \TXN@float@counter {0}%
   \gdef \TXN@margin@counter {0}%
   \ifnum \TXN@pass = \tw@
     \newread \TXN@auy
     \openin \TXN@auy = \jobname.auy\relax
     \TXN@read@auy
   \else
     \newwrite \TXN@auy
     \immediate \openout \TXN@auy = \jobname.auy\relax
   \fi
   \gdef \TXN@save@command@count {0}%
   \TXN@SimpleList@append \TXN@commissurae {-1}%
   \gdef \TXN@commissura@index {-1}%
   \TXN@get@next@commissura
 \fi
}
%    \end{macrocode}
% \subsection{Processing \textit{milestones}} 
% \subsubsection {Logging commands to \textbf{auy}}
%    \begin{macrocode}
\def \TXN@save@command {%
  \ifTXN@replay
  \else
    \expandafter \TXN@save@command@bis
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@save@command@bis {%
  \count@ = \TXN@save@command@count \TXN@safe
  \advance \count@ by \@ne
  \xdef \TXN@save@command@count {\the\count@}%
  \ifnum \TXN@pass = \tw@
    \ifnum \TXN@next@commissura = \count@
      \TXN@get@next@commissura
      \TXN@commissura
    \fi
    \ifvmode
      \ifinner \else 
        \leavevmode \@bsphack \@savsk\p@
      \fi
    \else
      \@bsphack
    \fi
    \@ignorefalse \@esphack
  \else
    \expandafter \TXN@do@save@command
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@do@save@command {%
%<debug> \TXN@trace@save@command 
  \ifnum \TXN@float@counter > \TXN@insert@toks@last \TXN@safe
    \TXN@commissura \the\toks@
    \protected@write\@auxout{}{%
    \string\TXN@@commissura{\TXN@save@command@count}}%
  \fi
  \TXN@run@LaTeX@again@reason \TXN@run@LaTeX@again@milestones
  \ifvmode
    \ifinner \else 
      \leavevmode \@bsphack \@savsk\p@
    \fi
  \else
    \@bsphack
  \fi
  \@bsphack
  \ifhmode
    \ifinner
     \TXN@float@error1
    \else
      \@floatpenalty -\@Mii
        \global \count\TXN@insert = -15011943 %
        \count@ = \TXN@float@counter \TXN@safe
        \advance \count@ by \@ne
        \xdef \TXN@float@counter {\the\count@}%
        \advance \count@ by \TXN@insert@toks@first  \TXN@safe
        \toks \the\count@ = \toks@
         \begingroup
          \setbox \TXN@insert \color@vbox \vbox \bgroup \@endfloatbox
          \@cons\@currlist\TXN@insert
          \vadjust {\penalty -\@Miv
                    \vbox{}\penalty\@floatpenalty}\@Esphack
          \nobreak\hskip \z@
        \endgroup
        \@ignorefalse \@esphack
    \fi
  \else
    \TXN@float@error2
  \fi
}
%    \end{macrocode}
% Should never happen
%    \begin{macrocode}
\def \TXN@float@error#1{%
    \PackageError{TEXNIKA}%
      {FLOAT ERROR #1}
      {Please report the error to the author}%
}
%    \end{macrocode}
%
%    \begin{macrocode}
\let \TXN@addmarginpar \@addmarginpar
\def \@addmarginpar {%
   \ifnum\count\@currbox = -15011943\relax
     \ifnum \@currbox = \TXN@insert \TXN@safe
       \ifnum \TXN@pass = \tw@
       \else
         \count@ = \TXN@margin@counter \TXN@safe
         \advance \count@ by \@ne
         \xdef \TXN@margin@counter {\the\count@}%
        \ifx \empty \TXN@insert@toks@first
        \fi
         \advance \count@ by \TXN@insert@toks@first \TXN@safe
         \toks@ = \toks \the\count@
         \begingroup
%             \newlinechar='40\relax 
         \immediate \write \TXN@auy 
           {{{\the\TXNl@linenumber}{\the\toks@}}}%
         \endgroup
       \fi
     \fi
   \else
     \expandafter \TXN@addmarginpar
   \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@read@auy {%
  \global \read \TXN@auy to \TXN@auy@line
  \def \TXN@temp {\par}%
  \ifx \TXN@temp \TXN@auy@line
    \gdef \TXN@auy@lineno {1000000}%
  \else
    \expandafter \TXN@split@auy@line 
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@split@auy@line {%
   \expandafter \TXN@split@auy@line@bis \TXN@auy@line
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@split@auy@line@bis #1{%
  \TXN@split@auy@line@ter #1\relax
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@split@auy@line@ter #1#2{%
  \gdef \TXN@auy@lineno {#1}%
  \gdef \TXN@auy@command {#2}%
}
%    \end{macrocode}
% \subsubsection {Processing \textit{commissurae}}
%    \begin{macrocode}
\newcommand {\commissura} {%
  \ifx \empty \TXN@attribute@name 
    \expandafter \TXN@commissura
  \else
    \def \TXN@subclass@name {commissura}%
    \def \TXN@subclass@number {}%
    \def \TXN@temp {TXN}%
    \expandafter \TXN@attribute@set
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@commissura {%
  \begingroup
    \parfillskip = \z@skip
    \par
    \parskip \z@skip
    \noindent
    \ifnum \TXN@pass = \tw@
    \else
      \TXN@FaciesCommissura
    \fi
  \endgroup
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@setFacies@commissura #1{%
  \def \TXN@FaciesCommissura {\begingroup#1\endgroup}%
}
%    \end{macrocode}
%
%    \begin{macrocode}
\TXN@SimpleList \TXN@commissurae \z@
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@@commissura #1{%
  \TXN@SimpleList@append \TXN@commissurae {#1}}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@get@next@commissura {%
  \count@ = \TXN@commissura@index \TXN@safe
  \advance \count@ by \@ne
  \xdef \TXN@commissura@index {\the\count@}%
  \TXN@get \TXN@commissurae.\TXN@commissura@index \TXN@next@commissura
}
%    \end{macrocode}
% \section{Initial and final processing} 
% \subsection{At the end of the package} 
%    \begin{macrocode}
\def \TXN@numeri {%
  \ifx \empty \TXN@attribute@name 
    \expandafter \TXN@save@numeri
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\AtEndOfPackage{%
  \TXN@initialize@numerus {0}%
  \TXN@initialize@textus {0}%
  \TXN@initialize@titulus {0}%
  \TXN@initialize@spatium {0}%
  \ifx \@undefined \numeri
    \let \numeri = \numerus
  \else
    \let \TXN@save@numeri = \numeri
    \let \numeri = \TXN@numeri
  \fi
  \ifx \@undefined \TXN@FaciesIncipit
    \def \TXN@FaciesIncipit {}%
  \fi
  \ifx \@undefined \TXN@SpatiumPostEscEsc
    \def \TXN@SpatiumPostEscEsc {\hskip .22em\relax}%
  \fi
  \TXN@def {TXN@titulus[0]Forma}{}%
  \let \TXN@LaTeX@esc@esc = \\
  \def \TXN@FaciesCommissura {}%
  \frenchspacing
  \parindent = \z@
  \gdef \TXN@spatium@flag {}%
  \gdef \TXN@set@second@pass {\gdef\TXN@pass{2}}
%    \end{macrocode}
%
%    \begin{macrocode}
  \def \TXN@numerus@max {0}
  \def \TXN@textus@max {0}
  \def \TXN@titulus@max {0}
  \def \TXN@spatium@max {0}
  \def \TXN@recto {recto}
}
%    \end{macrocode}
% \subsection{At the beginnning of the document} 
%    \begin{macrocode}
\AtBeginDocument{%
%    \end{macrocode}
% Set |\Facies \textus| ...
%    \begin{macrocode}
  \if \TXN@empty {TXN@textus[\TXN@theTextus]Facies}%
    \TXN@edef {TXN@textus[\TXN@theTextus]Facies}{%
      \noexpand\fontencoding {\f@encoding}%
      \noexpand\fontfamily   {\f@family}%
      \noexpand\fontseries   {\f@series}%
      \noexpand\fontshape    {\f@shape}%
      \noexpand\selectfont
    }%
  \fi
%    \end{macrocode}
% ... and the measure
%    \begin{macrocode}
  \if \TXN@empty {TXN@textus[\TXN@theTextus]measure}%
    \TXN@xdef {TXN@textus[\TXN@theTextus]measure}{\the\linewidth}%
  \fi
  \TXN@assign \TXN@measure = {TXN@textus[\TXN@theTextus]measure}%
%    \end{macrocode}
%
%    \begin{macrocode}
  \TXN@outside@preambletrue
  \@ifpackageloaded{poetry}{\TXN@poetrytrue}{}%
%    \end{macrocode}
%
%    \begin{macrocode}
  \if y\TXN@showlineno
    \global \TXN@lineatingtrue
  \fi
%    \end{macrocode}
%
%    \begin{macrocode}
  \gdef \TXN@insert@toks@first {}%
  \gdef \TXN@insert@toks@last  {}%
  \gdef \TXN@float@counter     {0}%
  \gdef \TXN@margin@counter    {0}%
%    \end{macrocode}
%
%    \begin{macrocode}
  \let \TXN@save@tableofcontents = \tableofcontents
  \let \tableofcontents = \TXN@tableofcontents
%    \end{macrocode}
%
%    \begin{macrocode}
  \gdef \TXN@theFolio {recto}
  \def  \TXN@line@class {}
%    \end{macrocode}
% These commands must be trapped, to set the measure.
%    \begin{macrocode}
  \let \TXN@save@onecolumn = \onecolumn
  \let \TXN@save@twocolumn = \twocolumn
  \gdef \onecolumn {\TXN@save@onecolumn \TXN@measure = \linewidth}%
  \renewcommand \twocolumn [1][\relax]{%  
    \TXN@save@twocolumn[#1]\TXN@measure = \linewidth}%
}
%    \end{macrocode}
% \subsection{At the end of the document} 
%    \begin{macrocode}
\AtEndDocument{%
  \ifTXN@lineating
    \protected@write \@auxout{}
      {\string\TXN@lineate{1000000}{1000000}{1000000}}%
    \def \TXN@lineate #1#2#3{}%
  \fi
%    \end{macrocode}
% Check proper nesting of domains
%    \begin{macrocode}
  \TXN@domain@top
  \ifnum \TXN@domain@stack@top > \z@
    \TXN@get@domain@stack
    \PackageError{TEXNIKA}%
      {Bad domain nesting: \MessageBreak\the\toks@}
      {The number after the hyphen is the input line\MessageBreak
       at which the (unclosed) domain was entered.}%
  \fi
%    \end{macrocode}
% Check proper nesting of areas
%    \begin{macrocode}
  \ifnum \TXN@active@areas > \z@
    \TXN@list@bad@areas 
  \fi
%    \end{macrocode}
%
%    \begin{macrocode}
  \ifnum \TXN@pass = \tw@
    \if y\TXN@option@stats 
      \TXN@print@stats
    \fi
  \else
    \ifx \empty \TXN@run@LaTeX@again 
      \if y\TXN@option@stats 
        \TXN@print@stats
      \fi
    \else
      \protected@write \@auxout{}{\string\TXN@set@second@pass}%
      \toks@ = {Run LaTeX again.  A second run is necessary because:}%
      \TXN@give@reason
      \edef \TXN@temp {\the\toks@}%
      \TXN@PackageWarningNoLine {TEXNIKA}{\TXN@temp}%
      \if y\TXN@option@repeat
        \newwrite \TXN@rpt
        \immediate \openout \TXN@rpt = \jobname.rpt\relax
        \immediate \write \TXN@rpt {repeat}% 
      \fi
    \fi
    \global \let \TXN@set@second@pass = \relax
    \gdef \TXN@pass {1}%
  \fi
%    \end{macrocode}
% This ensures that pending writes to .aux get executed, in case
% the document ends in vertical mode.
%    \begin{macrocode}
  \ifx \empty \TXN@run@LaTeX@again 
  \else
    \ifnum \TXN@pass = \@ne
      \leavevmode 
    \fi
  \fi
}
%    \end{macrocode}
% \subsubsection{Listing the bad areas} 
%    \begin{macrocode}
\def \TXN@list@bad@areas {%
  \toks@ = {}%
  \TXN@counter@a = \TXN@area@count \TXN@safe 
  \advance \TXN@counter@a by \@ne
  \TXN@counter = \@ne 
  \loop
  \ifnum \TXN@counter < \TXN@counter@a
    \TXN@get \TXN@areas.\TXN@counter \TXN@temp
    \expandafter \TXN@list@bad@areas@bis \TXN@temp \TXN@nil
    \advance \TXN@counter by \@ne
  \repeat
  \PackageError {TEXNIKA} {There is no \protect\endarea\space for:\the\toks@}
                {}%
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@list@bad@areas@bis #1,#2\TXN@nil{%
  \ifnum #1 > \z@
    \def \TXN@parameter {#2}%
    \ifx \TXN@parameter \TXN@safe
      \def \TXN@temp {}%
    \else
      \edef \TXN@temp {[\TXN@parameter]}%
    \fi
    \edef \TXN@temp@bis {\the\toks@ \TXN@next@warning@line
                         \@backslashchar area\TXN@temp\space at line #1}%
    \toks@ = \expandafter {\TXN@temp@bis}%
  \fi
}
%    \end{macrocode}
% \subsubsection{Listing the reason(s) for a second run} 
%    \begin{macrocode}
\def \TXN@give@reason {%
  \if \TXN@option t \TXN@run@LaTeX@again
      \toks@ = \expandafter {\the\toks@ \TXN@next@warning@line
        -- You have requested the table of contents}%
  \fi
  \if \TXN@option r \TXN@run@LaTeX@again
      \toks@ = \expandafter {\the\toks@ \TXN@next@warning@line
        -- You have different styles for `recto' and `verso'}%
  \fi
  \if \TXN@option m \TXN@run@LaTeX@again
      \toks@ = \expandafter {\the\toks@ \TXN@next@warning@line
        -- You are using `milestones'}%
  \fi
  \if \TXN@option p \TXN@run@LaTeX@again
      \toks@ = \expandafter {\the\toks@ \TXN@next@warning@line
        -- You are using pagewise numbering}%
  \fi
  \if \TXN@option a \TXN@run@LaTeX@again
      \toks@ = \expandafter {\the\toks@ \TXN@next@warning@line
        -- You have set \protect\Locus\space\protect\textus\space
          to \protect\auto\space (or \protect\Auto)}%
  \fi
  \if \TXN@option s \TXN@run@LaTeX@again
      \toks@ = \expandafter {\the\toks@ \TXN@next@warning@line
        -- Some split lines need to be adjusted}%
  \fi
  \if \TXN@option f \TXN@run@LaTeX@again
      \toks@ = \expandafter {\the\toks@ \TXN@next@warning@line
        -- You have requested the index of first lines}%
  \fi
  \if \TXN@option l \TXN@run@LaTeX@again
      \toks@ = \expandafter {\the\toks@ \TXN@next@warning@line
        -- You have used `firstlinetitlemarks'}%
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@next@warning@line {%
  ^^J\space\space\space\space\space\space\space\space\space\space
  \space\space\space\space\space\space\space\space\space\space
  \space\space\space\space\space
}
%    \end{macrocode}
% Record the reasons for a second run
%    \begin{macrocode}
\gdef \TXN@run@LaTeX@again {}
%    \end{macrocode}
%    \begin{macrocode}
\def \TXN@run@LaTeX@again@auto       {a} 
\def \TXN@run@LaTeX@again@split      {s} 
\def \TXN@run@LaTeX@again@milestones {m} 
\def \TXN@run@LaTeX@again@rectoverso {r}
\def \TXN@run@LaTeX@again@firstlines {f} 
\def \TXN@run@LaTeX@again@toc        {t} 
\def \TXN@run@LaTeX@again@fl@mark    {l}
\def \TXN@run@LaTeX@again@pagewise   {p}
%    \end{macrocode}
%    \begin{macrocode}
\def \TXN@run@LaTeX@again@reason #1{%
  \if \TXN@option #1\TXN@run@LaTeX@again
  \else
    \xdef \TXN@run@LaTeX@again {#1\TXN@run@LaTeX@again}%
  \fi
}
%    \end{macrocode}
% \subsubsection{Printing statistics} 
%    \begin{macrocode}
\gdef \TXN@stats@versus@lines {\z@}
\gdef \TXN@stats@versus@longest {\z@}
\gdef \TXN@stats@versus@longest@print {\z@}
\gdef \TXN@stats@versus@excessus@count {\z@}
\gdef \TXN@stats@versus@excessus@longest {\z@}
\gdef \TXN@stats@versus@excessus@shortest {\maxdimen}
\gdef \TXN@stats@versus@folded {\z@}
\gdef \TXN@stats@versus@moved {\z@}
\gdef \TXN@stats@prosa@lines {\z@}
\def \TXN@next@info@line {%
  ^^J\space\space\space\space\space\space\space\space\space\space
     \space\space\space\space\space\space\space\space\space\space
     \space\space
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@print@stats {%
  \ifnum \TXN@stats@versus@lines > \z@
    \toks@ = {Statistics for the Versus domain:}%
    \toks@ = \expandafter {\the\toks@ \TXN@next@info@line
      -- \TXN@stats@versus@lines\space lines\space
         (longest: \TXN@stats@versus@longest)}%
    \toks@ = \expandafter {\the\toks@ \TXN@next@info@line
      -- The longest print line is \TXN@stats@versus@longest@print}%
    \ifnum \TXN@stats@versus@excessus@count = \z@
      \toks@ = \expandafter {\the\toks@ \TXN@next@info@line
        -- No folded lines}%
    \else
      \toks@ = \expandafter {\the\toks@ \TXN@next@info@line
      -- \TXN@stats@versus@excessus@count\space folded lines:}%
      \toks@ = \expandafter {\the\toks@ \TXN@next@info@line
        \space\space\space 
        longest turnover line: \TXN@stats@versus@excessus@longest}%
      \toks@ = \expandafter {\the\toks@ \TXN@next@info@line
        \space\space\space 
        shortest turnover line: \TXN@stats@versus@excessus@shortest}%
    \fi
    \edef \TXN@temp {\the\toks@}%
    \let \on@line = \@empty
    \PackageInfo {TEXNIKA}{\TXN@temp}%
  \fi
}
%    \end{macrocode}
% \section{Headlines and the table of contents} 
%    \begin{macrocode}
\let \Capita = \TXNt@ttl@setmarks
%    \end{macrocode}
% These assignments ensure that we print a `clean' text.
%    \begin{macrocode}
\def \TXN@caput@cleanup {%
  \let \contents = \TXN@unskip@gobble
  \let \headline = \TXN@unskip@gobble
  \let \notcontents = \@firstofone
  \let \notheadline = \@firstofone
  \let \indexes = \TXN@unskip@gobble
  \let \addfirstline = \relax
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@unskip@gobble {\unskip\@gobble}
%    \end{macrocode}
% \subsection{Processing \TXN@cmd{Caput} for a \TXN@cmd{titulus} object}
%    \begin{macrocode}
\def \TXN@caput@titulus #1{%
  \edef \TXN@section@name {\@nameuse{TXN@\TXN@entity[\TXN@c]Caput}}%
%    \end{macrocode}
% Contents
%    \begin{macrocode}
  \if \TXN@empty {TXN@\TXN@entity[\TXN@c]Caput@contents}%
  \else
    \TXN@caput@titulus@contents {#1}%
  \fi
%    \end{macrocode}
% Headline
%    \begin{macrocode}
  \if \TXN@empty {TXN@\TXN@entity[\TXN@c]Caput@headline}%
  \else
    \TXN@caput@titulus@headline {#1}%
  \fi
%    \end{macrocode}
% Indexes
%    \begin{macrocode}
  \ifTXN@CollectingIndexesData
    \TXN@caput@titulus@indexes {#1}%
  \fi
}
%    \end{macrocode}
% \subsubsection{Processing \TXN@cmd{contents}}
%    \begin{macrocode}
\def \TXN@caput@titulus@contents #1{%
  \expandafter
  \ifx \csname TXN@\TXN@entity[\TXN@c]Caput@contents\endcsname
       \TXN@safe
      \gdef \TXN@section@contents {#1}%
  \else
    \global \expandafter 
    \let \expandafter \TXN@section@contents 
      \csname TXN@\TXN@entity[\TXN@c]Caput@contents\endcsname
  \fi
  \begingroup
    \def \contents ##1{\unskip\gdef \TXN@section@contents{##1}}%
    \let \notcontents = \TXN@unskip@gobble
    \let \headline = \TXN@unskip@gobble
    \let \notheadline = \@firstofone
    \let \indexes = \TXN@unskip@gobble
    \let \addfirstline = \relax
    \setbox \z@ = \hbox {#1}%
  \endgroup
  \protected@write \@auxout
    {\let \label = \@gobble 
     \let \index = \@gobble
     \let \glossary = \@gobble
     \let \notcontents = \@gobble 
     \let \headline = \@gobble
     \let \notheadline = \@firstofone 
     \let \indexes = \@gobble
     \let \relsize = \@gobble
     \let \RelSize = \@gobble
     \let \LetterSpace = \@firstofone
     \let \letterspace = \@firstofone
     \let \LETTERspace = \@firstofone
     \let \addfirstline = \relax
     \def \\{\protect\\}%
    }%
    {\string \@writefile {toc}{\protect \contentsline
      {\TXN@section@name}{\TXN@section@contents}{\thepage}}}%
}
%    \end{macrocode}
% \subsubsection{Processing \TXN@cmd{headline}}
%    \begin{macrocode}
\def \TXN@caput@titulus@headline #1{%
  \if \TXN@x {TXN@\TXN@entity[\TXN@c]Caput@headline}\TXN@safe
    \gdef \TXN@section@headline {#1}%
  \else
    \expandafter \let \expandafter \TXN@section@headline 
      \csname TXN@\TXN@entity[\TXN@c]Caput@headline\endcsname
  \fi
  \begingroup 
    \def \headline ##1{\unskip\gdef \TXN@section@headline{##1}}%
    \let \notheadline = \TXN@unskip@gobble
    \let \contents = \TXN@unskip@gobble
    \let \notcontents = \@firstofone
    \let \indexes = \TXN@unskip@gobble
    \let \addfirstline = \relax
    \setbox \z@ = \hbox {#1}%
    \ifx \empty \TXN@section@headline 
    \else
%     \protected@xdef\ttl@prevmarks{\ttl@marks}%
      \csname \TXN@section@name mark\expandafter\endcsname
        \expandafter {\TXN@section@headline}%
%     \gdef\ttl@prevmarks{\ttl@marks}%
    \fi
  \endgroup
}
%    \end{macrocode}
% \subsubsection{Processing \TXN@cmd{indexes}}
%    \begin{macrocode}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@caput@titulus@indexes #1{%
  \ifnum \TXN@pass = \tw@
    \TXN@sw@true
    \if \TXN@empty {TXN@\TXN@entity[\TXN@c]Caput@index}%
      \TXN@sw@false
    \else
      \xdef \TXN@index@type {%
        \@nameuse{TXN@\TXN@entity[\TXN@c]Caput@index@type}}%
      \expandafter
      \TXN@caput@titulus@indexes@type \TXN@index@type \TXN@nil
      \TXN@sw@false
      \def \TXN@titulus@article {0}%
      \expandafter
      \TXN@caput@titulus@indexes@check \TXN@index@flags\TXN@nil
    \fi
    \ifTXN@sw
      \if \TXN@x {TXN@\TXN@entity[\TXN@c]Caput@index}\TXN@safe
        \gdef \TXN@indexed@title {#1}%
      \else
        \expandafter \let \expandafter \TXN@indexed@title 
          \csname TXN@\TXN@entity[\TXN@c]Caput@index\endcsname
      \fi
      \begingroup 
        \gdef \TXN@addfirstline {}%
        \def \addfirstline {\unskip\gdef \TXN@addfirstline {:}}%
        \def \indexes ##1{\unskip\gdef \TXN@indexed@title{##1}}%
        \let \notcontents = \@firstofone
        \let \notheadline = \@firstofone
        \let \contents = \TXN@unskip@gobble
        \let \notcontents = \TXN@unskip@gobble
        \setbox \z@ = \hbox {#1}%
        \ifx \empty \TXN@indexed@title
        \else
          \TXN@get@page@column {\TXNl@linenumber}%
          \TXN@make@sort@key {\TXN@indexed@title}%
          \ifnum \TXN@titulus@article > \z@
            \expandafter 
              \TXN@articles@process \expandafter {\the\toks@i}%
          \fi
          \global \toks@iii = \toks@i
          \global \toks@i = \expandafter {\TXN@indexed@title}%
          \ifnum \TXN@titulus@article = \@ne
            \expandafter 
            \TXN@articles@process \expandafter {\the\toks@i}%
          \fi
          \ifx \empty \TXN@addfirstline
            \immediate \write \TXN@idy {%
              {\the\toks@iii}{\the\toks@i}%
              {\TXN@index@type\TXN@addfirstline}{\TXN@page@number}%
              {\@nameuse{TXN@index@numeri@\TXN@index@type}}%
              }%
          \else
            \edef \TXN@temp {\toks@ = {%
              {\the\toks@iii}{\the\toks@i}%
              {\TXN@index@type\TXN@addfirstline}{\TXN@page@number}%
              {\noexpand\csname TXN@index@numeri@\TXN@index@type\endcsname}%
              }}%
            \TXN@temp
            \xdef \TXN@index@pending {\the\toks@}%
            \xdef \TXN@index@pending@key {\the\toks@iii}%
            \global \TXN@index@next@first@linetrue
            \TXN@enable@first@lines 
          \fi
        \fi
      \endgroup
    \fi
  \fi
}
\def \TXN@caput@titulus@indexes@type #1#2\TXN@nil{%
  \def \TXN@index@type {#1}%
}
\def \TXN@caput@titulus@indexes@check #1{%
  \ifx \TXN@nil #1\relax
  \else
    \expandafter
    \ifx \TXN@index@type #1\relax
      \TXN@sw@true
      \TXN@exxxpandafter \TXN@caput@titulus@indexes@check@bis
    \else
      \TXN@exxxpandafter \TXN@caput@titulus@indexes@check
    \fi
  \fi
}
\def \TXN@caput@titulus@indexes@check@bis #1{%
  \expandafter
  \ifx \TXN@index@type l\relax
  \else
    \ifx '#1\relax
      \def \TXN@titulus@article {1}%
    \else
      \ifx "#1\relax
        \def \TXN@titulus@article {2}%
      \fi
    \fi
  \fi
  \ifx \TXN@nil #1\relax
  \else
    \expandafter \TXN@caput@titulus@indexes@check
  \fi
}
%    \end{macrocode}
% \subsection{Processing \TXN@cmd{Caput} for a \TXN@cmd{numerus} object}
%    \begin{macrocode}
\def \TXN@caput@numerus #1{%
%<debug> \TXN@trace [#1]\TXN@caput@numerus
  \if \TXN@empty {TXN@numerus[#1]Caput}%
  \else
    \edef \TXN@section@name {\@nameuse{TXN@numerus[#1]Caput}}%
%    \end{macrocode}
% Contents
%    \begin{macrocode}
    \if \TXN@empty {TXN@numerus[#1]Caput@contents}%
    \else
      \if \TXN@x {TXN@numerus[#1]Caput@contents}\TXN@safe
        \gdef \TXN@section@contents {\string\numberline
            {\@nameuse {the\csname TXN@numerus[#1]name\endcsname}}}%
      \else
        \global \expandafter
        \let \expandafter \TXN@section@contents 
          \csname TXN@numerus[#1]Caput@contents\endcsname
      \fi
      \protected@write \@auxout {}%
        {\string \@writefile {toc}{\protect \contentsline
          {\TXN@section@name}{\TXN@section@contents}{\thepage}}}%
    \fi
%    \end{macrocode}
% Headline
%    \begin{macrocode}
    \if \TXN@empty {TXN@numerus[#1]Caput@headline}%
    \else
      \if \TXN@x {TXN@numerus[#1]Caput@headline}\TXN@safe
        \xdef \TXN@section@headline {%
          \@nameuse {the\csname TXN@numerus[#1]name\endcsname}}%
      \else
        \expandafter \let \expandafter \TXN@section@headline 
          \csname TXN@numerus[#1]Caput@headline\endcsname
      \fi
     \ifnum \TXN@pass = \tw@
         \ifNewPage
           \if@specialpage
           \else
             \global \FirstLineOfPagetrue
           \fi
         \fi
     \fi
       \TXNt@set@numerus@marks 
    \fi
  \fi
}
%    \end{macrocode}
% \subsection {\TXN@cmd{thecontentslabelfinal}}
% If |\thecontentslabel| does not contain a period, the
% macro returns its contents, otherwise
% it returns the text following the last period.
%    \begin{macrocode}
\def \thecontentslabelfinal {%
  \expandafter \TXN@tclf \thecontentslabel.\TXN@nil}
\def \TXN@tclf #1.#2\TXN@nil{%
  \ifx \empty#2\empty
    #1\relax
  \else
    \TXN@tclf@bis #2\TXN@nil#1\TXN@nil
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@tclf@bis #1#2\TXN@nil#3\TXN@nil{%
  \if .#1 #3\relax
  \else
    \TXN@tclf #1#2.\TXN@nil
  \fi
}
%    \end{macrocode}
% \subsection {\TXN@cmd{firstlinetitlemarks}}
% |\firstlinetitlemarks| provides the type of mark discussed on page 260
% of \TeXbook: ``What we want [...] is a cross between |\topmark| and
% |\firstmark|: something that will reflect the mark text that represents
% the state of affairs just after the first line of the page. And \TeX\ 
% doesn't provide that.''
%    \begin{macrocode}
\newif \ifFirstLineOfPage
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand {\FirstLineTitleMarks}{%
  \ifTXN@lineating
  \else
    \global \TXN@lineatingtrue
    \TXN@run@LaTeX@again@reason \TXN@run@LaTeX@again@fl@mark
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \firstlinetitlemarks {%
  \FirstLineTitleMarks
  \ifFirstLineOfPage 
    \global \FirstLineOfPagefalse
     \firsttitlemarks
  \else
    \toptitlemarks
  \fi
}
%    \end{macrocode}
% To reset the switch at the appropriate times we have to `hook' into
% some \LaTeX{} commands.
%    \begin{macrocode}
\let \TXN@pagestyle = \pagestyle
\def \pagestyle {%
  \global \FirstLineOfPagefalse
  \TXN@pagestyle
}
\let \TXN@thispagestyle = \thispagestyle
\def \thispagestyle {%
  \global \FirstLineOfPagefalse
  \TXN@thispagestyle
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@tableofcontents {%
  \ifnum \TXN@pass = \@ne
    \TXN@run@LaTeX@again@reason \TXN@run@LaTeX@again@toc
  \fi
  \TXN@save@tableofcontents
}
%    \end{macrocode}
% \section{Preparing and processing the index file} 
%    \begin{macrocode}
\newif \ifTXN@BuildingIndexes
\newif \ifTXN@IndexesInitialized
\newif \ifTXN@CollectingIndexesData
\newif \ifTXN@IndexesBuilt
\newif \ifTXN@index@first@lines
\newif \ifTXN@index@next@first@line
%    \end{macrocode}
% The sorted indexes file
%    \begin{macrocode}
\newread \TXN@idz
%    \end{macrocode}
% \subsection{Collecting the information for indexes}
%
% \subsubsection{The \TXN@cmd{BuildIndexes} command}
%    \begin{macrocode}
\newcommand {\BuildIndexes}[2][t]{%
%<debug> \TXN@trace \BuildIndexes
  \ifTXN@outside@preamble
    \PackageError {TEXNIKA} 
      {\protect\BuildIndexes\space can be used only in the preamble}
      {The command must occur before \protect\begin{document}}%
  \fi
  \@ifpackageloaded{poetry}{\TXN@poetrytrue}{}%
  \ifTXN@poetry
  \else
    \PackageError {TEXNIKA} 
      {The `poetry' package is not loaded}
      {The `poetry' package is required for processing indexes}%
  \fi
%    \end{macrocode}
% Check the command argument
%    \begin{macrocode}
  \global \TXN@IndexesBuiltfalse
  \def \TXN@parameter {#2}%
  \def \TXN@temp {yes}%
  \ifx \TXN@parameter \TXN@temp
    \global \TXN@BuildingIndexestrue
  \else
    \def \TXN@temp {no}%
    \ifx \TXN@parameter \TXN@temp
      \global \TXN@BuildingIndexesfalse
    \else
      \TXN@sw@false
      \ifx \empty \TXN@parameter 
        \TXN@sw@true
      \else
        \def \TXN@temp {done}%
        \ifx \TXN@parameter \TXN@temp
          \TXN@sw@true
        \fi
      \fi
      \ifTXN@sw
        \global \TXN@BuildingIndexesfalse
        \global \TXN@IndexesBuilttrue
      \else
        \def \TXN@temp {toc}%
        \ifx \TXN@parameter \TXN@temp
          \TXN@indexes@toc 
        \else
        \PackageError {TEXNIKA} 
          {Invalid argument for \protect\BuildIndexes}
          {Valid arguments are: yes no done (or \protect\empty) toc}%
        \fi
      \fi
    \fi
  \fi
%    \end{macrocode}
%
%    \begin{macrocode}
  \ifTXN@BuildingIndexes
    \TXN@get@index@flags {#1}%
  \fi
}
%    \end{macrocode}
% Use the toc from the previous run and prevent writing of a new toc
%    \begin{macrocode}
\def \TXN@indexes@toc {%
  \global \TXN@IndexesBuilttrue
  \def \@starttoc ##1{%
    \begingroup
      \makeatletter
      \@input{\jobname.toc}%
      \makeatother
    \endgroup
  }%
  \let \TXN@writefile = \@writefile
  \def \@writefile ##1##2{%
    \def \TXN@temp {toc}%
    \def \TXN@parameter {##1}%
    \ifx \TXN@temp \TXN@parameter
    \else
      \TXN@writefile ##1##2%
    \fi
  }%
}
%    \end{macrocode}
% \paragraph{Processing the indexes flags}
%    \begin{macrocode}
\def \TXN@get@index@flags #1{%
  \gdef \TXN@index@flags {}%
  \toks@ = {*}%
  \TXN@get@index@flags@bis #1\TXN@nil
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@get@index@flags@bis #1{%
%<debug> \TXN@trace \TXN@get@index@flags@bis
  \ifx \TXN@nil #1\relax
  \else
    \ifcat a\noexpand#1\relax
      \toks@ = {#1}%
      \xdef \TXN@index@flags {\TXN@index@flags#1}%
      \TXN@xdef {TXN@index@numeri@\the\toks@}{}%
      \TXN@exxxpandafter \TXN@get@index@flags@ter
    \else
      \PackageError {TEXNIKA} 
        {Misplaced optional parameter}
        {The optional parameter must come after an entry type (a letter)}%
    \fi
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@get@index@flags@ter {%
%<debug> \TXN@trace \TXN@get@index@flags@ter
  \futurelet \TXN@token \TXN@get@index@flags@quater
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@get@index@flags@quater {%
%<debug> \TXN@trace \TXN@get@index@flags@quater
  \let \next = \TXN@get@index@flags@bis
  \ifx \TXN@token \TXN@nil
  \else
    \ifcat a\noexpand\TXN@token
    \else
      \ifx '\TXN@token
        \let \next = \TXN@get@index@flags@quinquies
      \else
        \ifx "\TXN@token
          \let \next = \TXN@get@index@flags@quinquies
        \else
          \let \next = \TXN@get@index@flags@numerus
        \fi
      \fi
    \fi
  \fi
  \next
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@get@index@flags@quinquies #1{%
%<debug> \TXN@trace \TXN@get@index@flags@quinquies
  \expandafter
  \ifx \the\toks@ l\relax
    \PackageError {TEXNIKA} 
      {The option #1 cannot be used after 'l'}
      {It makes no sense to postpone the article for a first line}%
  \fi
  \xdef \TXN@index@flags {\TXN@index@flags#1}%
  \TXN@get@index@flags@ter 
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@get@index@flags@numerus #1{%
%<debug> \TXN@trace \TXN@get@index@flags@numerus
  \ifcat \relax \noexpand #1\relax
  \else
    \PackageError {TEXNIKA} 
      {Extraneous information in the optional argument}
      {Only \protect\numerus\space subclasses can occur in %
       the optional parameter}%
  \fi
  \TXN@get@subclass@number \numerus #1\relax
  \ifnum \@tempcnta < \z@
    \PackageError {TEXNIKA} 
      {\protect#1\space is not a \protect\numerus\space subclass}
      {Only \protect\numerus\space subclasses can occur in %
       the optional parameter}%
  \else
    \TXN@toks@a = \expandafter \expandafter \expandafter 
      {\csname TXN@index@numeri@\the\toks@\endcsname}%
    \TXN@toks@b = \expandafter {%
      \csname c@\expandafter\@gobble\string#1\endcsname=}%
    \TXN@toks@c = \expandafter {%
      \csname the\expandafter\@gobble\string#1\endcsname}%
    \TXN@xdef {TXN@index@numeri@\the\toks@}%
      {\the\TXN@toks@a\the\TXN@toks@b\the\TXN@toks@c}%
  \fi
  \TXN@get@index@flags@ter 
}
\newif \ifTXN@first@lines@enabled
%    \end{macrocode}
% \subsubsection{The \TXN@cmd{Indexes} command}
%    \begin{macrocode}
\newcommand {\Indexes} {%
  \ifTXN@outside@preamble
  \else
    \PackageError {TEXNIKA} 
      {\protect\Indexes\space cannot be used in the preamble}
      {The command must occur after \protect\begin{document}}%
  \fi

  \@ifstar {\TXN@indexes@star}{\TXN@indexes}%
}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand {\TXN@indexes}[1][]{%
  \TXN@sw@false
  \ifTXN@withinVersus
    \TXN@sw@true
  \else
    \ifTXN@withinProsa
      \TXN@sw@true
    \fi
  \fi
  \ifTXN@sw
    \PackageError {TEXNIKA} 
      {\protect\Indexes\space cannot be used within a domain}
      {The command must appear outside Versus and Prosa}%
  \fi
  \ifTXN@BuildingIndexes
    \ifTXN@IndexesInitialized
    \else
      \global \TXN@IndexesInitializedtrue
      \global \TXN@lineatingtrue
      \ifnum \TXN@pass = \@ne
        \TXN@run@LaTeX@again@reason \TXN@run@LaTeX@again@firstlines 
      \fi
      \ifnum \TXN@pass = \tw@
        \newwrite \TXN@idy
        \immediate \openout \TXN@idy = \jobname.idy\relax
        \toks@ = {#1}%
        \TXN@Indexes@insert@separators 
      \fi
      \if \TXN@option l\TXN@index@flags
        \TXN@enable@first@lines 
        \global \TXN@index@first@linestrue
      \fi
    \fi
    \global \TXN@CollectingIndexesDatatrue
  \fi
  \ifTXN@IndexesBuilt
    \ifnum \TXN@pass = \@ne
      \TXN@run@LaTeX@again@reason \TXN@run@LaTeX@again@firstlines 
    \fi
  \fi
}
%    \end{macrocode}
% Insert the separators (the letters A-Z)
%    \begin{macrocode}
\def \TXN@Indexes@insert@separators {%
  \TXN@counter = \@ne
  \TXN@counter@a = \@nameuse{TXN@alphabetum@\the\toks@ @count}%
  \advance \TXN@counter@a by \@ne
  \@whilenum \TXN@counter < \TXN@counter@a \do {%
    \TXN@Indexes@separators@bis
    \immediate \write \TXN@idy {%
      {\TXN@temp}%
      {\TXN@temp}%
      {/}%
      {0}%
      {}%
      }%
    \advance \TXN@counter by \@ne
  }%
}
\def \TXN@Indexes@separators@bis {%
  \edef \TXN@temp {\expandafter \@secondoftwo
    \ifcase \the\TXN@counter\csname TXN@alphabetum@\the\toks@\endcsname}%
}
%    \end{macrocode}
% \subsubsection{The \TXN@cmd{Indexes*} command}
%    \begin{macrocode}
\def \TXN@indexes@star {%
  \TXN@sw@false
  \ifTXN@withinVersus
    \TXN@sw@true
  \else
    \ifTXN@withinProsa
      \TXN@sw@true
    \fi
  \fi
  \ifTXN@sw
    \PackageError {TEXNIKA} 
      {\protect\Indexes\space cannot be used within a domain}
      {The command must appear outside Versus and Prosa}%
  \fi
  \ifTXN@BuildingIndexes
    \ifTXN@CollectingIndexesData
      \global \TXN@CollectingIndexesDatafalse
    \else
      \PackageError {TEXNIKA} 
        {There was no previous \protect\Indexes\space command}
        {\protect\Indexes* must come after \protect\Indexes}%
    \fi
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@enable@first@lines {%
  \ifTXN@first@lines@enabled
  \else
    \global \TXN@first@lines@enabledtrue
    \ifnum \TXN@pass = \tw@
      \newcount \PTR@fl@count
      \newread  \PTR@fl
      \newread  \PTR@fl@bis
      \immediate \openin \PTR@fl = \jobname.tex\relax
      \immediate \openin \PTR@fl@bis = \jobname.tex\relax
      \PTR@fl@count = \z@
    \fi
 \fi
}
%    \end{macrocode}
% \subsubsection{Making the sort key}
%    \begin{macrocode}
\def \TXN@commands {%
    \\1\emph\\1\textrm\\1\textsf\\1\texttt\\1\textmd\\1\textbf
    \\1\textup\\1\textsl\\1\textit\\1\textsc\\1\textnormal
    \\0\rmfamily\\0\sffamily\\0\ttfamily\\0\mdseries\\0\upshape
    \\0\slshape\\0\itshape\\0\scshape\\0\normalfont
    \\0\em\\0\rm\\0\bf\\0\it\\0\tt\\0\sc\\0\sl\\0\sf
    \\0\tiny\\0\scriptsize\\0\footnotesize\\0\small
    \\0\normalsize\\0\large\\0\Large\\0\LARGE\\0\huge\\0\Huge
    \\1\MakeUppercase\\7\textsuperscript\\8\footnote
    \\1\textfrak\\1\textswab\\1\textgoth
    \\0\frakfamily\\0\swabfamily\\0\gothfamily
%    \end{macrocode}
%
%    \begin{macrocode}
    \\1\incipit\\1\persona
    \\0\0\\0\1\\0\2\\0\3\\0\4\\0\5\\0\6\\0\7\\0\8\\0\9
    \\0\auto\\0\Auto\\0\noincipit
    \\0\textemdash\\0\textendash\\0\textexclamdown\\0\textquestiondown
    \\0\textquotedblleft\\0\textquotedblright
    \\0\textquoteleft\\0\textquoteright
    \\0\guillemetleft\\0\guillemetright
    \\0\textemdash\\0\textendash
    \\0\addfirstline
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@make@sort@key #1{%
%<debug> \TXN@trace \TXN@make@sort@key
  \begingroup
    \def \\##1##2{%
      \if 1##1\relax
        \def ##2####1{####1}%
      \else
        \if 0##1\relax
          \def ##2{}%
        \fi
      \fi}%
    \TXN@commands
    \def \\{}%
    \edef \TXN@temp {#1}%
    \global \toks@i = \expandafter {\TXN@temp}%
  \endgroup
  \toks@ = \toks@i
  \global \toks@i = {}%
  \expandafter \TXN@make@sort@key@bis \the\toks@\TXN@nil
}
\def \TXN@make@sort@key@bis #1{%
  \let \next = \TXN@make@sort@key@bis
  \ifcat \noexpand#1a\relax
    \global \toks@i = {#1}%
    \let \next = \TXN@make@sort@key@ter
  \fi
  \next
}
\def \TXN@make@sort@key@ter #1\TXN@nil{%
  \global \toks@i = \expandafter {\the\toks@i#1}%
  \expandafter \TXN@trim \expandafter {\the\toks@i}%
  \global \toks@i = \TXN@trimmed
}
%    \end{macrocode}
% \subsubsection{Moving an article at the end ot the title}
%
%    \begin{macrocode}
\def \TXN@articles@english {\*\space{The}\*\space{A}\*\space{An}}
%    \end{macrocode}
% Each entry has two arguments: the terminating character (either
% space or apostrophe) and the article itself.
%    \begin{macrocode}
\def \TXN@articles@italian {%
  \*\space{Il}\*\space{La}\*\space{Lo}\*\space{I}\*\space{Gli}%
  \*\space{Le}\*\space{Un}\*\space{Una}\*'{L}\*'{Un}}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@articles@french {%
  \*\space{Le}\*\space{La}\*\space{Les}%
  \*\space{Un}\*\space{Une}\*'{L}\*'{Un}}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@articles@german {%
  \*\space{Der}\*\space{Die}\*\space{Das}%
  \*\space{Ein}\*\space{Eine}}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@articles@spanish {%
  \\\space{El}\\\space{La}\\\space{Los}\\\space{Las}%
  \\\space{Un}\\\space{Una}}
%    \end{macrocode}
% Set if the string has at least one space/apostrophe
%    \begin{macrocode}
\newif \ifTXN@article@space
\newif \ifTXN@article@apostrophe
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@articles@process #1{%
%<debug> \TXN@trace \TXN@articles@process
  \global \toks@i = {#1}%
  \TXN@sw@false
  \TXN@articles@check@space #1 \TXN@nil
  \TXN@articles@check@apostrophe #1'\TXN@nil
  \ifTXN@sw
    \TXN@sw@false
    \begingroup
      \let \\=\relax
      \let \*= \TXN@articles@process@article
      \@nameuse {TXN@articles@%
                 \ifx \@undefined\languagename english%
                 \else \languagename\fi}%
    \endgroup
  \fi
}
%    \end{macrocode}
% Check if the strings contain a space/apostrophe
%    \begin{macrocode}
\def \TXN@articles@check@space #1 #2\TXN@nil {%
  \@ifmtarg {#2} {\TXN@article@spacefalse}
                 {\TXN@sw@true\TXN@article@spacetrue}}           
\def \TXN@articles@check@apostrophe #1'#2\TXN@nil {%
  \@ifmtarg {#2} {\TXN@article@apostrophefalse}
                 {\TXN@article@apostrophetrue\TXN@sw@true}}           
%    \end{macrocode}
% Check if the article occurs at the start of the string
%    \begin{macrocode}
\def \TXN@articles@process@article #1#2{%
  \ifTXN@sw
  \else
    \ifx \space #1\relax
      \ifTXN@article@space
        \gdef \TXN@gtemp {#2}%
        \expandafter \TXN@article@check@space \the\toks@i\TXN@nil
      \fi
    \fi
  \fi
  \ifTXN@sw
  \else
    \ifx '#1\relax
      \ifTXN@article@apostrophe
        \gdef \TXN@gtemp {#2}%
        \expandafter \TXN@article@check@apostrophe \the\toks@i'\TXN@nil
      \fi
    \fi
  \fi
}
%    \end{macrocode}
% Extract the initial string and compare it with the article
%    \begin{macrocode}
\def \TXN@article@check@space #1\TXN@nil {%
  \TXN@article@check@space@bis #1 \TXN@nil}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@article@check@space@bis #1 #2 \TXN@nil {%
  \gdef \TXN@gtemp@bis {#1}%
  \ifx \TXN@gtemp \TXN@gtemp@bis
    \TXN@article@swap #2\TXN@nil#1\TXN@nil
  \fi
}
\def \TXN@article@check@apostrophe #1'#2'\TXN@nil {%
  \gdef \TXN@gtemp@bis {#1}%
  \ifx \TXN@gtemp \TXN@gtemp@bis
    \TXN@article@swap #2\TXN@nil#1'\TXN@nil
  \fi
}
%    \end{macrocode}
% Move the article at the end of the string
%    \begin{macrocode}
\def \TXN@article@swap #1#2\TXN@nil#3\TXN@nil{%
    \TXN@sw@true
    \edef \TXN@temp {\global\toks@i={#1}}%
    \uppercase \expandafter {\TXN@temp}%
    \global \toks@i = \expandafter {\the\toks@i#2, #3}%
}
%    \end{macrocode}
% \subsection{Typesetting an index}
%    \begin{macrocode}
\newcommand {\TypesetIndex}[3][t]{%
%<debug> \TXN@trace \TypesetIndex
  \ifTXN@IndexesBuilt
    \ifnum \TXN@pass = \tw@
      \xdef \TXN@typeset@types {#1}%
      \IfFileExists {\jobname.idz}
        {}
        {\PackageError {TEXNIKA} 
          {The \jobname.idz file does not exist}
          {}}%
      \long \def \TXN@TypesetIndex@postlude {#3}%
      \begingroup
      \TXN@TypesetIndex@prelude {#1}%
      #2\relax
      \TXN@TypesetIndex@prelude@bis
      \TXN@exxxpandafter \TXN@TypesetIndex@start
    \fi
  \fi
}
%    \end{macrocode}
% \subsubsection{Code executed before the command argument}
%    \begin{macrocode}
\def \TXN@TypesetIndex@prelude #1{%
%    \end{macrocode}
% Prevent printing of other |\numerus| subclasses
%    \begin{macrocode}
  \TXN@counter = \TXN@numerus@max \TXN@safe
  \loop
    \TXN@def {TXN@numerus[\TXN@c]printing}{0}%
  \ifnum \TXN@counter > \z@ 
    \advance \TXN@counter by \m@ne
  \repeat
  \TXN@withinIndexestrue
%    \end{macrocode}
% Create the |\titulus| subclass for the separator and disable incipit
%    \begin{macrocode}
  \Novus \titulus \IndexSeparator
  \Facies         {}
  \SpatiumSupra   {.5\leading}
  \Facies \incipit {}
%    \end{macrocode}
% Create the |\textus| and |\numerus| subclasses for the line
% types in the optional argument. The subclasses for 'l' are
% always created (for |\addfirstline|)
%    \begin{macrocode}
  \def \TXN@indexes@types {#1}%
  \if \TXN@option l\TXN@indexes@types
  \else
    \edef \TXN@indexes@types {l\TXN@indexes@types}%
  \fi
  \expandafter 
  \TXN@TypesetIndex@prelude@create \TXN@indexes@types \TXN@nil
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@TypesetIndex@prelude@create #1{%
  \ifx \TXN@nil #1\relax
  \else
    \ifcat a\noexpand#1\relax
      \edef \TXN@temp {\noexpand\Novus* \noexpand\textus 
        \expandafter\noexpand\csname #1IndexEntryText\endcsname}%
      \TXN@temp
      \Facies        {##1}
      \edef \TXN@temp {\noexpand\Novus* \noexpand\numerus 
        \expandafter\noexpand\csname #1IndexEntryPage\endcsname}%
      \TXN@temp
      \Facies         {##1}
      \Locus          {\rightmargin}
    \fi
    \expandafter \TXN@TypesetIndex@prelude@create
  \fi
}
%    \end{macrocode}
% \subsubsection{Code executed after the command argument}
%    \begin{macrocode}
\def \TXN@TypesetIndex@prelude@bis {%
%    \end{macrocode}
% Switch |\auto| off and set the |\textus| position
%    \begin{macrocode}
  \def \PTR@auto@mode {}%
  \Locus \textus   {\leftmargin+\z@}
  \Locus \textus   {+\z@}
  \Forma \strophae {}
%    \end{macrocode}
% Compute how much space to reserve for the page number
%    \begin{macrocode}
  \TXN@dim@a = \z@
  \expandafter 
  \TXN@TypesetIndex@page@digit \TXN@indexes@types \TXN@nil
%    \end{macrocode}
%
%    \begin{macrocode}
  \TXN@get@page@column {\TXNl@linenumber}%
  \count@ = \TXN@page@number
  \setbox\z@ = \hbox {\hskip
    \ifnum \count@ > 999 4.5\else
    \ifnum \count@ > 99 3.5\else 2.5\fi\fi\TXN@dim@a}%
  \Modus \textus   {\measure{-\wd\z@}}
%    \end{macrocode}
% Allow for folded lines
%    \begin{macrocode}
  \Locus \excessus {\textleftmargin + 1em}
  \Facies          {##1}
  \Modus           {\unhyphenated}  
}
%    \end{macrocode}
% Compute the maximum width of a digit in a page number
%    \begin{macrocode}
\def \TXN@TypesetIndex@page@digit #1{%
  \ifx \TXN@nil #1\relax
  \else
    \ifcat a\noexpand#1\relax
      \setbox\z@ = \hbox {%
        \expandafter \Locus \csname #1IndexEntryPage\endcsname{}%
        \@nameuse{#1IndexEntryPage}*{9}}%
      \ifdim \wd\z@ > \TXN@dim@a
        \TXN@dim@a = \wd\z@
      \fi
    \fi
    \expandafter \TXN@TypesetIndex@page@digit
  \fi
}
%    \end{macrocode}
% \subsubsection{Typesetting an index line}
%    \begin{macrocode}
\def \TXN@TypesetIndex@start {%
 \immediate \openin \TXN@idz = \jobname.idz\relax
 \Versus
 \parskip 0pt plus 1pt
 \TXN@TypesetIndex@read
} 
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@TypesetIndex@read {%
  \makeatletter
  \immediate \read \TXN@idz to \TXN@idz@line
  \makeatother
  \ifeof \TXN@idz 
    \expandafter \TXN@TypesetIndex@finish
  \else
    \expandafter \TXN@TypesetIndex@line
  \fi
}
%    \end{macrocode}
% At the end of the .idz file
%    \begin{macrocode}
\def \TXN@TypesetIndex@finish {%
  \immediate \closein \TXN@idz
  \endVersus
  \TXN@TypesetIndex@postlude
  \endgroup
}
%    \end{macrocode}
% Typeset an index line
%    \begin{macrocode}
\def \TXN@indexes@initial {}
\newif \ifTXN@index@normal@line
\def \TXN@TypesetIndex@line {%
  \expandafter \TXN@TypesetIndex@line@bis \TXN@idz@line
}
\def \TXN@TypesetIndex@line@bis #1#2#3#4#5{%
  \def \TXN@index@line@flags {#3}%
  \TXN@get@line@type #3\TXN@nil
%    \end{macrocode}
%
%    \begin{macrocode}
  \if /\TXN@line@type
    \def \TXN@indexes@initial {#2}%
  \fi
%    \end{macrocode}
% Check if line is to be typeset
%    \begin{macrocode}
  \TXN@sw@false
  \if \TXN@option +\TXN@index@line@flags
    \if \TXN@option t\TXN@typeset@types
      \TXN@sw@true
    \fi
  \else
    \if \TXN@option \TXN@line@type \TXN@typeset@types
      \TXN@sw@true
    \fi
  \fi
  \ifTXN@sw
    \TXN@toks@a = {#2}%
    \ifx \empty \TXN@indexes@initial
    \else
      \IndexSeparator \TXN@indexes@initial
      \def \TXN@indexes@initial {}%
      \ifx \empty \TXN@FaciesIncipit
      \else
        \TXN@TypesetIndex@incipit #2\TXN@nil
      \fi
    \fi
    \expandafter \TXN@get@subclass@number \expandafter \textus
      \csname \TXN@line@type IndexEntryText\endcsname
    \TXN@counter@a = \@tempcnta
%    \end{macrocode}
%
%    \begin{macrocode}
    \TXN@index@normal@linetrue
    \if \TXN@option :\TXN@index@line@flags
      \TXN@index@normal@linefalse
    \else
      \if \TXN@option *\TXN@index@line@flags
        \TXN@index@normal@linefalse
      \fi
    \fi
    \TXN@leadersfalse
    \ifTXN@index@normal@line
      \@nameuse{\TXN@line@type IndexEntryPage}*{#4}%
      \edef \TXN@flags {%
        \@nameuse{TXN@textus[\the\TXN@counter@a]flagsModus@recto}}%
      \if \TXN@option \TXN@o@Leaders \TXN@flags  
        \TXN@leaderstrue
        \edef \TXN@leaders@width {%
          \@nameuse{TXN@textus[\the\TXN@counter@a]leaders@recto}}%
      \fi
      \toks@ = {#5}%
    \else
      \toks@ = {}%
      \TXN@TypesetIndex@line@ter #5\TXN@nil
    \fi
    \the\toks@
    \toks@ = {}%
    \if \TXN@option *\TXN@index@line@flags
    \else
      \toks@ = {\let \\=\TXN@TypesetIndex@line@esc@esc
                \let \addfirstline = \relax
                \let \incipit = \TXN@self
                \let \1=\ignorespaces \let \2=\ignorespaces
                \let \3=\ignorespaces \let \4=\ignorespaces
                \let \5=\ignorespaces \let \6=\ignorespaces
                \let \7=\ignorespaces \let \8=\ignorespaces
                \let \9=\ignorespaces \def \persona #1{\ignorespaces}
               }%
    \fi
    \leavevmode 
    \@nameuse{TXN@textus[\the\TXN@counter@a]Facies}%
      {\the\toks@\the\TXN@toks@a}\PTR@atendofline
    \@nameuse{\TXN@line@type IndexEntryPage}{}%
    \if \TXN@option :\TXN@index@line@flags
      \penalty \@M
    \fi
    \if \TXN@option *\TXN@index@line@flags
      \penalty \@M
    \fi
  \fi
  \TXN@TypesetIndex@read
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@TypesetIndex@line@ter #1{%
  \ifx \TXN@nil #1\relax
  \else
    \ifcat \relax \noexpand #1\relax
      \toks@ = \expandafter {\the\toks@#1=0\relax}%
    \fi
    \expandafter \TXN@TypesetIndex@line@ter
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand {\TXN@TypesetIndex@line@esc@esc}[1][]{\space\ignorespaces}
\def \TXN@TypesetIndex@incipit #1#2\TXN@nil{%
  \TXN@toks@a = {{\TXN@FaciesIncipit {#1}{\relax}{\relax}{\relax}}#2}%
}
%    \end{macrocode}
% The line type is always the first character
%    \begin{macrocode}
\def \TXN@get@line@type #1#2\TXN@nil {\def \TXN@line@type {#1}}
%    \end{macrocode}
% \section{Displaying \TXN@cmd{Measure} and \TXN@cmd{linewidth}} 
%    \begin{macrocode}
\newif \ifTXN@show@versus
\newif \ifTXN@show@prosa
\newif \ifTXN@show@lineate
\newif \ifTXN@show@measure
\newif \ifTXN@show@starred
%    \end{macrocode}
%
%    \begin{macrocode}
\def \ShowMeasure {%
  \TXN@show@measuretrue
  \@ifstar {\TXN@show@starredtrue\TXN@show@width}
           {\TXN@show@starredfalse\TXN@show@width}}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \ShowLineWidth {%
  \TXN@show@measurefalse
  \@ifstar {\TXN@show@starredtrue\TXN@show@width}
           {\TXN@show@starredfalse\TXN@show@width}}
%    \end{macrocode}
% The common code
%    \begin{macrocode}
\newcommand {\TXN@show@width} [1][0pt]{%
  \TXN@show@versusfalse
  \TXN@show@lineatefalse
  \ifTXNl@lineating
    \TXN@show@lineatetrue
    \TXNl@lineate \relax
  \fi
  \ifTXN@withinVersus
    \TXN@show@versustrue
    \global \PTR@par@startedfalse
    \endVersus
  \fi
  \begingroup
  \everypar = {}%
  \leftskip = \z@
  \rightskip = \z@
  \TXNcmr
  \hsize = \linewidth
  \setbox \z@ = \hbox {%
    \ttfamily
    \ifTXN@show@measure 
      \ \char`\\Measure\ %
    \else
      \ \char`\\linewidth\ %
    \fi
    \ifTXN@show@starred 
      =\ \the\ifTXN@show@measure \TXN@measure\ \else \linewidth\ \fi
    \fi
  }%
  \ifdim #1 = \z@
  \else
    \dimen@ = .5\wd\z@
    \advance \dimen@ by -.0125pt
    \setbox \z@ = \hbox {%
      \rlap{\kern \dimen@ \vrule width .025pt %
            \ifdim #1 > \z@ depth\else height -\fi#1\relax
           }\box\z@}%
    \ht\z@ = \ht\strutbox
    \dp\z@ = \dp\strutbox
  \fi
  \dimen@ = \ifTXN@show@measure \TXN@measure \else \linewidth\fi
  \advance \dimen@ by -\wd\z@
  \advance \dimen@ by -1.5em %
  \divide \dimen@ by \tw@
  \vskip .5\baselineskip
  \noindent
  \ifTXN@show@measure
    \TXN@assign \dimen@@ = 
      {TXN@textus[\TXN@theTextus]offset@\TXN@theFolio}%
    \kern \dimen@@
  \fi
  \TXN@assign \dimen@@ = {TXN@textus[\TXN@theTextus]shift}%
  \ifdim \dimen@@ = \z@
  \else
    \kern \dimen@@
    {\setbox \tw@ = \hbox {%
      \vrule height \ht\strutbox depth \dp\strutbox width .125pt}%
     \global \dimen@i = \wd\tw@
     \box \tw@
    }%
    \advance \dimen@@ by \dimen@i
    \kern -\dimen@@
  \fi
  \hbox to \dimen@ {\leftarrowfill}%
  \kern .75em \box \z@ \kern .75em %
  \hbox to \dimen@ {\rightarrowfill}%
  \vskip .5\baselineskip
  \endgroup
  \ifTXN@show@lineate
    \TXNl@lineate \TXN@process@line
  \fi
  \ifTXN@show@versus
    \expandafter \versus
  \fi
}
%<*debug>
%    \end{macrocode}
% \section{Debugging code} 
%    \begin{macrocode}
\showboxdepth=1000
\showboxbreadth=1000
\newif \ifTXN@debug
\newif \ifTXN@debug@sw
\newcount \TXN@debug@count
%    \end{macrocode}
%
% 0  control sequences  \\
% 1  boxes              \\
% 2  counters           \\
% 3  dimensions         \\
% 4  token registers    \\
% 5  macros             \\
% 6  mode               \\
% 7  spatium            \\
% 8  domain             \\
% 9  set tracingmacros  \\
% A  area               \\
% R  replay
%    \begin{macrocode}
\def \TXN@debug@options {}%
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXNdebug #1{%
  \ifx -#1\relax
    \TXN@debugfalse
  \else
    \TXN@debugtrue
    \ifx +#1\relax
      \def \TXN@debug@options {0123456}%
    \else
      \def \TXN@debug@options {#1}%
    \fi
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@debug@check #1{%
  \TXN@debug@swfalse
  \def \TXN@debug@value {#1}%
  \expandafter \TXN@debug@check@bis \TXN@debug@options\TXN@nil
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \TXN@debug@check@bis #1{%
  \ifx \TXN@nil #1\relax
  \else
    \if \TXN@debug@value #1\relax
      \TXN@debug@swtrue
    \fi
    \expandafter \TXN@debug@check@bis
 \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand {\TXN@trace}[2][\relax]{%
  \ifTXN@debug
    \TXN@debug@check {0}%
    \ifTXN@debug@sw
      \ifx \relax#1\relax 
        \def \TXN@debug@temp {}%
      \else
        \edef \TXN@debug@temp {[#1]\space}%
      \fi
      \typeout {\TXN@debug@temp \protect#2}%
    \fi
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand {\TXN@trace@box}[2][\relax]{%
  \ifTXN@debug
    \TXN@debug@check {1}%
    \ifTXN@debug@sw
      \ifx \relax #1\relax
      \else
        \typeout {[#1]\space}%
      \fi
      \TXN@debug@count = \errorcontextlines 
      \errorcontextlines = \z@
      \showbox #2\relax
      \errorcontextlines = \TXN@debug@count
    \fi
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand {\TXN@trace@count}[2][\relax]{%
  \ifTXN@debug
    \TXN@debug@check {2}%
    \ifTXN@debug@sw
      \ifx \relax #1\relax
        \def \TXN@debug@temp {}%
      \else
        \def \TXN@debug@temp {#1= }%
      \fi
      \typeout {\TXN@debug@temp /\the#2/}%
    \fi
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand {\TXN@trace@dim}[2][\relax]{%
  \ifTXN@debug
    \TXN@debug@check {3}%
    \ifTXN@debug@sw
      \ifx \relax #1\relax
        \def \TXN@debug@temp {}%
      \else
        \edef \TXN@debug@temp {[#1]\space}%
      \fi
      \typeout {\TXN@debug@temp \protect#2=\the#2}%
    \fi
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand {\TXN@trace@toks}[2][\relax]{%
  \ifTXN@debug
    \TXN@debug@check {4}%
    \ifTXN@debug@sw
      \ifx \relax #1\relax
        \def \TXN@debug@temp {}%
      \else
        \edef \TXN@debug@temp {[#1]\space}%
      \fi
      \typeout {\TXN@debug@temp \protect#2=/\the#2/}%
    \fi
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand {\TXN@trace@macro}[2][\relax]{%
  \ifTXN@debug
    \TXN@debug@check {5}%
    \ifTXN@debug@sw
      \ifx \relax #1\relax
        \def \TXN@debug@temp {}%
      \else
        \edef \TXN@debug@temp {[#1]\space}%
      \fi
      \typeout {\TXN@debug@temp \protect#2=\meaning#2}%
    \fi
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand {\TXN@trace@mode}[1][\relax]{%
  \begingroup
  \ifTXN@debug
    \TXN@debug@check {6}%
    \ifTXN@debug@sw
      \ifhmode 
        \typeout {[#1]\space Hmode}%
      \else
        \typeout {[#1]\space Vmode}%
      \fi
    \fi
  \fi
  \endgroup
}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand {\TXN@trace@spatium}[1]{%
  \ifTXN@debug
    \TXN@debug@check {7}%
    \ifTXN@debug@sw
      \typeout {Spatium: \noexpand#1 \meaning#1}%
    \fi
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand {\TXN@trace@domain}[2]{%
  \ifTXN@debug
    \TXN@debug@check {8}%
    \ifTXN@debug@sw
      \typeout {\number\inputlineno\space 
                \ifnum #1=\z@ Enter\else Leave\fi \space 
                \ifnum #2=\@ne Versus\else Prosa\fi \space 
                }%
    \fi
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand {\TXN@tracing}[1]{%
  \ifTXN@debug
    \TXN@debug@check {9}%
    \ifTXN@debug@sw
      \ifx +#1
        \global\tracingmacros=2%
        \global\tracingcommands=2%
      \else
        \global\tracingmacros=0%
        \global\tracingcommands=0%
      \fi
    \fi
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand {\TXN@trace@area} {%
  \ifTXN@debug
    \TXN@debug@check {A}%
    \ifTXN@debug@sw
      \typeout {AREA \number\TXN@area@ind  baselineskip=\the\baselineskip}%
      \typeout {height = \csname 
                TXN@area[\TXN@area@ind]height\endcsname}%
      \typeout {depth = \csname 
                TXN@area[\TXN@area@ind]depth\endcsname}%
      \typeout {first height = \csname 
                TXN@area[\TXN@area@ind]first@line@height\endcsname}%
      \typeout {right = \csname 
                TXN@area[\TXN@area@ind]rightedge\endcsname}%
      \typeout {left =  \csname 
                TXN@area[\TXN@area@ind]leftedge\endcsname}%
      \typeout {spatium = \csname 
                TXN@area[\TXN@area@ind]spatium\endcsname}%
      \typeout {stropha = \csname 
                TXN@area[\TXN@area@ind]stropha\endcsname}%
    \fi
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand {\TXN@trace@replay} {%
  \ifTXN@debug
    \TXN@debug@check {R}%
    \ifTXN@debug@sw
      \typeout {REPLAY at \number\TXN@auy@lineno: \meaning\TXN@auy@command}%
    \fi
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand {\TXN@trace@save@command} {%
  \ifTXN@debug
    \TXN@debug@check {S}%
    \ifTXN@debug@sw
      \typeout {Save command at \the\inputlineno: 
                [\the\TXNl@linenumber] \the\toks@}%
    \fi
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand {\TypeOut}[2][]{\typeout {[[#1] #2}}
\newcommand {\TypeOutCs}[2][]{\typeout {[[#1] \expandafter
             \meaning\csname#2\endcsname}}
\newcommand {\ShowMode}[1][]{\ifhmode\typeout{#1 H}\else\typeout{#1 V}\fi}
%</debug>
%    \end{macrocode}
%
% \Finale
%
\endinput
