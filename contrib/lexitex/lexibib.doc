% \def\fileversion{ver.~1.0g}
% \def\filedate{1994/12/12}
% \def\docdate {1994/12/07}
% \CheckSum{92}
%
%\iffalse
% 
% Copyright (C) 1992-1994 by Frank Bennett.  All rights reserved.
% 
% This file contains the entire LexiBib package.  The complementary
% LaTeX2e style package LexiTeX is contained in the separate file
% lexitex.doc.
% 
%
% To get started with unpacking, run this file through DOCSTRIP
% giving `driver' as the extraction option, with the extension
% `ins'.  Then run the resulting lexibib.ins file through LaTeX,
% which will strip the files.  Run lexibib.man through LaTeX
% to print the documented file.  I have tried to make the commented
% code as informative as possible; comments are welcome on the
% commentary as well as the code itself.
%
% IMPORTANT NOTICE:
% 
% You are not allowed to change this file.  You may however copy
% this file to a file with a different name and then change the
% copy if (a) you do not charge for the modified code, (b) you
% acknowledge LexiBib and its author(s) in the new file, if it
% is distributed to others, and (c) you attach these same
% conditions to the new file.
% 
% You are not allowed to distribute this file alone.  You are not
% allowed to take money for the distribution or use of this file
% (or a changed version) except for a nominal charge for copying
% etc.
% 
% You are allowed to distribute this file under the condition that
% it is distributed with all of its contents, intact.
% 
% For error reports, or offers to help make LexiTeX a more powerful,
% friendlier, and better package, please contact me on
% fbennett@clus1.ulcc.ac.uk
%\fi
%
% \DoNotIndex{\@,\@@par,\@beginparpenalty,\@empty}
% \DoNotIndex{\@flushglue,\@gobble,\@input}
% \DoNotIndex{\@makefnmark,\@makeother,\@maketitle}
% \DoNotIndex{\@namedef,\@ne,\@spaces,\@tempa}
% \DoNotIndex{\@tempb,\@tempswafalse,\@tempswatrue}
% \DoNotIndex{\@thanks,\@thefnmark,\@topnum}
% \DoNotIndex{\@@,\@elt,\@forloop,\@fortmp,\@gtempa,\@totalleftmargin}
% \DoNotIndex{\",\/,\@ifundefined,\@nil,\@verbatim,\@vobeyspaces}
% \DoNotIndex{\|,\~,\,\active,\advance,\aftergroup,\begingroup,\bgroup}
% \DoNotIndex{\cal,\csname,\def,\documentstyle,\dospecials,\edef}
% \DoNotIndex{\egroup}
% \DoNotIndex{\else,\endcsname,\endgroup,\endinput,\endtrivlist}
% \DoNotIndex{\expandafter,\fi,\fnsymbol,\futurelet,\gdef,\global}
% \DoNotIndex{\hbox,\hss,\if,\if@inlabel,\if@tempswa,\if@twocolumn}
% \DoNotIndex{\ifcase}
% \DoNotIndex{\ifcat,\iffalse,\ifx,\ignorespaces,\index,\input,\item}
% \DoNotIndex{\jobname,\kern,\leavevmode,\leftskip,\let,\llap,\lower}
% \DoNotIndex{\m@ne,\next,\newpage,\nobreak,\noexpand,\nonfrenchspacing}
% \DoNotIndex{\obeylines,\or,\protect,\raggedleft,\rightskip,\rm,\sc}
% \DoNotIndex{\setbox,\setcounter,\small,\space,\string,\strut}
% \DoNotIndex{\strutbox}
% \DoNotIndex{\thefootnote,\thispagestyle,\topmargin,\trivlist,\tt}
% \DoNotIndex{\twocolumn,\typeout,\vss,\vtop,\xdef,\z@}
% \DoNotIndex{\,,\@bsphack,\@esphack,\@noligs,\@vobeyspaces,\@xverbatim}
% \DoNotIndex{\`,\catcode,\end,\escapechar,\frenchspacing,\glossary}
% \DoNotIndex{\hangindent,\hfil,\hfill,\hskip,\hspace,\ht,\it,\langle}
% \DoNotIndex{\leaders,\long,\makelabel,\marginpar,\markboth,\mathcode}
% \DoNotIndex{\mathsurround,\mbox,\newcount,\newdimen,\newskip}
% \DoNotIndex{\nopagebreak}
% \DoNotIndex{\parfillskip,\parindent,\parskip,\penalty,\raise,\rangle}
% \DoNotIndex{\section,\setlength,\TeX,\topsep,\underline,\unskip,\verb}
% \DoNotIndex{\vskip,\vspace,\widetilde,\\,\%,\@date,\@defpar}
% \DoNotIndex{\[,\{,\},\]}
% \DoNotIndex{\count@,\ifnum,\loop,\today,\uppercase,\uccode}
% \DoNotIndex{\baselineskip,\begin,\tw@}
% \DoNotIndex{\a,\b,\c,\d,\e,\f,\g,\h,\i,\j,\k,\l,\m,\n,\o,\p,\q}
% \DoNotIndex{\r,\s,\t,\u,\v,\w,\x,\y,\z,\A,\B,\C,\D,\E,\F,\G,\H}
% \DoNotIndex{\I,\J,\K,\L,\M,\N,\O,\P,\Q,\R,\S,\T,\U,\V,\W,\X,\Y,\Z}
% \DoNotIndex{\1,\2,\3,\4,\5,\6,\7,\8,\9,\0}
% \DoNotIndex{\!,\#,\$,\&,\',\(,\),\+,\.,\:,\;,\<,\=,\>,\?,\_}
% \DoNotIndex{\discretionary,\immediate,\makeatletter,\makeatother}
% \DoNotIndex{\meaning,\newenvironment,\par,\relax,\renewenvironment}
% \DoNotIndex{\repeat,\scriptsize,\selectfont,\the,\undefined}
% \DoNotIndex{\arabic,\do,\makeindex,\null,\number,\show,\write,\@ehc}
% \DoNotIndex{\@author,\@ehc,\@ifstar,\@sanitize,\@title,\everypar}
% \DoNotIndex{\if@minipage,\if@restonecol,\ifeof,\ifmmode}
% \DoNotIndex{\lccode,\newtoks,\onecolumn,\openin,\p@,\SelfDocumenting}
% \DoNotIndex{\settowidth,\@resetonecoltrue,\@resetonecolfalse,\bf}
% \DoNotIndex{\clearpage,\closein,\lowercase,\@inlabelfalse}
% \DoNotIndex{\selectfont,\mathcode,\newmathalphabet,\rmdefault}
% \DoNotIndex{\bfdefault}
% \setcounter{StandardModuleDepth}{1}
% \MakeShortVerb{\"}

% \title{\LexiBib\\a style file to link\\\BibTeX\ databases with
% the \\\LexiTeX\ style engine.\thanks{%
%    This file has version number \fileversion{} dated
%    \filedate{}.
%    The documentation was last revised on \docdate.
%    The documentation and the code for \LexiBib{} and \LexiTeX{} 
%    are \copyright{} 1992--94 Frank Bennett, Jr.  Distribution
%    and use are freely welcomed, on the sole condition that
%    acknowledgement of the \LexiTeX{} package and of its author
%    be made in any published using these utilities.
%       }}
% \author{Frank G. Bennett, Jr.}
% \maketitle
% 
% \begin{abstract}
% \LexiBib\ is a style for use with \BibTeX\ which permits
% legal and other citations to be stored in \BibTeX\ databases,
% and incorporated in documents in a manner similar to
% the normal operation of
% \BibTeX.  Citations exported using \LexiBib\ are written in
% the syntax required for digestion by \LexiTeX, a citation
% engine that produces in-footnote, cross-referenced citations
% from nickname references to a  single citation source list.
% \LexiTeX\ is currently a \LaTeX\ 2.09 style, which will be
% upgraded to \LaTeX2e form in due course.
% \end{abstract}
%
% \tableofcontents
% \lexiforcefoots
% \section*{Preface to Version 1.0b}
%
% This {\tt doc} package contains a \BibTeX\ style named
% {\tt lexibib.bst}.  This style file can be used to
% export citations from a \BibTeX{} database in a form
% that can be used by the \LexiTeX\ citation engine.
% This permits a user to store citation details and
% annotations in a separate database, and incorporate
% those citations into a document using simple nickname
% tags.  When the document is printed, the nickname tags
% will automagically be converted into properly formatted,
% Blue Book-conformant citations.\\
% The {\tt lexibib.bst} style file contains only a modest
% amount of code from the original 1988 release of {\tt
% btxbst.doc}
% by Oren Patashnik.  While the original style is very
% efficient in its operation, its output, formatting and
% logical function are intertwined in a way that makes
% modification of the style rather difficult.  At some cost
% in speed, in {\tt lexibib.bst} I have tried to provide
% a set of modular functions that can be more easily modified
% to suit specialized formatting requirements.\\
% Please note that this is a {\sf beta} release.  Full support
% for databases prepared according the general conventions laid
% down by Oren Patashnik is not yet provided,
% so please don't rely on this style in the way you would rely
% on the standard styles (yet).  Your comments will help to
% speed the development of \LexiBib\ into a reliable clone
% of the standard styles.
% 
% \newpage
% \pagenumbering{arabic}
% \section{User Guide}
% \subsection{Introduction}
%
% An adage in office management is that you should
% only touch incoming paper once; to respond to it, to file
% it, to forward it, or to destroy it.  A number of 
% commercial citation
% database managers provide a facility for ``filing'' citations
% in a flexible form, the idea being to extend this principle
% to citations as well as paper.  A hanging point for this
% strategy as been in-text context-sensitive citation styles.
% Database managers are at their best in exporting 
% entire bibliographies
% and lists of authorities.  Some packages are
% capable of scanning a document for citation ``tags'', 
% which eliminates the need to separately select bibliography
% items in the database.  Some, too, can replace ``tags''
% in the document with the formatted text of a citation.
% But once the text is replaced, the format of citations
% added in this way is fixed; conversion is a one-way process.
%
% A more serious problem is that, while the database manager
% can easily identify the {\em tag}, it cannot identify its 
% {\em context\/}---whether it occurs in a footnote, how many
% items were in the preceding footnote, how many articles
% by the same author are cited in the document, and so forth.
% As a result, citation formatting of cross-referenced styles
% is still done by hand.
%
% One of the most demanding cross-referenced styles is that
% laid down in {\sl A Uniform System of Citation}, or ``the Blue
% Book'', for the citation of legal materials.  This style
% has survived the era of computerization largely because
% most U.S. law journals using the style are edited by highly
% competitive law students.  Staff members contribute their
% editorial time to their journal free of charge, because of
% the value of listing law journal membership on their resume.
% The Blue Book style minimizes the bulk of citation
% text, while conveying sufficient information to the reader
% for the location of cited material.  It is also designed
% to provide all information required for the location of
% {\em primary\/} legal authority from the face of any citation
% to it, without tracing down cross-references.
%
% \LexiTeX{} and \LexiBib{} constitute the first attempt
% to allow documents requiring {\em cross-referenced},
% {\em in-text\/} citations in the demanding Blue Book style
% to draw all citation details
% from a separately maintained bibliography, with all
% citation formatting taking place automatically at print time.
% \LexiTeX{} is a style for use with the \LaTeX{} typesetting
% system.
% 
% The implications of such a system are particularly interesting
% if it comes to be widely used, say, in the publication of
% law journals.  The efficiency with which
% citations can be reported to citation services would be
% increased, since \LexiBib{}-format database entries
% are in a standard format that can
% be processed electronically.  These same lists could
% be made available as text-searchable databases of authority.
% Network discussions of legal issues could be accompanied by
% growing lists of annotated authority, available for all to
% use.
% 
% Even for personal use, the combination of \LexiTeX{} and
% \LexiBib{}

% Details on the use of \LexiTeX\ are contained in a separate
% manual.  The purpose of this guide is to explain the
% preparation
% and processing of \BibTeX\ databases for use with \LexiBib{}
% and
% \LexiTeX.  If you have any queries, please feel free to contact
% me on {\tt fbennett@clus1.ulcc.ac.uk}.  
%
% \subsection{Preparing bibliography files}
% 
% \subsection{Processing files using \LexiBib}
% \subsection{\LexiBib\ entry types}
% \subsection{\LexiBib\ entry fields}
%\StopEventually{}
% \section{The style code}
% \subsection{To prospective style hackers}
% The \BibTeX\ style language differs from \TeX\ both in style
% and in syntax.  Whereas \TeX\ tears through a document from
% start to finish, clearing memory as it feeds out pages and
% terminating at the end of the input file, \BibTeX\ reads its
% own {\tt *.bst} file in a linear fashion, but the
% commands used in that file to not treat treat the {\em
% database\/} input file as a linear input stream.\\
% At startup, \BibTeX\ latches onto the
% {\tt *.aux} file at which it has been pointed, and scans it for
% certain strings, which are hardwired into \BibTeX's own code.
% These strings tell the program (a) which citation databases it
% must open, and (b) what citation nicknames it must search those
% databases for.  A series of initializing operations are then
% performed, which define variables and functions much as one
% defines \TeX\ macros in advance of their use.  Finally, 
% the matching items from the database can be read for use by
% \BibTeX, and the defined functions can be invoked on each item.
% The entire list may be read several times if necessary.  In the
% end, special functions which write formatted entries on an
% output file are invoked after which, having reached the end of
% the {\tt *.bst} file, the program terminates.
% 
% The {\tt *.bst} style code below has been divided into logical
% sections which, I hope, will illustrate the logical phases of
% \BibTeX's progress.
%
% \subsection{About cross-referencing}
% About cross-referencing, Oren Patashnik wrote:
% \begin{quote}
% Now come the cross-referencing functions (these are invoked
% because one entry in the database file(s) cross-references
% another, by giving the other entry's database key in a 
% "crossref"
% field).  This feature allows one or more titled things that are
% part of a larger titled thing to cross-reference the larger
% thing.  These styles allow for five posibilities:
% 
% \begin{enumerate}
% \item an {\bf article} may cross-reference an {\bf article};
% 
% \item a cross-reference to a {\bf book} may be made in an
% entry for:
% 
% \begin{enumerate} 
% \item a {\bf book};
% \item an {\bf inbook}; or
% \item an {\bf incollection}; and
% \end{enumerate}
%
% \item
% an {\bf inproceedings} may cross-reference a {\bf proceedings}.
% \end{enumerate}
%  Each of
% these is explained in more detail later.
% 
%  An {\bf article} entry type may cross reference another
% {\bf article}
% (this
% is intended for when an entire journal is devoted to a single
% topic--- but since there is no {\bf journal} entry type, the
% journal,
% too, should be classified as an {\bf article} but without the
% author
% and title fields). This will result in two warning messages for
% the journal's entry if it's included in the reference list, but
% such is life. The other cross-referencing functions are
% similar,
% so no "comment version" will be given for them. We use just the
% last names of editors for a cross reference: either "editor",
% or
% "editor1 and editor2", or "editor1 et~al." depending on whether
% there are one, or two, or more than two editors.
% \end{quote}
% \def\option#1{\item\def\lawtemp{#1}\def\lawtemptwo{none}
% \ifx\lawtemp\lawtemptwo
% {\em none}
% \else{\small`{\bf#1}':}\fi}
% \newenvironment{Ventry}[1]%
%  {\begin{list}{}{\renewcommand{\makelabel}[1]{\textsf{##1:}\hfil}%
%  \settowidth{\labelwidth}{\textsf{#1:}}%
%  \setlength{\leftmargin}{\labelwidth}
%  \addtolength{\leftmargin}{1\labelsep}}}%
% {\end{list}}
% \changes{1.0f}{1994/12/08}{Rewrote the `spec' macro used in the
% documentation, which was not happy with either compatibility
% mode or 2e.}
% \changes{1.0f}{1994/12/08}{\LaTeX 2e version released!}
% \def\spec#1#2#3{\begin{Ventry}{Expected}
%   \item[Expected] \begin{enumerate}
%     #1
%                   \end{enumerate}
%   \item[Left] \begin{enumerate}
%     #2
%               \end{enumerate}
%   \item[Toggles] \begin{enumerate}
%     #3
%                   \end{enumerate}
% \end{Ventry}}
% Each function defined using the {\tt FUNCTION} operator
% is accompanied by a brief description of what it is
% intended to do, followed by a box in the following form:
%
% \spec{\item What the function expects to find on the stack,
% numbered from the top (most recently pushed) to the bottom
% item.}
% {\item What the function will leave on the stack, numbered in
% the
% same fashion.}
% {\option{toggle name} What the effect of any toggles is on the
% behaviour of the function.}
%
% Happy reading.
% \subsection{Hello!}
% As ever, we start by telling the world who we are.
%    \begin{macrocode}
%<*newbst>
FUNCTION { hello }
{ "     ========================================="
"     package, version 2.0g or later"
"     Use with LateX2e and the LexiTeX style"
"     -----------------------------------------"
"     documentation last updated: 5 December 1994"
"     code last updated: 12 December 1994"
"     style version: 1.0g"
"     This is the LexiBib style for BibTeX"
"     ========================================="
stack$
}
%    \end{macrocode}
% \subsection{Variable initializations}
% \DescribeEnv{ENTRY}
% This command takes three braced arguments, which in order are:
% \begin{enumerate}
% \item A list of field names;
% \item A list of integer variables; and
% \item A list of string variables.
% \end{enumerate}
% The field names created here include some not found in the
% standard \BibTeX\ styles.  The use of both the standard and
% these new
% items is fully documented elsewhere, so no commentary is
% given here.  Suffice to say that each item in the list creates
% a field that
% subsequent code can work on.
%    \begin{macrocode}
ENTRY
%    \end{macrocode}
%
% \DescribeEnv{field names}
% \mbox{}
%    \begin{macrocode}
{ address
annote
author
booktitle
chapter
edition
editor
howpublished
institution
journal
key
month
note
number
organization
pages
publisher
school
series
title
type
volume
year 
date
jurisdiction
court
division
divno
casedate
translator
booktranslator
}
%    \end{macrocode}
%
% \DescribeEnv{entry integers}
% None are defined.  Note that any integers or strings defined
% with the
% ENTRY command are created for {\em each\/} entry in the
% citation list.
%    \begin{macrocode}
{}
%    \end{macrocode}
%
% \DescribeEnv{entry strings}
% There are no general string variables, either.  Such variables
% might be defined for use in building key labels for use in
% sorting, or in an end-of-document bibliography style.
%    \begin{macrocode}
{}
%    \end{macrocode}
%
% \DescribeEnv{STRINGS}
% A few string macros are needed to hold things
% temporarily removed from the stack.
% \BibTeX\ only allows ten such string variables; the named
% variables in this list will slowly be reduced in number
% through redesign of the functions that require them.
% Meanwhile, let's hope we don't find a sudden need for
% more \ldots
%    \begin{macrocode}
STRINGS { s t u theyear themonth theday }
%    \end{macrocode}
%
% \DescribeEnv{INTEGERS}
% The following list of integers is probably also larger than
% it needs to be.  Again, optimization of stack usage will
% lead to the elimination of some of these variables.
%    \begin{macrocode}
INTEGERS { itemcount date.specials charcount a b
           nameptr namesleft numnames a.logical }
%    \end{macrocode}
%
% \DescribeEnv{FUNCTIONS}
% These functions provide strings used in the parsing of
% Japanese legal citations.  If the language of such citations
% is not English, these strings may need to be edited.
%    \begin{macrocode}
FUNCTION {dc..} {"District Court"}
FUNCTION {sc..} {"Supreme Court"}
%    \end{macrocode}
%
% \subsection{Function definitions}
% \subsubsection{Logic and measurement}
% 
% \DescribeEnv{not}
% \DescribeEnv{and}
% \DescribeEnv{or}
% These have been copied verbatim from Oren Patashnik's 1988
% release.
% His commentary on these functions reads: 
% {\em These three functions pop one or two (integer) arguments
% from the stack
% and push a single one, either "0" or "1".
% The {\tt 'skip\$} in the `"and"' and `"or"' functions are used
% because
% the corresponding {\tt if\$} would be idempotent.}
%
% \spec{\item The result of a logical test
% \item The result of a second logical test}
% {\item A single logical test result}
% {\option{none}}
%
%    \begin{macrocode}
 FUNCTION {not}
 {   { #0 }
     { #1 }
   if$
 }
 FUNCTION {and}
 {   'skip$
     { pop$ #0 }
   if$
 }
 FUNCTION {or}
 {   { pop$ #1 }
     'skip$
   if$
 }
%    \end{macrocode}
%
% \DescribeEnv{times.ten}
% One of the date calculation routines requires
% string-to-integer conversion.  \BibTeX\ primitives can only
% convert in this direction for single characters.  Accordingly,
% we need to be able to raise by a power of ten.
%
% \spec{\item A single integer.}
% {\item A single integer.}
% {\option{none}}
%
%    \begin{macrocode}
FUNCTION {times.ten}
 { duplicate$ duplicate$ duplicate$ duplicate$ duplicate$
   duplicate$ duplicate$ duplicate$ duplicate$
   + + + + + + + + +
 }
%    \end{macrocode}
%
% \DescribeEnv{character.length}
% \BibTeX\ provides a built-in command for measuring the length
% of a string in ``text units''.  Sometimes it's nice to know
% the length of a string in {\em characters\/};
% this function provides
% that facility.
%
% \spec{\item A string.}
% {\item An integer giving the number of characters in the
% string.}
% {\option{none}}
%
%    \begin{macrocode}
FUNCTION {character.length} 
    { 'u := 
      #0 'charcount := 
      { u empty$ not } 
        { u #2 global.max$ substring$ 'u := 
          charcount #1 + 'charcount := 
        }while$ 
      charcount 
    } 
%    \end{macrocode}
%
% \DescribeEnv{first.in.second}
% This function checks for a substring at the beginning or at the
% end of a given string.  This facility is needed, for example,
% to provide an automated means of toggling the formatting of
% the court division string for Japanese cases.
% In the defintion below, {\tt t} is the substring length, and
% {\tt u} is the string length.
%
% \spec{\item A string toggle.
% \item A string (the string in which to look).
% \item A string (the substring to look for).}
% {\item A single integer ({\tt 0} or {\tt 1}), indicating
% whether
% the substring was found at the specified location in the
% string for search.}
% {\option{end} The function looks at the end of the
% given string.
% \option{start} The function looks at the start of the
% given string.}
%
%    \begin{macrocode}
FUNCTION {first.in.second}
    { 's :=
      duplicate$ empty$
      { pop$ pop$ #0 }
      { swap$ duplicate$ character.length 'a :=
        swap$ duplicate$ character.length 'b :=
        b a <
        { pop$ pop$ #0 }
        { s "end" =
          { b a - #1 + global.max$ substring$ =
            { #1 }
            { #0
            }if$
          }
          { #1 a substring$ =
            { #1 }
            { #0
            }if$
          }if$
        }if$
      }if$
    }
%    \end{macrocode}
%
% \DescribeEnv{get.character.type}
% This function returns one of three strings, `"letter"',
% `"numeral"' or `"other"` to indicate the type of the
% character it finds on the stack.  This was written for
% use in the "gather.chars" function, but may find other
% uses as well.
%    \begin{macrocode}
FUNCTION { get.character.type }  
  { duplicate$ empty$
    { pop$ "other" }
    { duplicate$ chr.to.int$  
      duplicate$ #47 > swap$ #58 < and  
      { pop$ "numeral" }  
      { chr.to.int$  
        duplicate$ #64 > swap$ duplicate$ #91 < swap$ 
        duplicate$ #96 > swap$ #123 < and 'a.logical :=
        and a.logical or  
        { "letter" }  
        { "other"  
        }if$  
      }if$  
    }if$
  }  
%    \end{macrocode}
%
% \subsubsection{Housekeeping}
% These functions are used to issue warning messages and avoid
% errors during processing.
%
% \DescribeEnv{empty.to.null}
% This is simply the "field.or.null" function from the standard
% styles, renamed so that I could more easily remember what it
% does.  Invoked only by the output routines, it assures that
% empty field markers are replaced with the null string, to
% prevent smash-ups.
%
% \spec{\item The contents of a field, which may be an empty
% field marker.}
% {\item A string, possibly the null string.}
% {\option{none}}
%
%    \begin{macrocode}
 FUNCTION {empty.to.null}
 { duplicate$ empty$
     { pop$ "" }
     'skip$
   if$
 }
%    \end{macrocode}
%
% \DescribeEnv{check}
% This check function isolates the production of warning
% messages from the output routines, to enhance transparency.
% Note that this will not convert an empty field marker to
% the null string; that is left to the output routines.
%
% \spec{\item A string for
% use in an error message.
% \item The contents of a field.}
% {\item The field contents.}
% {\option{none}}
%
%    \begin{macrocode}
FUNCTION { check }
{ 't :=
  duplicate$ empty$
  { "empty " t * " in " * cite$ * warning$}
  'skip$
  if$
}
%    \end{macrocode}
%
% \DescribeEnv{either.or}
% \changes{1.0c}{94/08/10}{Added the {\tt either.or}
% housekeeping function, for use in {\tt j.cases}.}
% This checks whether one of a two-item pair is empty.
% If at least one is empty, the other is returned to the
% stack.  If both are non-empty, a warning is issued, and
% one item is arbitrarily selected.
%
% \spec{\item A string.
% \item A string.}
% {\item A single string.}
% {\option{none}}
%
%    \begin{macrocode}
FUNCTION {either.or}
 { duplicate$ empty$
   { pop$ duplicate$ empty$
     { pop$ "" }
     'skip$
     if$
   }
   { swap$ duplicate$ empty$
     { pop$ }
     { "both items in an either.or pair are non-empty in " cite$ *
       warning$
       "  I'm using only ONE of these items (the second passed by the function)."
       warning$
       pop$
     }if$
   }if$
 }
%    \end{macrocode}
%
% \subsubsection{Output}
% In the interest of transparency, I have tried to make the
% output functions as simple to use and as flexible in their
% operation as possible.  Every output routine expects to find
% three items on the stack, and the name of each routine
% describes how it will react to what it finds there.  
% To keep things tidy, the empty field marker
% is replaced with the null string only by the output
% routines.\\
% The names
% are sometimes coincidentally comical, but I hope informative
% as well.
%
% \DescribeEnv{must.must.must}
% The simplest
% output routine is the "must.must.must" routine; it
% simply catenates the three strings, replacing any
% empty field markers it finds with the null string.
%
% \spec{\item A string.
% \item A string.
% \item A string.}
% {\item none}
% {\option{none}}
%
%    \begin{macrocode}
FUNCTION {must.must.must}
    { empty.to.null 't :=
      empty.to.null swap$ empty.to.null swap$ t
      * * 
      write$
    }
%    \end{macrocode}
%
% \DescribeEnv{might.ifone.must}
% This output routine is heavily used for conditional
% output. If the deepmost of the three stack items is an empty
% field marker, the only the topmost item is written to the
% output file.  If this is not the case, then the three items are
% written in order.
%
% \spec{\item A string.
% \item A string.
% \item A string.}
% {\item {\em none}}
% {\option{none}}
%
%    \begin{macrocode}
FUNCTION {might.ifone.must}
    { empty.to.null 't :=
      swap$ duplicate$ empty$
      { pop$ pop$ t }
      { swap$ empty.to.null t * * }
      if$
      write$
    }
%    \end{macrocode}
%
% \DescribeEnv{iftwo.might.iftwo}
% This function is typically used to output a formatted item
% in enclosing braces, where the entire item and its braces
% should be suppressed if the item is empty.
%
% \spec{\item A string.
% \item A string.
% \item A string.}
% {\item none}
% {\option{none}}
%
%    \begin{macrocode}
FUNCTION {iftwo.might.iftwo}
    { 't :=
      duplicate$ empty$
       { pop$ pop$ }
       { empty.to.null swap$ empty.to.null swap$
         t empty.to.null
         * * write$ }
      if$
    }
%    \end{macrocode}
% \DescribeEnv{ifthree.ifthree.might}
% This outputs a pair of prefixes if the suffix to which they are
% to be attached exists.  Otherwise it outputs a null string.
%
% \spec{\item A string.
% \item A string.
% \item A string.}
% {\item none}
% {\option{none}}
%
%    \begin{macrocode}
FUNCTION {must.ifthree.might}
    { 't :=
      duplicate$ empty$
      { pop$ write$ }
      { swap$ empty.to.null
        swap$ empty.to.null
        t * * write$ }
      if$
    }
%    \end{macrocode}
%
% \subsubsection{Parsing and conversion}
%
% \DescribeEnv{field.tag.no.combine}
% The "no" here stands for ``number''.
% This function is typically used to simplify the task of
% building a numbered label for something (e.g.\ a technical
% report).  It provides facilities for handling blank
% entries, so that these error-handling routines do not
% need to be drafted from scratch for every such
% situation.
% 
% \spec{\item A string toggle.
% \item An identifier (i.e.\ a report number).
% \item A text prefix for the identifier.
% \item A string label (i.e.\ ``Technical Report'' or somesuch).}
% {\item A single string.}
% {\option{endlabel} Combines the text items in the same order
% in
% which they are found.
% \option{frontlabel} Places the label in front, followed by the
% identifier, followed by the first item pushed.}
%
%    \begin{macrocode}
FUNCTION {field.tag.no.combine}
  { "endlabel" =
    { duplicate$ empty$
      { pop$ pop$ empty.to.null }
      { empty.to.null 's := empty.to.null
      swap$ empty.to.null swap$ s * *
      }if$
    }
    { duplicate$ empty$
      { pop$ pop$ empty.to.null }
      { empty.to.null 's := empty.to.null
        swap$ empty.to.null s swap$ * * 
      }if$
    }if$
  }
%    \end{macrocode}
%
% \DescribeEnv{change.letter.case}
% This is a simple front-end to the {\tt change.case\$} built-in
% function, used to change characters in a string from upper to
% lower case.  It slightly enhances the built-in function by
% providing an option that leaves the string alone.
%
% \spec{\item A single character---either 
% an {\tt n}, a {\tt t}, an {\tt l}, or a {\tt u}.
% \item A string for conversion.}
%  {\item One string, converted according to the option toggle
% pushed
% after the string.}
% {\option{n} yields the string unchanged.
% \option{t} yields
% all lower case letters except for the first.
% \option{l} yields all lower case letters.
% \option{u} yields all
% upper case letters.}
%
%    \begin{macrocode}
FUNCTION {change.letter.case}
    { 't :=
      duplicate$ empty$
        'skip$
        { t chr.to.int$ "n" chr.to.int$ =
          'skip$
          { t change.case$ }
          if$
        }
      if$
    }
%    \end{macrocode}
%
% \DescribeEnv{n.dashify}
% The "n.dashify" function makes each single "-" in a string a
% double "--".
% if it's not already.\footnote{This comment by Oren Patashnik.}
%
% \spec{\item A single string for conversion.}
% {\item A single converted string.}
% {\option{none}}
%
%    \begin{macrocode}
 FUNCTION {n.dashify}
 { 't :=
   ""
     { t empty$ not }
     { t #1 #1 substring$ "-" =
      { t #1 #2 substring$ "--" = not
          { "--" *
            t #2 global.max$ substring$ 't :=
          }
          {   { t #1 #1 substring$ "-" = }
           { "-" *
             t #2 global.max$ substring$ 't :=
           }
            while$
          }
        if$
      }
      { t #1 #1 substring$ *
        t #2 global.max$ substring$ 't :=
      }
       if$
     }
   while$
 }
%    \end{macrocode}
%
% \DescribeEnv{gather.chars}
% The following function was designed for date parsing, but
% may find other uses as well.  It finds the first letter or
% numeral in a given string, then proceeds to build a substring
% until it hits a different character type or the end of the
% string,
%  at which point it
% stops parsing and terminates.
%
% \spec{\item A string for parsing.}
% {\item A string toggle showing the character type of the
% first homogenous substring in the string for parsing.
% \item A string of characters from the front of the given string
% which are letters or numbers only.
% \item The remainder of the string.}
% {\option{none}}
%
%    \begin{macrocode}
FUNCTION { gather.chars }  
  { 't :=
    { t empty$ not
      t #1 #1 substring$ get.character.type
      "other" = and }
    { t #2 global.max$ substring$ 't :=
    }while$
    t #1 #1 substring$ duplicate$ get.character.type
    "" swap$ duplicate$ 'u :=
    t #2 global.max$ substring$ 't :=
    { u = }
    { * t #1 #1 substring$ duplicate$ get.character.type
      duplicate$ u =
      { t #2 global.max$ substring$ 't :=  }  
      { swap$ pop$
      }if$  
    }while$
    t swap$ u
  }  
%    \end{macrocode}
%
% \DescribeEnv{tie.or.space.connect}
% We use this function from the standard styles.  It 
% adds a tie if the string it is applied to is three
% characters or less in length.
%
% \spec{\item A string
% \item A second string}
% {\item One string}
% {\item {none}}
%
%    \begin{macrocode}
 FUNCTION {tie.or.space.connect}
 { duplicate$ text.length$ #3 <
     { "~" }
     { " " }
   if$
   swap$ * *
 }
%    \end{macrocode}
%
% \DescribeEnv{format.pages}
% This function accepts one toggle option currently,
% but it is open to expansion.  If the "short" toggle is
% fed to this function, it reads through the field until
% it hits a non-integer character.  Otherwise, it "n.dashify"s
% the
% whole field.  This needs robustification; the page number
% might be a roman numeral.  Might it be simplest to just 
% drop the scan when we hit a "-"?  Deserves some thought.
%
% \spec{\item A toggle string.
% \item page number or possibly
% a range of pages.}
% {\item One string, constituting a finished page number, or {\tt
% empty\$}.}
% {\option{short} will return only the
% first number given in the string.
% \option{full}
% will return the page number, n-dashified.}
% \changes{1.0e}{94/12/05}{Altered {\tt format.pages} so
% that the {\tt short} scan stops at a {\tt-} character,
% rather than a non-integer.  Simpler and more robust.}
%    \begin{macrocode}
FUNCTION {format.pages}
    { swap$ duplicate$ empty$
      { pop$ pop$ "" }
      { swap$ duplicate$ "short" =
        { pop$
          's :=
          ""
          s #1 #1 substring$
          { "-" = not }
            { s #1 #1 substring$ *
              s #2 global.max$ substring$ 's :=
              s #1 #1 substring$
              duplicate$ "" =
                { pop$ "-" }
                'skip$
                if$
            }
          while$
        }
      { "full" =
        { pages n.dashify }
        { "invalid switch fed to the format.pages function"
           warning$
        }if$
      }if$
    }if$
}
%    \end{macrocode}
%
% \paragraph{Names}
% The code for parsing and formatting names is extremely
% economical,
% thanks to the powerful built-in functions that \BibTeX\
% supplies
% for this purpose.
%
% \DescribeEnv{format.names}
% This is based on Oren Patashnik's original function of the same
% name.  His comment was as follows:
% \begin{quote}
% The format.names function formats the argument (which should
% be in
% \BibTeX name format) into ``{\tt First Von Last, Junior}'',
% separated by commas
% and with an "and" before the last (but ending with "et~al." if
% the last
% of multiple authors is "others").  This function's argument
% should always
% contain at least one name.
% The format.authors function returns the result of
% format.names(author)
% if the author is present, or else it returns the null string.
% \end{quote}
%
% This function is used to format any name field that is
% thrown at it.  It is based on the 1988 release, but with
% modifications
% to permit toggling, since the Blue Book requires different
% author
% formats for different types of material.  The toggling strategy
% should also make modification of this style a pretty simple
% matter.
%
% \spec{\item The contents of one name field
% \item  string toggle
% (either {\tt firstinitial}, {\tt lastonly} or {\tt full})}
% {\item A single string, containing a formatted name or names,
% or {\tt empty\$}}
% {\option{firstinitial} Yields the form ``F.~Bennett, Jr.''
% \option{lastonly}
% Yields the form ``Bennett''
% \option{full} yields ``Frank Bennett, Jr.''}
%
%    \begin{macrocode}
FUNCTION {format.names}
    { 'u :=
      duplicate$ empty$
        'skip$
        { 's :=
          #1 'nameptr :=
          s num.names$ 'numnames :=
          numnames 'namesleft :=
          { namesleft #0 > }
            { u "lastonly" =
              { s nameptr "{vv~}{ll}" format.name$ 't := }
              { u "firstinitial"  =
                { s nameptr "{f.~}{vv~}{ll}{, jj}" format.name$
't := }
                { u "full" =
                  { s nameptr "{ff~}{vv~}{ll}{, jj}" format.name$ 't :=}
                  { "style error; invalid or non-existent toggle" warning$ }
                  if$
                }
                if$
              }
              if$
              nameptr #1 >
                { namesleft #1 >
                  { ", " * t * }
                  { numnames #2 >
                    { "," * }
                    'skip$
                    if$
                    t "others" =
                      { " et~al." * }
                      { " and " * t * }
                    if$
                  }
                if$
                }
                't
              if$
              nameptr #1 + 'nameptr :=
              namesleft #1 - 'namesleft :=
            }
          while$
        }
      if$
    }
%    \end{macrocode}
%
% \paragraph{Dates}
% The style code for parsing and formatting dates is much more
% complex than that for names.  This is due to the need to
% build the necessary tools out of \BibTeX\ primitives, since
% no built-in tools for this task are supplied.  There are
% two date formatting routines below.  The simpler of the two
% is "format.month.year".  This is basically just the function
% supplied with the standard \BibTeX\ styles, under a new name.
% The \LexiBib\ version of "format.date" is underpinned by
% a whole set of new
% functions, and allows great flexibility in the syntax
% for entering dates.
%
% \subparagraph{Old format routine}
%
% \DescribeEnv{format.month.year}
% The "format.date" function is for the month and year, but we
% give a warning if
% there's an empty year but the month is there, and we return the
% empty string
% if they're both empty.\footnote{This comment by Oren
% Patashnik.}
%
% This is not changed over the "format.date" function in the 
% original standard \BibTeX{} styles.  It is retained, although
% the distributed \LexiBib\ styles won't be making use of it.
%
% \spec{\item none}
% {\item A single string.}
% {\option{none}}
%
%    \begin{macrocode}
 FUNCTION {format.month.year}
 { year empty$
     { month empty$
      { "" }
      { "there's a month but no year in " cite$ * warning$
        month
      }
       if$
     }
     { month empty$
      'year
      { month " " * year * }
       if$
     }
   if$
 }
%    \end{macrocode}
%
% \subparagraph{New date parsing routines}
% The "format.date" function depends upon a number of
% supporting functions.  Some of these are of general utility,
% and are presented above.  Those presented here are specific
% to this particular function.
%
% \DescribeEnv{fillout.a.year}
% This adds a leading "19" to a year entered in two-digit
% form.
%
% \spec{\item A single string.}
% {\item A single string.}
% {\option{none}}
%
%    \begin{macrocode}
FUNCTION {fillout.a.year}
 { duplicate$ character.length #2 =
   { pop$ "19" swap$ * }
   'skip$
   if$
 }
%    \end{macrocode}
%
% \DescribeEnv{parse.month}
% This function is a simple parser, used in converting
% database entries that have been identified as probable
% abbreviated month entries into numerical string form.
%
% \spec{\item A single string, which should consist of
% exactly three alphabetic characters.}
% {\item A single string of numbers.}
% {\option{none}}
%
%    \begin{macrocode}
FUNCTION {parse.month}
 { duplicate$ "jan" =
   { pop$ "1" }
   { duplicate$ "feb" =
     { pop$ "2" }
     { duplicate$ "mar" =
       { pop$ "3" }
       { duplicate$ "apr" =
         { pop$ "4" }
         { duplicate$ "may" =
           { pop$ "5" }
           { duplicate$ "jun" =
             { pop$ "6" }
             { duplicate$ "jul" =
               { pop$ "7" }
               { duplicate$ "aug" =
                 { pop$ "8" }
                 { duplicate$ "sep" =
                   { pop$ "9" }
                   { duplicate$ "oct" =
                     { pop$ "10" }
                     { duplicate$ "nov" =
                       { pop$ "11" }
                       { duplicate$ "dec" =
                         { pop$ "12" }
                         { "invalid month in " cite$ * warning$
                         }if$
                       }if$
                     }if$
                   }if$
                 }if$
               }if$
             }if$
           }if$
         }if$
       }if$
     }if$
   }if$
 }
%    \end{macrocode}
%
%
% \DescribeEnv{extract.date}
% This function takes a labelled stack of numeric items,
% and places its contents into the appropriate variables
% representing elements of a date.  It will probably
% tolerate further enhancement, and should probably 
% deliver its result to the stack, rather than into
% variables.
%
% The behaviour of this function is a little too complex
% to describe its input and output behaviour using our
% usual description box, so we revert to prose here.
% The stack is always left empty, and there are no
% toggles that affect the overall behaviour of the
% function.  The expectation of what will appear on the
% stack depends on the contents of the integer
% variable "itemcount".  For each date item counted, the
% function expects to find two items on the stack: a
% string possibly flagging the variable into which the
% item should be placed; and a numerical string.
%
% If "itemcount" is "0", a warning of an empty date
% is issued.
%
% If "itemcount" is "1", the flag string is ignored,
% and the numerical item is assumed to be a year.
%
% If "itemcount" is "2", the flag strings are both
% ignored, and the numerical items are assumed to be
% a year and a month, in that order.
% 
% If "itemcount" is "3", the first item is assumed to
% be a year.  The assignment of the second two items
% depends first upon the contents of the integer
% variable "date.specials".  If this is "0", then
% the flags are ignored, and the numerical items are
% assumed to be a day and a month, in that order.
% If "date.specials" is "1" (`true'), then the
% flag of the first item is checked to see whether it
% is ``"month"''.  If so, the first item is assigned to
% the "themonth" variable, and the next to the "theday"
% variable.  Otherwise the assignments are reversed.
%
%    \begin{macrocode}
FUNCTION {extract.date}
  { "" 'theyear := "" 'themonth := "" 'theday :=
    itemcount #0 =
    { "some date or other is COMPLETELY empty in " cite$ * warning$ }
    { itemcount #1 =
      { pop$ fillout.a.year 'theyear := "" 'theday := "" 'themonth := }
      { itemcount #2 =
        { pop$ fillout.a.year 'theyear :=
          pop$ 'themonth :=
          "" 'theday :=
        }
        { itemcount #3 =
          { date.specials
            { pop$ fillout.a.year 'theyear := 
              "month" =
              { 'themonth :=
                pop$ 'theday := }
              { 'theday :=
                pop$ 'themonth :=
              }if$
            }
            { pop$ fillout.a.year 'theyear :=
              pop$ 'theday :=
              pop$ 'themonth :=
            }if$
          }
          { "too many items for date in " cite$ * warning$
          }if$
        }if$
      }if$
    }if$
 }
%    \end{macrocode}
%
% \DescribeEnv{format.month.name}
% \changes{\LexiBib{} 1.0b}{94/08/09}{Added {\tt swap\$} as appropriate
% to expose string on stack for {\tt empty\$} check.}
% This takes a numerical string and converts it to either an
% abbrviated or a spelled-out month name.
%
% \spec{\item A toggle string.
% \item A numerical string.}
% {\item A string.}
% {\option{long} The month name placed on the stack will be
% spelled out.
% \option{short} The month name will be abbreviated.}
%
%    \begin{macrocode}
FUNCTION { format.month.name }
 { swap$ duplicate$ empty$
   { pop$ pop$ "" }
   { swap$ "long" = 
     { duplicate$ "1" =
       { "January" }
       { duplicate$  "2" =
         { "February" } 
         { duplicate$  "3" =
           { "March" } 
           { duplicate$ "4" =
             { "April" } 
             { duplicate$  "5" =
               { "May" } 
               { duplicate$ "6" =
                 { "June" } 
                 { duplicate$  "7" =
                   { "July" } 
                   { duplicate$  "8" =
                     { "August" } 
                     { duplicate$  "9" =
                       { "September" } 
                       { duplicate$  "10" =
                         { "October" } 
                         { duplicate$  "11" =
                           { "November" } 
                           { duplicate$  "12" =
                             { "December" }
                             { "invalid month in " cite$ * warning$ "" 
                             }if$
                           }if$
                         }if$
                       }if$
                     }if$
                   }if$
                 }if$
               }if$
             }if$
           }if$
         }if$
       }if$
     }
     { duplicate$ "1" =
       { "Jan." }
       { duplicate$  "2" =
         { "Feb." } 
         { duplicate$  "3" =
           { "Mar." } 
           { duplicate$ "4" =
             { "Apr." } 
             { duplicate$  "5" =
               { "May" } 
               { duplicate$ "6" =
                 { "Jun." } 
                 { duplicate$  "7" =
                   { "Jul." } 
                   { duplicate$  "8" =
                     { "Aug." } 
                     { duplicate$  "9" =
                       { "Sept." } 
                       { duplicate$  "10" =
                         { "Oct." } 
                         { duplicate$  "11" =
                           { "Nov." } 
                           { duplicate$  "12" =
                             { "Dec." }
                             { ""
                             }if$
                           }if$
                         }if$
                       }if$
                     }if$
                   }if$
                 }if$
               }if$
             }if$
           }if$
         }if$
       }if$
     }if$
swap$ pop$
   }if$
 }
%    \end{macrocode}
%
% \DescribeEnv{topup.date}
% This is used to perform an addition operation on a
% string of numerals.
%
% \spec{\item An integer to be added.
% \item A string consisting of numerals only.}
% {\item A string consisting of the sum of the integer and
% the numeric string.}
% {\option{none}}
%
%    \begin{macrocode}
FUNCTION {topup.date}
 { 'a :=
   duplicate$ character.length #2 =
   { duplicate$ #1 #1 substring$ chr.to.int$ #48 -
     times.ten swap$ #2 #1 substring$ chr.to.int$ #48 -
     +
   }
   { duplicate$ character.length #1 =
     { chr.to.int$ #48 - }
     { pop$ #0 "I can't cope with more than two Japanese year digits in "
       cite$ * warning$
     }if$
   }if$
 a + int.to.str$
 }
%    \end{macrocode}
%
% \DescribeEnv{format.jdate}
% This rather specialized function converts a Japanese
% Imperial date written
% in a fixed syntax into the \LexiBib\ internal date stack,
% for onward handling by "extract.date".
%
% \spec{\item A string in the form: {\tt s57.9.27}, where
% the first letter indicates the Imperial reign of the year
% given, the first numeric item is the year, the second the
% month, and the third the day.  Any non-alphabetic, non-numeric
% character may be used as a separator.}
% {\item {\tt itemcount} is set to {\tt 2} (one more is added
% by the {\tt format.date} function in which is function is
% nested).
% \item Six stack items are output---see {\tt extract.date}
% for details on stack syntax.}
% {\option{none}}
%
%    \begin{macrocode}
FUNCTION {format.jdate}
 { duplicate$ #2 global.max$ substring$ gather.chars
   pop$ 't := swap$
   #1 #1 substring$ duplicate$ "s" =
   { pop$ t #1925 topup.date }
   { duplicate$ "m" =
     { pop$ t #1867 topup.date }
     { duplicate$ "t" =
       { pop$ t #1911 topup.date }
       { duplicate$ "h" =
         { t #1988 topup.date }
         { "invalid Imperial calendar code in " cite$ * warning$
         }if$
       }if$
     }if$
   }if$
   swap$
   gather.chars
   pop$ swap$
   gather.chars
   pop$ swap$ pop$ 't := swap$ "default" swap$ t swap$ "default"
   swap$ "default"
   #2 'itemcount :=
 }
%    \end{macrocode}
%
% \DescribeEnv{format.date}
% This function makes use of "gather.chars" and other supporting
% functions to build a stack of date items, which it then parses
% using "extract.date".  The syntax for entering dates is
% described in the user guide.
%
% \spec{\item A single string in appropriate date syntax.}
% {\item none}
% {\option{none}}
%
%    \begin{macrocode}
FUNCTION {format.date}
  { empty.to.null 's :=
    #0 'charcount :=
    #0 'itemcount :=
    #0 'date.specials :=
    { s empty$ not }
      { s gather.chars
        duplicate$ "letter" =
        { pop$ duplicate$ character.length #1 = itemcount not and
          { pop$ pop$ s format.jdate "" 's := }
          { duplicate$ character.length #3 =
            { swap$ 's :=
              parse.month "month" #1 'date.specials := }
            { swap$ 's :=
              pop$ "1" "invalid date in " cite$ * warning$
              "default"
            }if$
          }if$
        }
        { "numeral" =
          { duplicate$ character.length #1 =
            { swap$ 's := "default" }
            { duplicate$ character.length #2 =
              { swap$ 's := "default" }
              { duplicate$ character.length #4 =
                { swap$ 's := "default" }
                { swap$ 's := pop$ "1"
                  "invalid numerical element in date for " cite$ * warning$
                  "default"
                }if$
              }if$
            }if$
          }
          { swap$ 's := pop$ "1"
            "failed to parse date in " cite$ * warning$
            "default"
          }if$
        }if$
        itemcount #1 + 'itemcount :=
      }while$
    extract.date
  }
%    \end{macrocode}
%
% \subsubsection{Entry type specific functions}
% The functions below should not be used as general utilities;
% they are designed specifically for use with a particular entry
% type.  While they could be placed directly into the entry
% functions to which they apply, defining them separately
% helps improve the transparency of the code.
%
% \DescribeEnv{j.format.division}
% This function assembles the various fields relevant to the
% division of a Japanese court into a single string.
%
% \spec{\item none}
% {\item A single string}
% {\option{none}}
%
%    \begin{macrocode}
FUNCTION {j.format.division}
 { division empty$
   { "" }
   { dc.. court "end" first.in.second
     { " no.~" 's := "endlabel" 't := }
     { sc.. court "start" first.in.second
       { "No.\ " 's := "frontlabel" 't := }
       {  " " 's :=  "endlabel" 't :=
       }if$
     }if$
   }if$
   division s divno t field.tag.no.combine
 }
%    \end{macrocode}
%
% \DescribeEnv{format.thesis.type}
% The function "format.thesis.type" returns either the
% (case-changed) type field,
% if it is defined, or else the default string already on the
% stack
% (like ``Master's thesis'' or ``PhD thesis'').\footnote{This
% comment by Oren Patashnik.}
%
% \spec{\item One string, representing the default label for a
% thesis}
% {\item One string, to stand as the label for a thesis}
% {\option{none}}
%    \begin{macrocode}
%<*oldbdoc>
FUNCTION {format.thesis.type}
{ type empty$
'skip$
{ pop$
type "t" change.case$
}
if$
}
%</oldbdoc>
%    \end{macrocode}
%
% \DescribeEnv{format.tr.number}
% The function "format.tr.number" makes a string starting with
% ``Technical Report''
% (or type, if that field is defined), followed by the number if
% there is one;
% it returns the starting part (with a case change) even if there
% is no number.
% This is used at the beginning of a sentence.\footnote{This
% comment by Oren Patashnik.}
%
% \spec{\item none}
% {\item One string, the label for a technical report}
% {\option{none}}
%
%    \begin{macrocode}
%<*oldbdoc>
FUNCTION {format.tr.number}
{ type empty$
{ "Technical Report" }
'type
if$
number empty$
{ "t" change.case$ }
{ number tie.or.space.connect }
if$
}
%</oldbdoc>
%    \end{macrocode}
%
% \subsubsection{Entry type functions}
% Now we define the type functions for all entry types that may
% appear
% in the {\tt*.bib} file---e.g., functions like `"article"' and 
% `"book"'.  These
% are the routines that actually generate the "*.bbl" file output
% for
% the entry.  These must all precede the "READ" command.  In
% addition, the
% style designer should have a function `"default.type"' for
% unknown types.\footnote{This comment by Oren Patashnik.}
% 
% \DescribeEnv{article}
% This function performs the necessary operations for
% exporting a valid \LexiTeX\ citation to an article.
% For this and for all citation types defined in the
% \LexiBib{} style, the goal is to provide reasonably
% complete commentary, so that anyone wanting to
% alter the behaviour of the style can set to work
% with a fair degree of confidence about what needs to
% be done to achieve a particular result.
%    \begin{macrocode}
FUNCTION { article }
%    \end{macrocode}
% The "article" entry is used for all kinds of material, so
% it ends up as one of the most complex entries.  Before we
% do anything, we have to check whether the default \LexiTeX{}
% bridges are acceptable.  If the volume and the number are both
% non-empty, we need to add a special set of substitute bridges.
%    \begin{macrocode}
{ volume empty$ number empty$ and not
  { "\bridges{,\ p.~}{,\ }{,\ }{\ at~}{\ at~}" 
    "" "" must.must.must 
    newline$ }
  'skip$
  if$
%    \end{macrocode}
% Then we write the citation leader, to prepare for outputting the
% actual content of the citation text.
%    \begin{macrocode}
 "\lexibib{article}{" cite$ "}{" must.must.must 
%    \end{macrocode}
% The author name is pushed to the stack, followed by a toggle
% to trigger last-name-only formatting.  Then the "format.names"
% reduces this to a single, appropriately-formatted string,
% possibly the null string.  All that is left to do is push a
% set a braces, a null string to make up three arguments to the
% export routine, and write the lot on the output
% file unconditionally, using "must.must.must".
%    \begin{macrocode}
author  "lastonly" format.names
"}{"
""
must.must.must
%    \end{macrocode}
% Next comes the title of the article.  This is not specially
% formatted; we simply push the title field, then a warning
% string
% followed by a check for whether it is empty or not, then
% braces and a null string, and write again.
%    \begin{macrocode}
title "title" check
"}{"
""
must.must.must
%    \end{macrocode}
% The next bit is actually rather thorny.  Our first
% formatting decision is based on whether or not there
% is a "volume" for this source.  If not, we adopt a
% Commonwealth-style citation scheme, using the bracketed
% year for the volume.  This will be coupled with suppression
% of the year in the final LexiTeX ``field''.
%    \begin{macrocode}
volume empty$
  { "[" year format.date theyear "] " must.must.must
    number  "\ " journal "journal" check might.ifone.must
  }
%    \end{macrocode}
% If there {{\em is\/} a volume, we make different formatting
% decisions, depending on
% whether an issue number exists for this source.
%    \begin{macrocode}
  { number empty$
%    \end{macrocode}
% If there is no number, we do as follows.  We
% push the volume, providing
% a warning if it it is empty, then
% a separating space, then the name of the journal, writing
% all three on the output, or just the journal name if the
% volume number is empty.  This is a nice illustration of
% the utility of the "might.ifone.must" export routine.
% The braces are pushed and written separately.
%    \begin{macrocode}
    { volume "volume" check
      "\ "
      journal  "journal" check
      might.ifone.must }
%    \end{macrocode}
% If the "number" field was non-empty, then we do as follows.
% The journal name goes up first, and is checked.  Then the
% bridge for the volume number, and the volume number itself
% go up, both being checked.  The "must.ifthree.might" export
% routine will drop the bridge and number, if the volume number
% was empty, although this will probably leave us with an incomplete
% (but nice-looking) citation anyway.  The we push a bridge to
% the number, the issue number, and a null string,
% and force all three on the
% output (no need for conditions in this last action, since we
% know already that "number" is non-empty.
%    \begin{macrocode}
    { journal "journal" check
      ", \\vol.~"
      volume "volume" check
      must.ifthree.might
      ", no.~" number "\\" must.must.must
    }if$
  }if$
%    \end{macrocode}
% Finally, we complete the second \LexiTeX{} argument
% and start the next.  The emply strings just take up space
% of course.
%    \begin{macrocode}
  "}{" "" "" must.must.must
%    \end{macrocode}
% The Blue Book does not like page ranges
% so we need to clean
% out anything following a dash in the "pages" field.  The
% "short" option
% toggles this behaviour on.  We also check to see that the page
% is not empty.  This is followed by braces, a null string, and
% output.
%    \begin{macrocode}
pages "short" format.pages "pages" check
"}{"
""
must.must.must
%    \end{macrocode}
% We add the year next, but only if the "volume" field is
% non-empty (if "volume" is empty, we'll have put the year
% is as a bracketed volume number, Commonwealth-style.
% We could use just the year (this is normal for Blue Book
% style, but we'll add the month for good measure, if it's
% been provided in the "year" field.
%    \begin{macrocode}
volume empty$
  'skip$
  { year format.date themonth "short" format.month.name
  "\ " theyear might.ifone.must
  }if$
%    \end{macrocode}
% Finally, we have to tangle with cross-references.
% Yuck.  (Not a complaint about \BibTeX, just a general
% response to the design problems inherent in the task).
% Formatting depends on whether there is a "crossref" entry.
% Hear that, guys?  If you don't use the "crossref" field,
% we'll short-change you on formatting service.
%    \begin{macrocode}
crossref empty$
%    \end{macrocode}
% If there is no "crossref", we just push a brace and a couple
% of nulls, and write.  Done!  Hurray!
%    \begin{macrocode}
{ "}" "" "" must.must.must }
%    \end{macrocode}
% But if there {\em was\/} a "crossref", we've go work to do.
% Darn.  The first thing we do is have a look at "booktitle".
% This should be non-null in this situation; there's no sense
% setting up a cross-reference to an individual volume of
% a journal unless there's something special to be said
% about it.
%    \begin{macrocode}
{ booktitle empty$
%    \end{macrocode}
% So if no "booktitle" is found, we whinge and format
% as for a no-cross-reference entry.
%    \begin{macrocode}
  { "no booktitle (name of special issue) for "
     cite$ "/" crossref * * * warning$
    "}" "" "" must.must.must }
%    \end{macrocode}
% If there {\em is\/} a "booktitle", though, 
% and if the "volume" field is non-empty (which
% means that we just printed, or at least should
% have printed, the year), we close the
% parens following the year (which is opened by \LexiTeX),
% and open another (which will be closed by \LexiTeX).
% That's it for conditional punctuation; we follow
% with "booktitle", which should be 
% the title or subject description of the special
% issue of the journal.
%    \begin{macrocode}
  { volume empty$ {""} {") ("} if$ booktitle "}" must.must.must}
  if$
}if$
%    \end{macrocode}
% Add a fresh new line in the export file, and we're done!  Whew!
%    \begin{macrocode}
newline$
}
%    \end{macrocode}
%
% \DescribeEnv{book}
% This is the entry for books, which includes individual
% volumes in a series, and multi-volume works with a single
% title.  Correct me if I'm wrong, but I think this latter
% citation type is not supported by \BibTeX.  \LexiBib{}
% manages it by allowing the user to specify the volume
% number in the text using the optional ":<number>:" argument to
% the "\lexicite" tag.
%    \begin{macrocode}
FUNCTION {book}
%    \end{macrocode}
% After the opener, we push the opening macro tag for a book
% entry, the nickname of the citation, and a couple of
% braces.  This is all mandatory and can safely be given
% unconditional export.
%    \begin{macrocode}
{ "\lexibib{book}{" cite$ "}{" must.must.must
%    \end{macrocode}
% A non-empty "volume" field means we need a leading
% volume number in the Blue Book style.  If a volume
% number (or anything else) is found in the "volume"
% field of a book entry, we replace it with a 
% "volno" macro.  This will expand in the document to
% whatever the author has specified using the optional
% ":<number>" argument to "\lexicite".  For example,
% volume 8 of "holdsworth" would be: "\lexicite:8:{holdsworth}".
%    \begin{macrocode}
  volume empty$
  { "" }
  { "\volno " }
  if$
%    \end{macrocode}
% The author comes first.  We push the contents of the
% "author" field, then the toggle string ``"firstinitial"'',
% and run  the "format.names" function to produce the name
% formatted properly for a book entry.  Then we push
% fa couple of braces
% and force all three items ("\volno" or null, author, and
% braces) onto the output.
%    \begin{macrocode}
  author
  "firstinitial" format.names "}{" must.must.must
%    \end{macrocode}
% The title is very straightforward.  We push the title, then
% check to be sure it's non-empty, then a couple of braces
% go up, filled out with a null string, and force all three
% onto the output.
%    \begin{macrocode}
  title "title" check "}{" "" must.must.must 
%    \end{macrocode}
% We're now in the final ``field'' of the \LexiTeX{} entry.
% This is mainly for the year, but we also give the 
% name of the editor(s) or translator(s) 
% if present.  If there is no
% editor or translator, we'll put a series name here, to help identify
% the source.  We don't put both, because this would
% confuse things (there can be book editors and
% series editors too, and the Blue Book style is 
% too streamlined to distinguish the two elegantly).
% So our first task is to see if there is an editor\ldots
%    \begin{macrocode}
    editor empty$ translator empty$ and
%    \end{macrocode}
% \ldots{} and if there is none, we put in a
% series name if it exists.  
% The "series" \BibTeX{} field should be used for the
% name of the series of which a volume forms a part,
% but some folks might accidentally use "booktitle".
% We'll be forgiving and accept it anyway.
%    \begin{macrocode}
    { series empty$ booktitle empty$ and
%    \end{macrocode}
%  If both
% "series" and "booktitle" are empty, we've nothing to do.
%    \begin{macrocode}
      'skip$
%    \end{macrocode}
% If at least one is non-empty, we push both,
% and cull them to just one using the "either.or" function.
% If only one is non-empty, this function leaves that one;
% if both are non-empty, the "either.or" function whinges
% and chooses one arbitrarily.
%
% Next, we push a bridge and a series item number,
% and a toggle for the "field.tag.no.combine" function.
% The "endlabel" toggle causes this function to put
% the bridge and the number after the series name,
% if a number exists, and push the lot back as a single
% item on the stack.  Otherwise it leaves just the series
% name.
%
% And last, we put up a comma to close, and do a mandatory
% export of the lot.
%    \begin{macrocode}
      { series booktitle either.or " No.~" number
      "endlabel" field.tag.no.combine ", " "" must.must.must }
      if$
    }
%    \end{macrocode}
% If either the editor or the translator fields were not empty,
% we format the editor or translator name
% instead, and put those details here.
%    \begin{macrocode}
    { editor translator either.or "firstinitial" format.names
%    \end{macrocode}
% We need to append the correct designator, either ``ed.''\ or
% ``trans.''.  The "either.or" function will use the second
% item pushed if both are non-empty, so we take advantage of
% this ``feature'' in making our choice of designators; the
% "ed." or "eds." strings are only used if the "translator"
% field is empty.  And finally, we push a null string to
% round out, and do a compulsory export.
%    \begin{macrocode}
      translator empty$
      { editor num.names$ #1 >
        { " eds.\ " }
        { " ed.\ " }
        if$
      }
      { " trans.\ " }
      if$
      "" must.must.must
    }if$
%    \end{macrocode}
% We also need to indicate the edition, if any.
%    \begin{macrocode}
  edition " ed.\ " "" might.ifone.must
%    \end{macrocode}
% The year itself is easy.  We push the year, do a check to issue
% a warning if necessary, then run format.date over it,
% which yields the year in "theyear", which can be pushed
% back onto the stack.  Then we fill out to six
% \LexiTeX{} fields in
% all, and do a compulsory export.
%    \begin{macrocode}
  year "year" check format.date theyear "}{}{}" "" must.must.must
%    \end{macrocode}
% A new line for a new macro, and we're done!  Rejoice!
% On to the next function definition!
%    \begin{macrocode}
  newline$
}
%    \end{macrocode}
%
% \DescribeEnv{incollection}
% This is for those nasty entries that are created when someone
% publishes an article in a collection of essays edited by someone
% else.
%    \begin{macrocode}
FUNCTION{incollection}
{ "\lexibib{article}{" cite$ "}{" must.must.must
  author "lastonly" format.names "author" check
  "}{" "" must.must.must
  title "title" check
  "}{" "" must.must.must
  chapter empty$
    { "" }
    { "\\" chapter " of \\" * * }
    if$
  booktitle "booktitle" check
  "}{" must.must.must
  pages "short" format.pages "pages" check
  "}{" "" must.must.must
% We're now in the final ``field'' of the \LexiTeX{} entry.
% The coding here is the same as for a "book" entry; the
% reader is referred to that entry for the commentary
% on the following code.
%    \begin{macrocode}
    editor empty$ translator empty$ and
    { series empty$ booktitle empty$ and
      'skip$
      { series booktitle either.or " No.~" number
      "endlabel" field.tag.no.combine ", " "" must.must.must }
      if$
    }
    { editor booktranslator either.or "firstinitial" format.names
      booktranslator empty$
      { editor num.names$ #1 >
        { " eds.\ " }
        { " ed.\ " }
        if$
      }
      { " trans.\ " }
      if$
      "" must.must.must
    }if$
  edition " ed.\ " "" might.ifone.must
  year "year" check format.date theyear "}" "" must.must.must
  newline$
}
%    \end{macrocode}
%
%    \begin{macrocode}
FUNCTION{booklet}
{ "\lexibib{man}{" cite$ "}{" must.must.must
  author "}{" "" must.must.must
  "\\" title "\\}{" must.must.must
  howpublished ", " "" might.ifone.must
  year "year" check format.date theyear
  "}{}{}" "" must.must.must
  newline$
}
%    \end{macrocode}
% \changes{1.0g}{1994/12/12}{Added the `techreport' function,
% to support draft article sent to Pedro Aphalo for comments.}
%    \begin{macrocode}
FUNCTION {techreport}
{"\lexibib{man}{" cite$ "}{" must.must.must
  author "full" format.names "author" check
  "}{" title "title" check must.must.must
  "}{"
  type empty$
    { "Technical report" }
    { type
    }if$
  " no.~" number "endlabel" field.tag.no.combine
  ", " must.must.must
  year format.date
  themonth empty$
  { "" }
  { themonth "short" format.month.name "\ " * }
  if$
  theyear
  "}{}{}{}" must.must.must
  newline$
  }
%    \end{macrocode}
%
% \paragraph{Cases} Law cases are all entered using the
% {\tt\string@CASE} entry type.  The formatting of citations
% varies from jurisdiction to jurisdiction, so the behaviour
% of citations of this type is controlled via a "jurisdiction"
% field.  Supported jurisdictions are listed in the user
% guide.  Below, the functions for each jurisdiction are
% defined first, followed by the "case" function itself.
%
% \DescribeEnv{j.case}
% This function applies to cases from Japan.
%    \begin{macrocode}
FUNCTION { j.case }
{ "\lexibib{jcase}{" cite$ "}{" must.must.must
 "Decision of the " court "court" check "" must.must.must
 " (" j.format.division ")" iftwo.might.iftwo  
 ", " "" "" must.must.must
  casedate format.date themonth "short" format.month.name "\ "
  theday must.must.must
  ", " theyear "}{" must.must.must
  volume empty$ not number empty$ not and
  { journal "journal" check ", no.~" number must.must.must
    ", vol.~" volume "" must.must.must }
  { volume number either.or "\ " journal "journal" check
  might.ifone.must
    "}{" pages "}{" must.must.must
  }if$
  year "year" check empty.to.null format.date
  themonth "short" format.month.name " " "" might.ifone.must
  theday ", " "" might.ifone.must
  theyear "}" "{}" must.must.must
  newline$
}
%    \end{macrocode}
%
% \DescribeEnv{e.case}
% This function applies to English cases.
%    \begin{macrocode}
FUNCTION { e.case }
{ "\lexibib{ecase}{" cite$ "}{" must.must.must
  title "title" check "}{" "" must.must.must
  year "year" check format.date "[" theyear "] " must.must.must
  journal "}{" "" must.must.must
  pages "short" format.pages "}" "{}{}{}" must.must.must
  newline$
}
%    \end{macrocode}
%
% \DescribeEnv{p.case}
% This function applies to Pakistani cases.
%    \begin{macrocode}
FUNCTION {p.case}
{e.case}
%    \end{macrocode}
%
% \DescribeEnv{us.case}
% This function applies to U.S. cases.
%    \begin{macrocode}
FUNCTION { us.case }
{"\lexibib{case}{" cite$ "}{" must.must.must
 title "title" check "}{" "" must.must.must
 volume "\ " journal must.must.must
 "}{" pages "}{" must.must.must
 court "court" check "\ " year format.date theyear
 might.ifone.must
 "}{}{}" "" "" must.must.must
 newline$
}
%    \end{macrocode}

% \DescribeEnv{case}
% This function simply reads the contents of the "jurisdiction"
% field, and invokes the appropriate case function.
%    \begin{macrocode}
FUNCTION { case }
 { jurisdiction empty.to.null duplicate$ "jurisdiction (sine qua non!)" check
   "japan" =
   { pop$ j.case }
   { duplicate$ "england" =
     { pop$ e.case }
     { duplicate$ "pakistan" =
       { pop$ p.case }
       { duplicate$ "singapore" =
         { pop$ e.case }
         { pop$ us.case
         }if$
       }if$
     }if$
   }if$
%    \end{macrocode}
% The following item adds annotations; this may be eliminated by
% stripping with "noannotes".
%    \begin{macrocode}
%<*!noannotes>
annote empty.to.null write$ newline$
%</!noannotes>
 }
%    \end{macrocode}
%
% \DescribeEnv{j.statute}
% This function applies to Japanese statutory materials.
% \changes{\LexiBib 1.0c}{94/08/03}{Added support for Japanese statutes.}
%    \begin{macrocode}
FUNCTION {j.statute}
 { "\lexibib{jstatute}{" cite$ "}{" must.must.must
   title "title" check "}{" "" must.must.must
   "Law no.~" number "number" check " of "
   iftwo.might.iftwo
   year format.date theyear "}{}{}{}" "" must.must.must
   newline$
 }
%    \end{macrocode}
%
% \DescribeEnv{s.statute}
% This function formats a statute entry for Singapore.
%    \begin{macrocode}
FUNCTION { s.statute }
{ "\lexibib{statute}{" cite$ "}{" must.must.must
  title "title" check ", No.~" number
  "got it" warning$ "endlabel" field.tag.no.combine
  number empty$
    { "\ " * }
    { "\ of " * }
    if$
  year format.date theyear "}{" must.must.must
  "}{}{}{}{}" "" "" must.must.must
  newline$
}
%    \end{macrocode}
%
% \DescribeEnv{statute}
% This function selects the correct statute entry function.
%    \begin{macrocode}
FUNCTION { statute }
 { jurisdiction empty.to.null duplicate$
   "japan" =
   { pop$ j.statute }
   { duplicate$ "singapore" =
     { pop$ s.statute }
     { pop$ "IMPORTANT: unknown jurisdiction for " cite$ * warning$
     }if$
   }if$
 }
%    \end{macrocode}
%
% \DescribeEnv{default.type}
% We use the "book" type as our default type.  When "manual" is
% completed, we should probably use that type instead.
%    \begin{macrocode}
FUNCTION {default.type} { book }
%</newbst>
%    \end{macrocode}
%
% 
% \subsection{Macro definitions}
% We don't define any macros for abbreviating law journal
% names.  Instead, we will use Blue Book abbreviations
% ``native'', with a special syntax (probably the full
% form in syntax: 
% ``"\gobble{Accountant}{}"'' immediately after
% the abbreviation) for resolving
% ambiguous abbreviations.  Meanwhile, trust me: use the
% Blue Book abbreviations and take this upcoming facility
% on faith.  And besides, do you ever {\em need\/} to spell
% out journal and reporter names?
%
% \subsection{Execution}
% With all preliminaries out of the way, our first act is
% to read in the entries from {\tt *.bib}..
%    \begin{macrocode}
%<*newbst>
READ
%    \end{macrocode}
% Then we say ``Hi'' to the user.  It would be nice to make this
% the first message, but the structure of \BibTeX{} style files
% dictates that it will follow any warnings about missing
% entries.
%    \begin{macrocode}
EXECUTE {hello}
%    \end{macrocode}
%
% \DescribeEnv{begin.bib}
% \DescribeEnv{end.bib}
% We need a couple of functions to write the starting and
% finishing strings on to output file.
%    \begin{macrocode}
FUNCTION {begin.bib}
 { "\begin{lexilist}" write$ newline$
 }
FUNCTION {end.bib}
 { "\end{lexilist}" write$ newline$
 }
%    \end{macrocode}
% Now we put it all together by running the entry-type
% function on each entry selected from the database in turn,
% bracketed by the starting and ending output functions
% just defined.
%    \begin{macrocode}
EXECUTE {begin.bib}
ITERATE {call.type$}
EXECUTE {end.bib}
%</newbst>
%    \end{macrocode}
% And, er, that's it!
%
% \section{Extraction utilities}
% \subsection{The Driver}
% Here is a simple driver for extracting the files in the
% package.
%    \begin{macrocode}
%<*driver>
\def\batchfile{lexibib.ins}
\input docstrip
\preamble
%
\endpreamble
\generateFile{lexibib.man}{t}{\from{lexibib.doc}{manual}}
\generateFile{lexitest.tex}{t}{\from{lexibib.doc}{testdoc}}
\postamble
\endpostamble
\generateFile{lexitest.bib}{t}{\from{lexibib.doc}{testbib}}
\generateFile{lexibib.bst}{t}{\from{lexibib.doc}{newbst}}
%</driver>
%    \end{macrocode}
% \subsection{The Manual}
% This is a simple driver that generates the documentation.
%    \begin{macrocode}
%<*manual>
\let\lawhline=\hline
\documentclass{ltxdoc}
\usepackage{lexitexm}
% \makebooktable
\EnableCrossrefs
\RecordChanges                  % Gather update information
\CodelineIndex                  % Index code by line number
%\OnlyDescription  % comment out for implementation details
\begin{document}
\DocInput{lexibib.doc}
\end{document}
%</manual>
%    \end{macrocode}
%    \begin{macrocode}
%<*testbib>
@STRING{tdc..="Tokyo District Court"}
@STRING{minjibu..="Civil Division"}
@STRING{ksh..="Kin'y{\=u} sh{\=o}ji hanrei"}
@PREAMBLE{ "\newcommand{\kk}{K.K. } "
          # "\newcommand{\v}{v.~} " }
@book{tanaka-tekisuto,
   author    = {Akira Tanaka and others},
   title     = {Tekisutobukku Tegata,  Kogitte H{\=o}},
   year      = {1987},
   publisher = {Y{\=u}hikaku Bukkusu},
   subject   = {commtrans}
}
@case{tdc.s57.9.27,
   journal   = ksh..,
   volume    = {663},
   annote    = {
       \holding{
       \item The Business Suspension Sanction of the Notes
Clearing Center falls
       within the terms of the explicit exemption of Notes and
Cheque Clearing
       Centers from the terms of Anti-Monopoly Act section 8, as
a practice
       necessary to the specialized function of such Centers.
       }},
   court     = tdc..,
   division  = minjibu..,
   divno     = {30},
   casedate  = {s57.9.27},
   page      = {35},
   jurisdiction = {j},
   subject   = {commtrans: aml attack on clearing system}
}
@book{horitsu-jiten,
   title     = {H\=oritsu jiten},
   year      = {s11.3.10},
   editor    = {? Suehiro and ? Tanaka},
   publisher = {Iwanami sh\=oten},
   volume    = {1},
   subject   = {general}
}
%</testbib>
%    \end{macrocode}
%    \begin{macrocode}
%<*testdoc>
\documentclass{article}
\usepackage{lexitex}
\begin{document}
\bibliography{lexitest}
\bibliographystyle{lexibib}
Waffle burble.\footnote{\lexicite{tanaka-tekisuto}.}
More waffle and burble.\footnote{\lexicite:2:{horitsu-jiten}.}
\lexicite{tdc.s57.9.27}:
\theholding
\end{document}
%</testdoc>
%    \end{macrocode}
%   \changes{no ver}{84/12/16}{   (HWT)       Original `plain'
% version, by Howard Trickey.}
%   \changes{no ver}{84/12/23}{     (LL)     Some comments made
% by Leslie Lamport.}
%    \changes{no ver}{85/2/16}{     (OP)     Changes based on
% LL's comments, Oren Patashnik.}
%    \changes{no ver}{85/2/17}{     (HWT)     Template file and
% other standard styles made.}
%    \changes{0.98b}{85/3/28}{     (OP)     First
% release,  for BibTeX 0.98f.}
%    \changes{0.98c}{85/5/9}{     (OP)      for BibTeX
% 0.98i:
%               fixed Theoretical Computer Science macro name;
%               fixed the format.vol.num.pages function.}
%    \changes{0.99a}{88/1/24}{     (OP)      for BibTeX
% 0.99a, main changes:
%               assignment operator (:=) arguments reversed;
%               the preamble$ function outputs the database
% PREAMBLE;
%               entry.max$ and global.max$ (built-in) variables
% replace
%               entry.string.max and global.string.max functions;
%               alphabetizing by year then title, not just title;
%               many unnecessary ties removed; \it ==> \em;
%               the `alpha' style uses a superscripted `+'
% instead of a
%               `*' for unnamed names in constructing the label;
%               the `abbrv' style now uses "Mar." and "Sept.";
%               the functions calc.label and presort now look at
% just
%               the fields they're supposed to;
%               BOOKLET, MASTERSTHESIS, TECHREPORT use nonbook
% titles;
%               INBOOK and INCOLLECTION take an optional type
% (e.g.
%               type = "Section"), overriding the default
% "chapter";
%               BOOK, INBOOK, INCOLLECTION, and PROCEEDINGS now
% allow
%               either volume or number, not just volume;
%               INCOLLECTION now allows an edition and series
% field;
%               PROCEEDINGS and INPROCEEDINGS now use the address
% field
%               to tell where a conference was held;
%               INPROCEEDINGS and PROCEEDINGS now allow either
% volume
%               or number, and also a series field;
%               MASTERSTHESIS and PHDTHESIS accept types other
% than
%               "Master's thesis" and "PhD thesis";
%               UNPUBLISHED now outputs, in one block, note then
% date;
%               MANUAL now prints out the organization in
%               the first block if the author field is empty;
%               MISC can't be empty---it requires some optional
% field.}
%    \changes{0.99b}{88/3/23}{     (OP)      For BibTeX
% 0.99c---changed the three
%               erroneous occurrences of `{\tt cite }'
% to `{\tt cite\$ }';
% this
%               change didn't affect the four standard styles,
% so the
%               0.99a versions of those styles are still
% current.}
%
%    \changes{\LexiBib{} 1.0}{94/6/12}{  (FB)   Copied into
% {\tt btxbst.doc} to {\tt lexibib.doc} and commenced editing.}
% \changes {\LexiBib{} 1.0a}{94/7/25}{(FB) First successful
% trial of \LexiBib.}
% \changes{\LexiBib{} 1.0b}{94/8/9}{(FB) Completed first
% operational version, with date parsing, for use with
% articles, books and Japanese case materials.}
% \Finale \PrintIndex \PrintChanges



